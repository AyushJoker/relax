!function(e){function n(s){if(t[s])return t[s].exports;var r=t[s]={exports:{},id:s,loaded:!1};return e[s].call(r.exports,r,r.exports,n),r.loaded=!0,r.exports}var t={};return n.m=e,n.c=t,n.p="/",n(0)}([function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(161);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi tests\n// module id = 0\n// module chunks = 1\n//# sourceURL=webpack:///multi_tests?")},,,function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(4), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/keys.js\n// module id = 3\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/object/keys.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(5);\nmodule.exports = __webpack_require__(25).Object.keys;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/keys.js\n// module id = 4\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/object/keys.js?")},function(module,exports,__webpack_require__){eval("// 19.1.2.14 Object.keys(O)\nvar toObject = __webpack_require__(6);\nvar $keys = __webpack_require__(8);\n\n__webpack_require__(23)('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.keys.js\n// module id = 5\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es6.object.keys.js?")},function(module,exports,__webpack_require__){eval("// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(7);\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-object.js\n// module id = 6\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_to-object.js?")},function(module,exports){eval('// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError("Can\'t call method on  " + it);\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_defined.js\n// module id = 7\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_defined.js?')},function(module,exports,__webpack_require__){eval("// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(9);\nvar enumBugKeys = __webpack_require__(22);\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys.js\n// module id = 8\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-keys.js?")},function(module,exports,__webpack_require__){eval("var has = __webpack_require__(10);\nvar toIObject = __webpack_require__(11);\nvar arrayIndexOf = __webpack_require__(14)(false);\nvar IE_PROTO = __webpack_require__(18)('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys-internal.js\n// module id = 9\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-keys-internal.js?")},function(module,exports){eval("var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_has.js\n// module id = 10\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_has.js?")},function(module,exports,__webpack_require__){eval("// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(12);\nvar defined = __webpack_require__(7);\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-iobject.js\n// module id = 11\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_to-iobject.js?")},function(module,exports,__webpack_require__){eval("// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(13);\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iobject.js\n// module id = 12\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_iobject.js?")},function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_cof.js\n// module id = 13\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_cof.js?")},function(module,exports,__webpack_require__){eval("// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(11);\nvar toLength = __webpack_require__(15);\nvar toAbsoluteIndex = __webpack_require__(17);\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-includes.js\n// module id = 14\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_array-includes.js?")},function(module,exports,__webpack_require__){eval("// 7.1.15 ToLength\nvar toInteger = __webpack_require__(16);\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-length.js\n// module id = 15\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_to-length.js?")},function(module,exports){eval("// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-integer.js\n// module id = 16\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_to-integer.js?")},function(module,exports,__webpack_require__){eval("var toInteger = __webpack_require__(16);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-absolute-index.js\n// module id = 17\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_to-absolute-index.js?")},function(module,exports,__webpack_require__){eval("var shared = __webpack_require__(19)('keys');\nvar uid = __webpack_require__(21);\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared-key.js\n// module id = 18\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_shared-key.js?")},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(20);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function (key) {\n  return store[key] || (store[key] = {});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared.js\n// module id = 19\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_shared.js?")},function(module,exports){eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_global.js\n// module id = 20\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_global.js?")},function(module,exports){eval("var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_uid.js\n// module id = 21\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_uid.js?")},function(module,exports){eval("// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_enum-bug-keys.js\n// module id = 22\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_enum-bug-keys.js?")},function(module,exports,__webpack_require__){eval("// most Object methods by ES6 should accept primitives\nvar $export = __webpack_require__(24);\nvar core = __webpack_require__(25);\nvar fails = __webpack_require__(34);\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-sap.js\n// module id = 23\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-sap.js?")},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(20);\nvar core = __webpack_require__(25);\nvar ctx = __webpack_require__(26);\nvar hide = __webpack_require__(28);\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && key in exports) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_export.js\n// module id = 24\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_export.js?")},function(module,exports){eval("var core = module.exports = { version: '2.5.1' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_core.js\n// module id = 25\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_core.js?")},function(module,exports,__webpack_require__){eval("// optional / simple context binding\nvar aFunction = __webpack_require__(27);\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ctx.js\n// module id = 26\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_ctx.js?")},function(module,exports){eval("module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_a-function.js\n// module id = 27\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_a-function.js?")},function(module,exports,__webpack_require__){eval("var dP = __webpack_require__(29);\nvar createDesc = __webpack_require__(37);\nmodule.exports = __webpack_require__(33) ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_hide.js\n// module id = 28\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_hide.js?")},function(module,exports,__webpack_require__){eval("var anObject = __webpack_require__(30);\nvar IE8_DOM_DEFINE = __webpack_require__(32);\nvar toPrimitive = __webpack_require__(36);\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(33) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dp.js\n// module id = 29\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-dp.js?")},function(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(31);\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_an-object.js\n// module id = 30\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_an-object.js?")},function(module,exports){eval("module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-object.js\n// module id = 31\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_is-object.js?")},function(module,exports,__webpack_require__){eval("module.exports = !__webpack_require__(33) && !__webpack_require__(34)(function () {\n  return Object.defineProperty(__webpack_require__(35)('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ie8-dom-define.js\n// module id = 32\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_ie8-dom-define.js?")},function(module,exports,__webpack_require__){eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(34)(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_descriptors.js\n// module id = 33\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_descriptors.js?")},function(module,exports){eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_fails.js\n// module id = 34\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_fails.js?")},function(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(31);\nvar document = __webpack_require__(20).document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_dom-create.js\n// module id = 35\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_dom-create.js?")},function(module,exports,__webpack_require__){eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(31);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-primitive.js\n// module id = 36\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_to-primitive.js?")},function(module,exports){eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_property-desc.js\n// module id = 37\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_property-desc.js?")},function(module,exports){eval('"use strict";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/classCallCheck.js\n// module id = 38\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/helpers/classCallCheck.js?')},function(module,exports,__webpack_require__){eval('"use strict";\n\nexports.__esModule = true;\n\nvar _defineProperty = __webpack_require__(40);\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/createClass.js\n// module id = 39\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/helpers/createClass.js?')},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(41), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/define-property.js\n// module id = 40\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/object/define-property.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(42);\nvar $Object = __webpack_require__(25).Object;\nmodule.exports = function defineProperty(it, key, desc) {\n  return $Object.defineProperty(it, key, desc);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/define-property.js\n// module id = 41\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/object/define-property.js?")},function(module,exports,__webpack_require__){eval("var $export = __webpack_require__(24);\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !__webpack_require__(33), 'Object', { defineProperty: __webpack_require__(29).f });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.define-property.js\n// module id = 42\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es6.object.define-property.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.replaceVariables = exports.relalgFromSQLAstRoot = exports.relalgFromRelalgAstRoot = exports.relalgFromRelalgAstNode = exports.textFromRelalgAstRoot = exports.textFromRelalgAstNode = exports.textFromGroupAstRoot = undefined;\n\nvar _keys = __webpack_require__(3);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _textFromAst = __webpack_require__(44);\n\nObject.defineProperty(exports, 'textFromGroupAstRoot', {\n\tenumerable: true,\n\tget: function get() {\n\t\treturn _textFromAst.textFromGroupAstRoot;\n\t}\n});\nObject.defineProperty(exports, 'textFromRelalgAstNode', {\n\tenumerable: true,\n\tget: function get() {\n\t\treturn _textFromAst.textFromRelalgAstNode;\n\t}\n});\nObject.defineProperty(exports, 'textFromRelalgAstRoot', {\n\tenumerable: true,\n\tget: function get() {\n\t\treturn _textFromAst.textFromRelalgAstRoot;\n\t}\n});\n\nvar _relalgFromAst = __webpack_require__(45);\n\nObject.defineProperty(exports, 'relalgFromRelalgAstNode', {\n\tenumerable: true,\n\tget: function get() {\n\t\treturn _relalgFromAst.relalgFromRelalgAstNode;\n\t}\n});\nObject.defineProperty(exports, 'relalgFromRelalgAstRoot', {\n\tenumerable: true,\n\tget: function get() {\n\t\treturn _relalgFromAst.relalgFromRelalgAstRoot;\n\t}\n});\nObject.defineProperty(exports, 'relalgFromSQLAstRoot', {\n\tenumerable: true,\n\tget: function get() {\n\t\treturn _relalgFromAst.relalgFromSQLAstRoot;\n\t}\n});\n\nvar _replaceVariables = __webpack_require__(152);\n\nObject.defineProperty(exports, 'replaceVariables', {\n\tenumerable: true,\n\tget: function get() {\n\t\treturn _replaceVariables.replaceVariables;\n\t}\n});\nexports.parseSQLSelect = parseSQLSelect;\nexports.parseSQLDump = parseSQLDump;\nexports.parseRelalg = parseRelalg;\nexports.parseRelalgGroup = parseRelalgGroup;\nexports.executeRelalg = executeRelalg;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar peg_parser_ra = __webpack_require__(153);\nvar peg_parser_sql = __webpack_require__(154);\n\nfunction parseSQLSelect(text) {\n\treturn peg_parser_sql.parse(text, { startRule: 'start' });\n}\nfunction parseSQLDump(text) {\n\treturn peg_parser_sql.parse(text, { startRule: 'dbDumpStart' });\n}\nfunction parseRelalg(text, relationNames) {\n\treturn peg_parser_ra.parse(text, { startRule: 'start', relationNames: relationNames });\n}\nfunction parseRelalgGroup(text) {\n\treturn peg_parser_ra.parse(text, { startRule: 'groupStart' });\n}\n\nfunction executeRelalg(text, relations) {\n\trelations = relations || {};\n\tvar ast = parseRelalg(text, (0, _keys2.default)(relations));\n\t(0, _replaceVariables.replaceVariables)(ast, relations);\n\tvar root = (0, _relalgFromAst.relalgFromRelalgAstRoot)(ast, relations);\n\troot.check();\n\treturn root;\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/relalg.js\n// module id = 43\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/relalg.js?")},function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.textFromGroupAstRoot = textFromGroupAstRoot;\nexports.textFromRelalgAstRoot = textFromRelalgAstRoot;\nexports.textFromRelalgAstNode = textFromRelalgAstNode;\n// builds the formated text version of a group\nfunction textFromGroupAstRoot(astRoot) {\n\t'use strict';\n\n\tif (astRoot.type !== 'groupRoot') throw new Error('wrong ast!?');\n\tvar s = '';\n\n\tfunction group_to_text(group) {\n\t\tvar s = '';\n\t\t// header\n\t\tfor (var name in group.headers) {\n\t\t\tif (!group.headers.hasOwnProperty(name)) continue;\n\n\t\t\ts += name + ':';\n\n\t\t\tif (group.headers[name].indexOf('\\n') !== -1) {\n\t\t\t\ts += '[[' + group.headers[name] + ']]\\n';\n\t\t\t} else s += group.headers[name] + '\\n';\n\t\t}\n\t\ts += '\\n';\n\n\t\t// body\n\t\tfor (var i = 0; i < group.assignments.length; i++) {\n\t\t\ts += group.assignments[i].name + ' = ';\n\t\t\ts += textFromRelalgAstNode(group.assignments[i].child);\n\t\t\ts += '\\n\\n';\n\t\t}\n\n\t\treturn s;\n\t}\n\n\tfor (var i = 0; i < astRoot.groups.length; i++) {\n\t\ts += group_to_text(astRoot.groups[i]);\n\n\t\tif (i !== astRoot.groups.length - 1) s += '\\n\\n\\n\\n';\n\t}\n\n\treturn s;\n}\n\n// builds the formated text version of a relalg root\nfunction textFromRelalgAstRoot(root) {\n\t'use strict';\n\n\tif (root.type !== 'root') throw new Error('wrong ast!?');\n\tvar s = '';\n\n\t// assignments\n\tfor (var i = 0; i < root.assignments.length; i++) {\n\t\ts += root.assignments[i].name + ' = ';\n\t\ts += textFromRelalgAstNode(root.assignments[i].child);\n\t\ts += '\\n\\n';\n\t}\n\n\ts += textFromRelalgAstNode(root.child);\n\n\treturn s;\n}\n\nfunction textFromRelalgAstNode(node) {\n\t'use strict';\n\n\tfunction unaryFormula(className, funcName, argument, body) {\n\t\tvar s = $('<span>'); //TODO: remove jquery!\n\t\tif (className !== null) s.addClass(className);\n\n\t\tif (funcName !== null) s.append(funcName);\n\n\t\tif (argument !== null) {\n\t\t\tvar sub = $('<sub>');\n\t\t\tsub.append(argument);\n\t\t\ts.append(' ').append(sub);\n\t\t}\n\n\t\tif (body !== null) s.append(' ( ').append(body).append(' ) ');\n\t\treturn s.text();\n\t}\n\n\tfunction binaryFormula(className, funcName, argument, child, child2) {\n\t\tvar s = $('<span>');\n\t\tif (className !== null) s.addClass(className);\n\n\t\ts.append('( ').append(child).append(' ) ');\n\n\t\ts.append(funcName);\n\t\tif (argument !== null) {\n\t\t\tvar sub = $('<sub>');\n\t\t\tsub.append(argument);\n\t\t\ts.append(sub);\n\t\t}\n\n\t\ts.append(' ( ').append(child2).append(' ) ');\n\t\treturn s.text();\n\t}\n\n\tfunction columnName(name, relAlias) {\n\t\tif (typeof name === 'number') name = '[' + name + ']';\n\n\t\tif (relAlias === null) return name;\n\t\treturn relAlias + '.' + name;\n\t}\n\n\tfunction comparison(className, comparator, child, child2, ltr) {\n\t\tvar s = $('<span>');\n\t\tif (className !== null) s.addClass(className);\n\n\t\tif (ltr === true) s.append(child);else s.append(child2);\n\n\t\tvar c = comparator;\n\n\t\t// nice comparator symbol\n\t\tswitch (comparator) {\n\t\t\tcase '!=':\n\t\t\t\tc = '≠';\n\t\t\t\tbreak;\n\t\t\tcase '>=':\n\t\t\t\tc = '≥';\n\t\t\t\tbreak;\n\t\t\tcase '<=':\n\t\t\t\tc = '≤';\n\t\t\t\tbreak;\n\t\t}\n\t\ts.append(c);\n\n\t\tif (ltr === true) s.append(child2);else s.append(child);\n\n\t\treturn s.text();\n\t}\n\n\tfunction booleanOp(className, operator, child, child2) {\n\t\tvar s = $('<span>');\n\t\tif (className !== null) s.addClass(className);\n\n\t\ts.append('(').append(child).append(') ');\n\t\ts.append(operator);\n\t\ts.append(' (').append(child2).append(')');\n\t\treturn s.text();\n\t}\n\n\tfunction value(val, type) {\n\t\tif (val === null || type === 'null') return 'null';\n\n\t\tif (val instanceof Date) return val.getFullYear() + '-' + (val.getMonth() + 1 < 10 ? '0' + (val.getMonth() + 1) : val.getMonth() + 1) + '-' + (val.getDate() < 10 ? '0' + val.getDate() : val.getDate());else if (typeof val === 'string') return \"'\" + val + \"'\";else if (typeof val === 'number') return val.toString();else throw new Error('unknown type ' + type);\n\t}\n\n\tfunction variable(name) {\n\t\tvar s = $('<span>');\n\t\ts.append(name);\n\t\treturn s.text();\n\t}\n\n\tfunction formatInlineTable(rows, delimiter, compact) {\n\t\t// calculate max length per column\n\t\tvar colLengths = [];\n\t\tif (compact === false) {\n\t\t\tfor (var i = 0; i < rows.length; i++) {\n\t\t\t\tfor (var j = 0; j < rows[i].length; j++) {\n\t\t\t\t\tvar length = rows[i][j].length;\n\t\t\t\t\tif (i === 0 || length > colLengths[j]) {\n\t\t\t\t\t\tcolLengths[j] = length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// build output\n\t\tvar s = '{\\n';\n\n\t\tfor (var _i = 0; _i < rows.length; _i++) {\n\t\t\tfor (var _j = 0; _j < rows[_i].length; _j++) {\n\t\t\t\tif (compact === false) {\n\t\t\t\t\t// pad with spaces (right)\n\t\t\t\t\trows[_i][_j] = rows[_i][_j] + new Array(colLengths[_j] + 1 - rows[_i][_j].length).join(' ');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (compact === false) {\n\t\t\t\ts += '\\t';\n\t\t\t}\n\t\t\ts += rows[_i].join(delimiter) + '\\n';\n\t\t}\n\n\t\treturn s + '}';\n\t}\n\n\tfunction rec(n) {\n\t\t// π σ ρ ←   ∧ ∨   ≠ = ¬ ≥ ≤   ∩ ∪ ÷ -   ✕ ⋈ ⟕ ⟖ ⟗ ⋉ ⋊\n\n\t\tswitch (n.type) {\n\t\t\tcase 'relation':\n\t\t\t\treturn unaryFormula(n.type, n.name, null, null);\n\n\t\t\tcase 'table':\n\t\t\t\t{\n\t\t\t\t\tvar rows = [];\n\n\t\t\t\t\t// header\n\t\t\t\t\tvar row = [];\n\t\t\t\t\tfor (var i = 0; i < n.columns.length; i++) {\n\t\t\t\t\t\tvar col = n.columns[i];\n\n\t\t\t\t\t\trow.push(columnName(col.name, col.relAlias) + ':' + col.type);\n\t\t\t\t\t}\n\t\t\t\t\trows.push(row);\n\n\t\t\t\t\t// rows\n\t\t\t\t\tfor (var _i2 = 0; _i2 < n.rows.length; _i2++) {\n\t\t\t\t\t\trow = [];\n\t\t\t\t\t\tfor (var j = 0; j < n.rows[_i2].length; j++) {\n\t\t\t\t\t\t\trow.push(value(n.rows[_i2][j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\trows.push(row);\n\t\t\t\t\t}\n\t\t\t\t\treturn formatInlineTable(rows, ', ', false);\n\t\t\t\t}\n\t\t\tcase 'selection':\n\t\t\t\treturn unaryFormula(n.type, 'σ', rec(n.arg), rec(n.child));\n\n\t\t\tcase 'projection':\n\t\t\t\t{\n\t\t\t\t\tvar args = [];\n\t\t\t\t\tfor (var _i3 = 0; _i3 < n.arg.length; _i3++) {\n\t\t\t\t\t\targs.push(columnName(n.arg[_i3].name, n.arg[_i3].relAlias));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn unaryFormula(n.type, 'π', args.join(', '), rec(n.child));\n\t\t\t\t}\n\t\t\tcase 'union':\n\t\t\t\treturn binaryFormula(n.type, '∪', null, rec(n.child), rec(n.child2));\n\n\t\t\tcase 'intersect':\n\t\t\t\treturn binaryFormula(n.type, '∩', null, rec(n.child), rec(n.child2));\n\n\t\t\tcase 'division':\n\t\t\t\treturn binaryFormula(n.type, '÷', null, rec(n.child), rec(n.child2));\n\n\t\t\tcase 'difference':\n\t\t\t\treturn binaryFormula(n.type, '-', null, rec(n.child), rec(n.child2));\n\n\t\t\tcase 'renameColumns':\n\t\t\t\t{\n\t\t\t\t\tvar _args = [];\n\t\t\t\t\tfor (var _i4 = 0; _i4 < n.arg.length; _i4++) {\n\t\t\t\t\t\tvar e = n.arg[_i4];\n\t\t\t\t\t\t_args.push(e.dst + '←' + columnName(e.src.name, e.src.relAlias));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn unaryFormula(n.type, 'ρ', _args.join(', '), rec(n.child));\n\t\t\t\t}\n\t\t\tcase 'renameRelation':\n\t\t\t\treturn unaryFormula(n.type, 'ρ', n.newRelAlias, rec(n.child));\n\n\t\t\tcase 'orderBy':\n\t\t\t\t{\n\t\t\t\t\tvar _args2 = [];\n\t\t\t\t\tfor (var _i5 = 0; _i5 < n.arg.length; _i5++) {\n\t\t\t\t\t\tvar _e = n.arg[_i5];\n\t\t\t\t\t\tvar s = columnName(_e.col.name, _e.col.relAlias) + ' ' + (_e.asc ? 'asc' : 'desc');\n\t\t\t\t\t\t_args2.push(s);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn unaryFormula(n.type, 'ψ', _args2.join(', '), rec(n.child));\n\t\t\t\t}\n\t\t\tcase 'groupBy':\n\t\t\t\t{\n\t\t\t\t\tvar argument = '';\n\t\t\t\t\tvar tmp = [];\n\n\t\t\t\t\t// group\n\t\t\t\t\tif (n.group.length > 0) {\n\t\t\t\t\t\tfor (var _i6 = 0; _i6 < n.group.length; _i6++) {\n\t\t\t\t\t\t\ttmp.push(columnName(n.group[_i6].name, n.group[_i6].relAlias));\n\t\t\t\t\t\t}\n\t\t\t\t\t\targument += tmp.join(', ') + ' ; ';\n\t\t\t\t\t}\n\n\t\t\t\t\t// aggregate\n\t\t\t\t\ttmp = [];\n\t\t\t\t\tfor (var _i7 = 0; _i7 < n.aggregate.length; _i7++) {\n\t\t\t\t\t\tvar f = n.aggregate[_i7];\n\t\t\t\t\t\t//tmp.push(f.name + '←');\n\n\t\t\t\t\t\tif (f.aggFunction == 'COUNT_ALL') tmp.push(f.name + ' ← COUNT(*)');else tmp.push(f.name + ' ← ' + f.aggFunction + '(' + columnName(f.col.name, f.col.relAlias) + ')');\n\t\t\t\t\t}\n\t\t\t\t\targument += tmp.join(', ');\n\n\t\t\t\t\treturn unaryFormula(n.type, 'γ', argument, rec(n.child));\n\t\t\t\t}\n\t\t\tcase 'thetaJoin':\n\t\t\t\treturn binaryFormula(n.type, '⋈', rec(n.arg), rec(n.child), rec(n.child2));\n\n\t\t\tcase 'crossJoin':\n\t\t\t\treturn binaryFormula(n.type, '⨯', null, rec(n.child), rec(n.child2));\n\n\t\t\tcase 'naturalJoin':\n\t\t\t\treturn binaryFormula(n.type, '⋈', null, rec(n.child), rec(n.child2));\n\n\t\t\tcase 'leftSemiJoin':\n\t\t\t\treturn binaryFormula(n.type, '⋉', null, rec(n.child), rec(n.child2));\n\n\t\t\tcase 'rightSemiJoin':\n\t\t\t\treturn binaryFormula(n.type, '⋊', null, rec(n.child), rec(n.child2));\n\n\t\t\tcase 'antiJoin':\n\t\t\t\treturn binaryFormula(n.type, '▷', null, rec(n.child), rec(n.child2));\n\n\t\t\tcase 'leftOuterJoin':\n\t\t\t\t{\n\t\t\t\t\tvar condition = n.arg === null ? null : rec(n.arg);\n\t\t\t\t\treturn binaryFormula(n.type, '⟕', condition, rec(n.child), rec(n.child2));\n\t\t\t\t}\n\t\t\tcase 'rightOuterJoin':\n\t\t\t\t{\n\t\t\t\t\tvar _condition = n.arg === null ? null : rec(n.arg);\n\t\t\t\t\treturn binaryFormula(n.type, '⟖', _condition, rec(n.child), rec(n.child2));\n\t\t\t\t}\n\t\t\tcase 'fullOuterJoin':\n\t\t\t\t{\n\t\t\t\t\tvar _condition2 = n.arg === null ? null : rec(n.arg);\n\t\t\t\t\treturn binaryFormula(n.type, '⟗', _condition2, rec(n.child), rec(n.child2));\n\t\t\t\t}\n\n\t\t\tcase 'ConditionConst':\n\t\t\t\treturn unaryFormula(n.type, n.value + '', null, null);\n\n\t\t\tcase 'ConditionAnd':\n\t\t\t\treturn booleanOp(n.type, '∧', rec(n.child), rec(n.child2));\n\n\t\t\tcase 'ConditionNot':\n\t\t\t\treturn unaryFormula(n.type, '¬', null, rec(n.child));\n\n\t\t\tcase 'ConditionOr':\n\t\t\t\treturn booleanOp(n.type, '∨', rec(n.child), rec(n.child2));\n\n\t\t\tcase 'ConditionColEqualsValue':\n\t\t\t\treturn comparison(n.type, n.comperator, columnName(n.col.name, n.col.relAlias), value(n.value, n.valType), n.ltr);\n\n\t\t\tcase 'ConditionColEqualsCol':\n\t\t\t\treturn comparison(n.type, n.comperator, columnName(n.col.name, n.col.relAlias), columnName(n.col2.name, n.col2.relAlias), false);\n\n\t\t\tcase 'variable':\n\t\t\t\treturn variable(n.name);\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('type ' + n.type + ' not implemented');\n\t\t}\n\t}\n\n\treturn rec(node);\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/translate/textFromAst.js\n// module id = 44\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/translate/textFromAst.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.relalgFromSQLAstRoot = relalgFromSQLAstRoot;\nexports.relalgFromRelalgAstRoot = relalgFromRelalgAstRoot;\nexports.relalgFromRelalgAstNode = relalgFromRelalgAstNode;\n\nvar _ValueExpr = __webpack_require__(46);\n\nvar ValueExpr = _interopRequireWildcard(_ValueExpr);\n\nvar _Schema = __webpack_require__(101);\n\nvar _Column = __webpack_require__(100);\n\nvar _Table = __webpack_require__(102);\n\nvar _RANode = __webpack_require__(133);\n\nvar _Projection = __webpack_require__(134);\n\nvar _Union = __webpack_require__(135);\n\nvar _Intersect = __webpack_require__(136);\n\nvar _Division = __webpack_require__(137);\n\nvar _Difference = __webpack_require__(138);\n\nvar _Selection = __webpack_require__(141);\n\nvar _GroupBy = __webpack_require__(142);\n\nvar _OrderBy = __webpack_require__(143);\n\nvar _InnerJoin = __webpack_require__(144);\n\nvar _LeftOuterJoin = __webpack_require__(145);\n\nvar _RightOuterJoin = __webpack_require__(146);\n\nvar _FullOuterJoin = __webpack_require__(147);\n\nvar _CrossJoin = __webpack_require__(139);\n\nvar _SemiJoin = __webpack_require__(148);\n\nvar _AntiJoin = __webpack_require__(149);\n\nvar _RenameColumns = __webpack_require__(150);\n\nvar _RenameRelation = __webpack_require__(151);\n\nvar _Relation = __webpack_require__(132);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// translate a SQL-AST to RA\nfunction relalgFromSQLAstRoot(astRoot, relations) {\n\t\"use strict\";\n\n\tfunction setCodeInfoFromNode(raNode, astNode) {\n\t\tif (!astNode.codeInfo) {\n\t\t\tthrow new Error('should not happen');\n\t\t}\n\n\t\traNode.setCodeInfoObject(astNode.codeInfo);\n\t}\n\n\tfunction getError(msg, codeInfo) {\n\t\tvar error = new Error(msg);\n\t\terror.codeInfo = codeInfo;\n\t\treturn error;\n\t}\n\n\tfunction rec(n) {\n\t\tvar node, rel;\n\t\tvar a, b, tmp, i;\n\t\tvar condition;\n\t\tif (typeof n.cond !== 'undefined') condition = n.cond === null || n.cond instanceof Array ? n.cond : rec(n.cond);\n\n\t\tswitch (n.type) {\n\t\t\tcase 'relation':\n\t\t\t\tif (typeof relations[n.name] == 'undefined') {\n\t\t\t\t\tthrow getError(i18n.t('db.messages.translate.error-relation-not-found', { name: n.name }), n.codeInfo);\n\t\t\t\t}\n\t\t\t\trel = relations[n.name].copy();\n\t\t\t\tif (n.relAlias === null) {\n\t\t\t\t\tnode = rel;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnode = new _RenameRelation.RenameRelation(rel, n.relAlias);\n\t\t\t\tbreak;\n\n\t\t\tcase 'valueExpr':\n\t\t\t\tif (n.datatype == 'null' && n.func === 'columnValue') {\n\t\t\t\t\tnode = new ValueExpr.ValueExprColumnValue(n.args[0], n.args[1]);\n\t\t\t\t} else {\n\t\t\t\t\tswitch (n.datatype) {\n\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tcase 'date':\n\t\t\t\t\t\tcase 'null':\n\t\t\t\t\t\t\t// all with unknown type\n\t\t\t\t\t\t\ttmp = [];\n\t\t\t\t\t\t\tfor (i = 0; i < n.args.length; i++) {\n\t\t\t\t\t\t\t\tif (n.func === 'constant') tmp.push(n.args[i]);else tmp.push(rec(n.args[i]));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnode = new ValueExpr.ValueExprGeneric(n.datatype, n.func, tmp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow 'not implemented yet';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'statement':\n\t\t\t\tnode = parseStatement(n);\n\n\t\t\t\tif (n.select.distinct === false) {\n\t\t\t\t\tnode.addWarning(i18n.t('db.messages.translate.warning-distinct-missing'), n.codeInfo);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'renameRelation':\n\t\t\t\tnode = new _RenameRelation.RenameRelation(rec(n.child), n.newRelAlias);\n\t\t\t\tbreak;\n\n\t\t\tcase 'relationFromSubstatement':\n\t\t\t\trel = rec(n.statement);\n\t\t\t\tnode = new _RenameRelation.RenameRelation(rel, n.relAlias);\n\t\t\t\tbreak;\n\n\t\t\tcase 'innerJoin':\n\t\t\t\tnode = new _InnerJoin.InnerJoin(rec(n.child), rec(n.child2), condition);\n\t\t\t\tbreak;\n\t\t\tcase 'leftOuterJoin':\n\t\t\t\tnode = new _LeftOuterJoin.LeftOuterJoin(rec(n.child), rec(n.child2), condition);\n\t\t\t\tbreak;\n\t\t\tcase 'rightOuterJoin':\n\t\t\t\tnode = new _RightOuterJoin.RightOuterJoin(rec(n.child), rec(n.child2), condition);\n\t\t\t\tbreak;\n\t\t\tcase 'fullOuterJoin':\n\t\t\t\tnode = new _FullOuterJoin.FullOuterJoin(rec(n.child), rec(n.child2), condition);\n\t\t\t\tbreak;\n\t\t\tcase 'crossJoin':\n\t\t\t\tnode = new _CrossJoin.CrossJoin(rec(n.child), rec(n.child2));\n\t\t\t\tbreak;\n\t\t\tcase 'naturalJoin':\n\t\t\t\tnode = new _InnerJoin.InnerJoin(rec(n.child), rec(n.child2), null);\n\t\t\t\tbreak;\n\n\t\t\tcase 'union':\n\t\t\t\tnode = new _Union.Union(rec(n.child), rec(n.child2));\n\t\t\t\tbreak;\n\t\t\tcase 'intersect':\n\t\t\t\tnode = new _Intersect.Intersect(rec(n.child), rec(n.child2));\n\t\t\t\tbreak;\n\t\t\tcase 'except':\n\t\t\t\tnode = new _Difference.Difference(rec(n.child), rec(n.child2));\n\t\t\t\tbreak;\n\n\t\t\tcase 'orderBy':\n\t\t\t\tnode = function (n) {\n\t\t\t\t\tvar orderCols = [];\n\t\t\t\t\tvar orderAsc = [];\n\t\t\t\t\tfor (i = 0; i < n.arg.value.length; i++) {\n\t\t\t\t\t\tvar e = n.arg.value[i];\n\n\t\t\t\t\t\torderAsc.push(e.asc);\n\t\t\t\t\t\torderCols.push(new _Column.Column(e.col.name, e.col.relAlias));\n\t\t\t\t\t}\n\t\t\t\t\tnode = new _OrderBy.OrderBy(rec(n.child), orderCols, orderAsc);\n\t\t\t\t\treturn node;\n\t\t\t\t}(n);\n\t\t\t\tbreak;\n\n\t\t\tcase 'limit':\n\t\t\t\tnode = function (n) {\n\t\t\t\t\tvar limit = n.limit;\n\t\t\t\t\tvar offset = n.offset;\n\n\t\t\t\t\tvar conditionOffset = new ValueExpr.ValueExprGeneric('boolean', '>', [new ValueExpr.ValueExprGeneric('number', 'rownum', []), new ValueExpr.ValueExprGeneric('number', 'constant', [offset])]);\n\n\t\t\t\t\tif (limit === -1) {\n\t\t\t\t\t\t// === LIMIT ALL => only offset\n\t\t\t\t\t\tnode = new _Selection.Selection(rec(n.child), conditionOffset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// limit and offset\n\t\t\t\t\t\tvar conditionLimit = new ValueExpr.ValueExprGeneric('boolean', '<=', [new ValueExpr.ValueExprGeneric('number', 'rownum', []), new ValueExpr.ValueExprGeneric('number', 'constant', [limit + offset])]);\n\t\t\t\t\t\tnode = new _Selection.Selection(rec(n.child), new ValueExpr.ValueExprGeneric('boolean', 'and', [conditionOffset, conditionLimit]));\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t}(n);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tvar e = new Error('type ' + n.type + ' not implemented');\n\t\t\t\te.line = n.codeInfo.location.start.line;\n\t\t\t\te.column = n.codeInfo.location.start.column;\n\t\t\t\te.codeInfo = n.codeInfo;\n\t\t\t\tthrow e;\n\t\t}\n\n\t\tif ((n.type === 'union' || n.type === 'intersect' || n.type === 'except') && n.all === true) {\n\t\t\tnode.addWarning(i18n.t('db.messages.translate.warning-ignored-all-on-set-operators'), n.codeInfo);\n\t\t}\n\n\t\tif (n.wrappedInBrackets === true) {\n\t\t\tnode.setWrappedInBrackets(true);\n\t\t}\n\n\t\tsetCodeInfoFromNode(node, n);\n\n\t\treturn node;\n\t}\n\n\tfunction getSelection(root, condition, codeInfo) {\n\t\troot.check();\n\t\treturn new _Selection.Selection(root, rec(condition));\n\t}\n\n\tfunction parseStatement(statement) {\n\t\tvar root, i;\n\t\tvar projectionArgs = statement.select.arg;\n\t\tvar col;\n\t\tvar projections;\n\n\t\t// from-CLAUSE\n\t\troot = rec(statement.from);\n\t\tsetCodeInfoFromNode(root, statement.from);\n\t\troot.check();\n\n\t\t// selection\n\t\tif (statement.where !== null) {\n\t\t\troot = getSelection(root, statement.where.arg, statement.where.codeInfo);\n\t\t\tsetCodeInfoFromNode(root, statement.where);\n\t\t}\n\n\t\t// groupby + aggregation\n\t\tif (statement.groupBy !== null || statement.numAggregationColumns > 0) {\n\t\t\tvar aggregateFunctions = [];\n\t\t\tvar groupByCols = statement.groupBy || [];\n\n\t\t\t// filter aggFunctions from SELECT list\n\t\t\tfor (i = 0; i < projectionArgs.length; i++) {\n\t\t\t\tcol = projectionArgs[i];\n\t\t\t\tif (col.type === 'aggFunction') aggregateFunctions.push(col);\n\t\t\t}\n\n\t\t\tif (aggregateFunctions.length > 0) root = new _GroupBy.GroupBy(root, groupByCols, aggregateFunctions);else {\n\t\t\t\t// use projection if no aggregation is used\n\t\t\t\tprojections = [];\n\t\t\t\tfor (i = 0; i < groupByCols.length; i++) {\n\t\t\t\t\tcol = groupByCols[i];\n\t\t\t\t\tprojections.push(new _Column.Column(col.name, col.relAlias));\n\t\t\t\t}\n\t\t\t\troot = new _Projection.Projection(root, projections);\n\t\t\t}\n\t\t}\n\n\t\t// having\n\t\tif (statement.having !== null) {\n\t\t\troot = getSelection(root, statement.having.arg, statement.having.codeInfo);\n\t\t\tsetCodeInfoFromNode(root, statement.having);\n\t\t}\n\n\t\t// projection\n\t\tvar colsRenamed = false;\n\t\tif (projectionArgs.length == 1 && projectionArgs[0].type === 'column' && projectionArgs[0].name === '*' && projectionArgs[0].relAlias === null) {\n\t\t\t// select * => no projection needed\n\t\t} else {\n\t\t\tprojections = [];\n\t\t\tfor (i = 0; i < projectionArgs.length; i++) {\n\t\t\t\tcol = projectionArgs[i];\n\n\t\t\t\tif (col.type === 'aggFunction') {\n\t\t\t\t\tprojections.push(new _Column.Column(col.name, null)); // has been renamed by gamma\n\t\t\t\t} else if (col.type === 'namedColumnExpr') {\n\t\t\t\t\tprojections.push({\n\t\t\t\t\t\tname: col.name,\n\t\t\t\t\t\trelAlias: col.relAlias,\n\t\t\t\t\t\tchild: rec(col.child)\n\t\t\t\t\t});\n\t\t\t\t} else if (col.type === 'column') {\n\t\t\t\t\t// normal columns\n\t\t\t\t\tprojections.push(new _Column.Column(col.name, col.relAlias));\n\n\t\t\t\t\tif (col.alias !== null) colsRenamed = true;\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'this should not happen';\n\t\t\t\t}\n\t\t\t}\n\t\t\troot = new _Projection.Projection(root, projections);\n\t\t\tsetCodeInfoFromNode(root, statement.select);\n\t\t}\n\n\t\t// rename columns\n\t\tif (colsRenamed === true) {\n\t\t\troot = new _RenameColumns.RenameColumns(root);\n\n\t\t\tfor (i = 0; i < projectionArgs.length; i++) {\n\t\t\t\tif (projectionArgs[i].type === 'column' && projectionArgs[i].alias !== null) {\n\t\t\t\t\troot.addRenaming(projectionArgs[i].alias, projectionArgs[i].name, projectionArgs[i].relAlias);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn root;\n\t}\n\n\treturn rec(astRoot.child);\n}\n\n// translates a RA-AST to RA\nfunction relalgFromRelalgAstRoot(astRoot, relations) {\n\t// root is the real root node! of a statement\n\treturn relalgFromRelalgAstNode(astRoot.child, relations);\n}\n\n/**\n * translates a RA-AST node to RA\n * @param   {Object} astNode   a node of a RA-AST\n * @param   {Object} relations hash of the relations that could be used in the statement\n * @returns {Object} an actual RA-expression\n */\nfunction relalgFromRelalgAstNode(astNode, relations) {\n\tfunction rec(n) {\n\t\tvar node;\n\t\tvar child, i, e, condition, tmp;\n\n\t\tswitch (n.type) {\n\t\t\tcase 'relation':\n\t\t\t\tif (typeof relations[n.name] == 'undefined') {\n\t\t\t\t\te = new Error(i18n.t('db.messages.translate.error-relation-not-found', { name: n.name }));\n\t\t\t\t\te.codeInfo = n.codeInfo;\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tnode = relations[n.name].copy();\n\t\t\t\tbreak;\n\n\t\t\tcase 'table':\n\t\t\t\tvar schema = new _Schema.Schema();\n\n\t\t\t\tvar col;\n\t\t\t\tfor (i = 0; i < n.columns.length; i++) {\n\t\t\t\t\tcol = n.columns[i];\n\t\t\t\t\tschema.addColumn(col.name, col.relAlias, col.type);\n\t\t\t\t}\n\n\t\t\t\tvar rel = new _Relation.Relation(n.name);\n\t\t\t\trel.setSchema(schema, true);\n\t\t\t\trel.addRows(n.rows);\n\t\t\t\trel.setMetaData('isInlineRelation', true);\n\t\t\t\trel.setMetaData('inlineRelationDefinition', n.codeInfo.text);\n\t\t\t\t//TODO: inlineRelationDefinition should be replaced; there should be a generic way to get the definition of a node\n\t\t\t\tnode = rel;\n\t\t\t\tbreak;\n\n\t\t\tcase 'selection':\n\t\t\t\tchild = rec(n.child);\n\t\t\t\tcondition = rec(n.arg);\n\t\t\t\tnode = new _Selection.Selection(child, condition);\n\t\t\t\tbreak;\n\n\t\t\tcase 'valueExpr':\n\t\t\t\tif (n.datatype == 'null' && n.func === 'columnValue') {\n\t\t\t\t\tnode = new ValueExpr.ValueExprColumnValue(n.args[0], n.args[1]);\n\t\t\t\t} else {\n\t\t\t\t\tswitch (n.datatype) {\n\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tcase 'date':\n\t\t\t\t\t\tcase 'null':\n\t\t\t\t\t\t\t// all with unknown type\n\t\t\t\t\t\t\ttmp = [];\n\t\t\t\t\t\t\tfor (i = 0; i < n.args.length; i++) {\n\t\t\t\t\t\t\t\tif (n.func === 'constant') tmp.push(n.args[i]);else tmp.push(rec(n.args[i]));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnode = new ValueExpr.ValueExprGeneric(n.datatype, n.func, tmp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow 'not implemented yet';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'projection':\n\t\t\t\tchild = rec(n.child);\n\t\t\t\tvar projections = [];\n\t\t\t\tfor (i = 0; i < n.arg.length; i++) {\n\n\t\t\t\t\te = n.arg[i];\n\n\t\t\t\t\tif (e.type === 'columnName') {\n\t\t\t\t\t\tprojections.push(new _Column.Column(e.name, e.relAlias));\n\t\t\t\t\t} else if (e.type === 'namedColumnExpr') {\n\t\t\t\t\t\t// namedColumnExpr\n\t\t\t\t\t\tprojections.push({\n\t\t\t\t\t\t\tname: e.name,\n\t\t\t\t\t\t\trelAlias: e.relAlias,\n\t\t\t\t\t\t\tchild: rec(e.child)\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'should not happen';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnode = new _Projection.Projection(child, projections);\n\t\t\t\tbreak;\n\n\t\t\tcase 'orderBy':\n\t\t\t\tchild = rec(n.child);\n\t\t\t\tvar orderCols = [];\n\t\t\t\tvar orderAsc = [];\n\n\t\t\t\tfor (i = 0; i < n.arg.length; i++) {\n\t\t\t\t\te = n.arg[i];\n\n\t\t\t\t\torderAsc.push(e.asc);\n\t\t\t\t\torderCols.push(new _Column.Column(e.col.name, e.col.relAlias));\n\t\t\t\t}\n\n\t\t\t\tnode = new _OrderBy.OrderBy(child, orderCols, orderAsc);\n\t\t\t\tbreak;\n\n\t\t\tcase 'groupBy':\n\t\t\t\tchild = rec(n.child);\n\t\t\t\tvar aggregateFunctions = n.aggregate;\n\t\t\t\tvar groupByCols = n.group;\n\n\t\t\t\tnode = new _GroupBy.GroupBy(child, groupByCols, aggregateFunctions);\n\t\t\t\tbreak;\n\n\t\t\tcase 'union':\n\t\t\t\tnode = new _Union.Union(rec(n.child), rec(n.child2));\n\t\t\t\tbreak;\n\n\t\t\tcase 'intersect':\n\t\t\t\tnode = new _Intersect.Intersect(rec(n.child), rec(n.child2));\n\t\t\t\tbreak;\n\n\t\t\tcase 'division':\n\t\t\t\tnode = new _Division.Division(rec(n.child), rec(n.child2));\n\t\t\t\tbreak;\n\n\t\t\tcase 'difference':\n\t\t\t\tnode = new _Difference.Difference(rec(n.child), rec(n.child2));\n\t\t\t\tbreak;\n\n\t\t\tcase 'renameColumns':\n\t\t\t\tvar ren = new _RenameColumns.RenameColumns(rec(n.child));\n\n\t\t\t\tfor (i = 0; i < n.arg.length; i++) {\n\t\t\t\t\te = n.arg[i];\n\n\t\t\t\t\tren.addRenaming(e.dst, e.src.name, e.src.relAlias);\n\t\t\t\t}\n\n\t\t\t\tnode = ren;\n\t\t\t\tbreak;\n\n\t\t\tcase 'renameRelation':\n\t\t\t\tnode = new _RenameRelation.RenameRelation(rec(n.child), n.newRelAlias);\n\t\t\t\tbreak;\n\n\t\t\tcase 'thetaJoin':\n\t\t\t\tcondition = rec(n.arg);\n\t\t\t\tnode = new _InnerJoin.InnerJoin(rec(n.child), rec(n.child2), condition);\n\t\t\t\tbreak;\n\n\t\t\tcase 'crossJoin':\n\t\t\t\tnode = new _CrossJoin.CrossJoin(rec(n.child), rec(n.child2));\n\t\t\t\tbreak;\n\n\t\t\tcase 'naturalJoin':\n\t\t\t\tnode = new _InnerJoin.InnerJoin(rec(n.child), rec(n.child2), null);\n\t\t\t\tbreak;\n\n\t\t\tcase 'leftSemiJoin':\n\t\t\t\tnode = new _SemiJoin.SemiJoin(rec(n.child), rec(n.child2), true);\n\t\t\t\tbreak;\n\n\t\t\tcase 'rightSemiJoin':\n\t\t\t\tnode = new _SemiJoin.SemiJoin(rec(n.child), rec(n.child2), false);\n\t\t\t\tbreak;\n\n\t\t\tcase 'antiJoin':\n\t\t\t\tnode = new _AntiJoin.AntiJoin(rec(n.child), rec(n.child2));\n\t\t\t\tbreak;\n\n\t\t\tcase 'leftOuterJoin':\n\t\t\t\tcondition = n.arg === null ? null : rec(n.arg);\n\t\t\t\tnode = new _LeftOuterJoin.LeftOuterJoin(rec(n.child), rec(n.child2), condition);\n\t\t\t\tbreak;\n\n\t\t\tcase 'rightOuterJoin':\n\t\t\t\tcondition = n.arg === null ? null : rec(n.arg);\n\t\t\t\tnode = new _RightOuterJoin.RightOuterJoin(rec(n.child), rec(n.child2), condition);\n\t\t\t\tbreak;\n\n\t\t\tcase 'fullOuterJoin':\n\t\t\t\tcondition = n.arg === null ? null : rec(n.arg);\n\t\t\t\tnode = new _FullOuterJoin.FullOuterJoin(rec(n.child), rec(n.child2), condition);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\te = new Error('type ' + n.type + ' not implemented');\n\t\t\t\tif (n.codeInfo) {\n\t\t\t\t\te.codeInfo = n.codeInfo;\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t}\n\n\t\tnode.setCodeInfoObject(n.codeInfo);\n\n\t\tif (typeof n.metaData != 'undefined') {\n\t\t\tfor (var key in n.metaData) {\n\t\t\t\tif (!n.metaData.hasOwnProperty(key)) continue;\n\n\t\t\t\tnode.setMetaData(key, n.metaData[key]);\n\t\t\t}\n\t\t}\n\n\t\tif (n.wrappedInBrackets === true) {\n\t\t\tnode.setWrappedInBrackets(true);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\treturn rec(astNode);\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/translate/relalgFromAst.js\n// module id = 45\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/translate/relalgFromAst.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.ValueExprGeneric = exports.ValueExprColumnValue = exports.ValueExpr = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _escape = __webpack_require__(95);\n\nvar _escape2 = _interopRequireDefault(_escape);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _Column = __webpack_require__(100);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar MILLI_SEC_PER_DAY = 24 * 3600 * 1000;\n\nif (!_escape2.default) {\n\t/**\n  * polyfill for RegExp.escape\n  * src: https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js\n  *\n  * @param s\n  * @returns {string}\n  */\n\tRegExp.escape = function (s) {\n\t\treturn String(s).replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\t};\n}\n\n/**\n * the base class for all valueExpressions\n *\n * the calculation of an expression must follow the folowing 3 steps:\n * - the instances of the operators get plugged together building a operator tree\n *   at this stage no checking is done\n * - the `check()` function  is called recursivly to check the correct nesting\n *   of the expressions like schema compability or existance of columns\n *   used in an projection\n *   The `check()` function also calculates the output schema for the specific\n *   operator.\n * - after check has been called the actual result is calculated when `evaluate()` is called\n * @constructor\n * @returns {ValueExpr}\n * @abstract\n */\n\nvar ValueExpr = exports.ValueExpr = function () {\n\tfunction ValueExpr() {\n\t\t(0, _classCallCheck3.default)(this, ValueExpr);\n\n\t\tthis.func = null;\n\t\tthis.dataType = null;\n\t\tthis._wrappedInBrackets = false;\n\t}\n\n\t(0, _createClass3.default)(ValueExpr, [{\n\t\tkey: 'setCodeInfoObject',\n\t\tvalue: function setCodeInfoObject(codeInfo) {\n\t\t\tthis._codeInfo = codeInfo;\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: 'throwExecutionError',\n\t\tvalue: function throwExecutionError(message) {\n\t\t\tthrow new _ExecutionError.ExecutionError(message, this._codeInfo);\n\t\t}\n\n\t\t/**\n   * evaluates the _checked_ expression against one or two given tuples\n   * if two tuples are given they are considered to be concatinated\n   * @param {Array}  tuple            a tuple of a relation\n   * @param {Array}  tupleB           a second tuple (that is meant to be seen as the right part of the first)\n   * @param {Number} row              the index of the index (this is used for some functions)\n   * @param {Object} statementSession the session object of the relalg statement\n   * @abstract\n   */\n\n\t}, {\n\t\tkey: 'evaluate',\n\t\tvalue: function evaluate(tuple, tupleB, row, statementSession) {\n\t\t\tthrow new Error('not implemented: needs to be overwritten');\n\t\t}\n\n\t\t/**\n   * get the datatype that is returned by this expression\n   * @abstract\n   */\n\n\t}, {\n\t\tkey: 'getDataType',\n\t\tvalue: function getDataType() {\n\t\t\tthrow new Error('not implemented: needs to be overwritten');\n\t\t}\n\n\t\t/**\n   * this method must be called before calling evaluate\n   * with the schema(s) the tuples will be part of\n   *\n   * in this step the column names are checked and the indices\n   * (used by evaluate) are calculated\n   * @param {Schema} schemaA the schema for the first tuple\n   * @param {Schema} schemaB the schema for the second tuple\n   * @abstract\n   */\n\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check(schemaA, schemaB) {\n\t\t\tthrow new Error('not implemeted: needs to be overwritten');\n\t\t}\n\n\t\t/**\n   * gets a html representation of the expression (as String)\n   * @abstract\n   */\n\n\t}, {\n\t\tkey: 'getFormulaHtml',\n\t\tvalue: function getFormulaHtml() {\n\t\t\tthrow new Error('not implemeted: needs to be overwritten');\n\t\t}\n\n\t\t/**\n   * sets the indicator wether the expression was wrapped in brackets in the code\n   * this is used for getFormulaHtml because at this stage there is no more information\n   * about the precedence of the operators and how the expression was created\n   * @param {Boolean} wrappedInBrackets true when this (sub) expression was wrapped in brackets\n   */\n\n\t}, {\n\t\tkey: 'setWrappedInBrackets',\n\t\tvalue: function setWrappedInBrackets(wrappedInBrackets) {\n\t\t\tthis._wrappedInBrackets = wrappedInBrackets === undefined ? true : wrappedInBrackets;\n\t\t}\n\t}]);\n\treturn ValueExpr;\n}();\n\n/**\n * value expression with no predefined datatype\n * @constructor\n * @param {String}               name                   the name of a column\n * @param {String}               relAlias               the relation alias of the column\n * @param {Number}               manuallySetColumnIndex the index of the column described; this allows\n *                                                      to set the index within a schema because sometimes\n *                                                      it can not be determined by the check function\n * @returns {ValueExprColumnValue}\n */\n\n\nvar ValueExprColumnValue = exports.ValueExprColumnValue = function (_ValueExpr) {\n\t(0, _inherits3.default)(ValueExprColumnValue, _ValueExpr);\n\n\tfunction ValueExprColumnValue(name, relAlias, manuallySetColumnIndex) {\n\t\t(0, _classCallCheck3.default)(this, ValueExprColumnValue);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (ValueExprColumnValue.__proto__ || (0, _getPrototypeOf2.default)(ValueExprColumnValue)).call(this));\n\n\t\t_this._name = name;\n\t\t_this._relAlias = relAlias;\n\t\t_this._index = null;\n\n\t\tif (typeof manuallySetColumnIndex !== 'undefined') {\n\t\t\t_this._index = manuallySetColumnIndex;\n\t\t}\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(ValueExprColumnValue, [{\n\t\tkey: 'getDataType',\n\t\tvalue: function getDataType() {\n\t\t\treturn this._type;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check(schemaA, schemaB) {\n\t\t\tif (this._index === null) {\n\t\t\t\t// the index has not been set manually\n\t\t\t\tthis._index = ValueExprColumnValue._getColumnIndex(schemaA, schemaB, this._name, this._relAlias);\n\t\t\t}\n\t\t\tthis._type = ValueExprColumnValue._getType(schemaA, schemaB, this._index);\n\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: 'evaluate',\n\t\tvalue: function evaluate(tupleA, tupleB, row, statementSession) {\n\t\t\tif (this._index >= tupleA.length) {\n\t\t\t\treturn tupleB[this._index - tupleA.length];\n\t\t\t}\n\t\t\treturn tupleA[this._index];\n\t\t}\n\t}, {\n\t\tkey: 'toString',\n\t\tvalue: function toString() {\n\t\t\treturn _Column.Column.printColumn(this._name, this._relAlias);\n\t\t}\n\t}, {\n\t\tkey: 'getFormulaHtml',\n\t\tvalue: function getFormulaHtml() {\n\t\t\tvar s = _Column.Column.printColumn(this._name, this._relAlias);\n\t\t\tif (this._wrappedInBrackets === true) {\n\t\t\t\treturn '(' + s + ')';\n\t\t\t} else {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t}], [{\n\t\tkey: '_getColumnIndex',\n\t\tvalue: function _getColumnIndex(schemaA, schemaB, name, relAlias) {\n\t\t\tif (!schemaB || schemaB === null) {\n\t\t\t\treturn schemaA.getColumnIndex(name, relAlias, true);\n\t\t\t}\n\n\t\t\t// if 2 schemas are given make sure the given relAlias.name is not ambiguous\n\t\t\tvar index = schemaA.getColumnIndex(name, relAlias, false);\n\t\t\tif (index == -1) {\n\t\t\t\t// must be in schemaB!\n\t\t\t\treturn schemaB.getColumnIndex(name, relAlias, true) + schemaA.getSize();\n\t\t\t} else {\n\t\t\t\tif (schemaB.getColumnIndex(name, relAlias, false) != -1) {\n\t\t\t\t\t// ambiguous!!\n\t\t\t\t\tthrow new Error('column ' + relAlias + '.' + name + ' found in both schemas: ' + schemaA.toString() + \" \" + schemaB.toString());\n\t\t\t\t} else {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_getType',\n\t\tvalue: function _getType(schemaA, schemaB, index) {\n\t\t\tif (index >= schemaA.getSize()) {\n\t\t\t\treturn schemaB.getType(index - schemaA.getSize());\n\t\t\t}\n\t\t\treturn schemaA.getType(index);\n\t\t}\n\t}]);\n\treturn ValueExprColumnValue;\n}(ValueExpr);\n\n/**\n * all value expressions that are not column values belong here\n * @constructor\n * @param {String} dataType the datatype the function returns\n * @param {String} func     the name of the function used\n * @param {Array}  args     array containing the specific arguments for the function\n */\n\n\nvar ValueExprGeneric = exports.ValueExprGeneric = function (_ValueExpr2) {\n\t(0, _inherits3.default)(ValueExprGeneric, _ValueExpr2);\n\n\tfunction ValueExprGeneric(dataType, func, args) {\n\t\t(0, _classCallCheck3.default)(this, ValueExprGeneric);\n\n\t\tvar _this2 = (0, _possibleConstructorReturn3.default)(this, (ValueExprGeneric.__proto__ || (0, _getPrototypeOf2.default)(ValueExprGeneric)).call(this));\n\n\t\t_this2._func = func;\n\t\t_this2._dataType = dataType;\n\t\t_this2._dataTypeCalculated = null;\n\t\t_this2._args = args || [];\n\t\treturn _this2;\n\t}\n\n\t(0, _createClass3.default)(ValueExprGeneric, [{\n\t\tkey: 'evaluate',\n\t\tvalue: function evaluate(tupleA, tupleB, row, statementSession) {\n\t\t\tswitch (this._dataType) {\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn this._evaluateString(tupleA, tupleB, row, statementSession);\n\t\t\t\tcase 'number':\n\t\t\t\t\treturn this._evaluateNumber(tupleA, tupleB, row, statementSession);\n\t\t\t\tcase 'boolean':\n\t\t\t\t\treturn this._evaluateBoolean(tupleA, tupleB, row, statementSession);\n\t\t\t\tcase 'date':\n\t\t\t\t\treturn this._evaluateDate(tupleA, tupleB, row, statementSession);\n\t\t\t\tcase 'null':\n\t\t\t\t\treturn this._evaluateNull(tupleA, tupleB, row, statementSession);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_parseIsoDate',\n\t\tvalue: function _parseIsoDate(str) {\n\t\t\tvar regex = /^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$/;\n\t\t\tvar groups = regex.exec(str);\n\n\t\t\tvar year = parseInt(groups[1], 10);\n\t\t\tvar month = parseInt(groups[2], 10) - 1;\n\t\t\tvar day = parseInt(groups[3], 10);\n\t\t\tvar date = new Date(year, month, day);\n\n\t\t\tif (date.getFullYear() != year || date.getMonth() != month || date.getDate() != day) {\n\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-invalid-date-format', { str: str }));\n\t\t\t}\n\t\t\treturn date;\n\t\t}\n\t}, {\n\t\tkey: '_evaluateNull',\n\t\tvalue: function _evaluateNull(tupleA, tupleB, row, statementSession) {\n\t\t\tvar i, value;\n\n\t\t\tif (this._func === 'constant') {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'constant':\n\t\t\t\t\treturn null;\n\t\t\t\tcase 'coalesce':\n\t\t\t\t\t// returns the first non null value or null if all are null\n\t\t\t\t\tfor (i = 0; i < this._args.length; i++) {\n\t\t\t\t\t\tvalue = this._args[i].evaluate(tupleA, tupleB, row, statementSession);\n\t\t\t\t\t\tif (value !== null) return value;\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\tcase 'caseWhen':\n\t\t\t\tcase 'caseWhenElse':\n\t\t\t\t\t// conditions are on i%2 === 0\n\t\t\t\t\t// values on i%2 === 1\n\n\t\t\t\t\t// see http://www.postgresql.org/docs/9.3/static/functions-conditional.html\n\t\t\t\t\tfor (i = 0; i < this._args.length; i += 2) {\n\t\t\t\t\t\tif (this._args[i].evaluate(tupleA, tupleB, row, statementSession) === true) {\n\t\t\t\t\t\t\treturn this._args[i + 1].evaluate(tupleA, tupleB, row, statementSession);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_evaluateDate',\n\t\tvalue: function _evaluateDate(tupleA, tupleB, row, statementSession) {\n\t\t\tvar a, b;\n\n\t\t\tif (this._func === 'transaction_timestamp' || this._func === 'statement_timestamp' || this._func === 'now' || this._func === 'clock_timestamp') {\n\t\t\t\t// dates are the same due to lack of transaction concept\n\t\t\t\t// now is alias of transaction_timestamp\n\t\t\t\treturn statementSession.statement_timestamp;\n\t\t\t}\n\n\t\t\ta = this._args[0].evaluate(tupleA, tupleB, row, statementSession);\n\t\t\tb = this._args.length > 1 && this._args[1].evaluate(tupleA, tupleB, row, statementSession);\n\n\t\t\tif (a === null || this._args.length > 1 && b === null) return null;\n\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'clock_timestamp':\n\t\t\t\t\treturn new Date();\n\n\t\t\t\tcase 'date':\n\t\t\t\t\treturn this._parseIsoDate(a);\n\t\t\t\tcase 'adddate':\n\t\t\t\t\treturn new Date(a.getTime() + b * MILLI_SEC_PER_DAY);\n\t\t\t\tcase 'subdate':\n\t\t\t\t\treturn new Date(a.getTime() - b * MILLI_SEC_PER_DAY);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_checkDate',\n\t\tvalue: function _checkDate(schemaA, schemaB) {\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'transaction_timestamp':\n\t\t\t\tcase 'statement_timestamp':\n\t\t\t\tcase 'clock_timestamp':\n\t\t\t\tcase 'now':\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase 'date':\n\t\t\t\t\treturn this._checkArgsDataType(schemaA, schemaB, ['string']);\n\n\t\t\t\tcase 'adddate':\n\t\t\t\tcase 'subdate':\n\t\t\t\t\treturn this._checkArgsDataType(schemaA, schemaB, ['date', 'number']);\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_evaluateBoolean',\n\t\tvalue: function _evaluateBoolean(tupleA, tupleB, row, statementSession) {\n\t\t\tvar a, b, typeA;\n\n\t\t\tif (this._func === 'constant') {\n\t\t\t\treturn this._args[0];\n\t\t\t}\n\n\t\t\ta = this._args[0].evaluate(tupleA, tupleB, row, statementSession);\n\t\t\tb = this._args.length > 1 && this._args[1].evaluate(tupleA, tupleB, row, statementSession);\n\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'not':\n\t\t\t\t\tif (a == 'unknown') return a;\n\t\t\t\t\treturn !a;\n\t\t\t\tcase 'and':\n\t\t\t\t\tif (a === false || b === false) return false;\n\t\t\t\t\tif (a === true && b === true) return true;\n\t\t\t\t\treturn 'unknown';\n\t\t\t\tcase 'or':\n\t\t\t\t\tif (a === true || b === true) return true;\n\t\t\t\t\tif (a === false && b === false) return false;\n\t\t\t\t\treturn 'unknown';\n\t\t\t\tcase 'xor':\n\t\t\t\t\tif (a === 'unknown' || b === 'unknown') return 'unknown';\n\t\t\t\t\treturn a !== b;\n\t\t\t\tcase '=':\n\t\t\t\tcase '>=':\n\t\t\t\tcase '<=':\n\t\t\t\tcase '>':\n\t\t\t\tcase '<':\n\t\t\t\tcase '!=':\n\t\t\t\t\ttypeA = this._args[0].getDataType();\n\t\t\t\t\treturn ValueExprGeneric._condition_compare(a, b, typeA, this._func);\n\t\t\t\tcase 'like':\n\t\t\t\tcase 'ilike':\n\t\t\t\t\treturn this._regex.test(a);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_checkBoolean',\n\t\tvalue: function _checkBoolean(schemaA, schemaB) {\n\t\t\tvar typeA, typeB;\n\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'constant':\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'not':\n\t\t\t\t\treturn this._checkArgsDataType(schemaA, schemaB, ['boolean']);\n\t\t\t\tcase 'and':\n\t\t\t\tcase 'or':\n\t\t\t\tcase 'xor':\n\t\t\t\t\treturn this._checkArgsDataType(schemaA, schemaB, ['boolean', 'boolean']);\n\t\t\t\tcase '=':\n\t\t\t\tcase '>=':\n\t\t\t\tcase '<=':\n\t\t\t\tcase '>':\n\t\t\t\tcase '<':\n\t\t\t\tcase '!=':\n\t\t\t\t\t// check if the datatypes are identical\n\t\t\t\t\tthis._args[0].check(schemaA, schemaB);\n\t\t\t\t\tthis._args[1].check(schemaA, schemaB);\n\n\t\t\t\t\ttypeA = this._args[0].getDataType();\n\t\t\t\t\ttypeB = this._args[1].getDataType();\n\t\t\t\t\tif (typeA === 'null' || typeB === 'null') {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (typeA === typeB) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-could-not-compare-different-types', {\n\t\t\t\t\t\t\ttypeA: typeA,\n\t\t\t\t\t\t\ttypeB: typeB\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\treturn this._checkArgsDataType(schemaA, schemaB, ['boolean', 'boolean']);\n\t\t\t\tcase 'like':\n\t\t\t\tcase 'ilike':\n\t\t\t\t\t// http://www.postgresql.org/docs/9.4/static/functions-matching.html#FUNCTIONS-LIKE\n\t\t\t\t\tthis._args[0].check(schemaA, schemaB);\n\t\t\t\t\tif (this._args[1].getDataType() !== 'string' || this._args[1]._func !== 'constant') {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// cache regex\n\t\t\t\t\tvar value = this._args[1]._args[0]; // direct access of constant value\n\t\t\t\t\tvar regex_str = (0, _escape2.default)(value);\n\t\t\t\t\tregex_str = regex_str.replace(/([^\\\\]?)_/g, '$1.');\n\t\t\t\t\tregex_str = regex_str.replace(/([^\\\\]?)%/g, '$1.*');\n\n\t\t\t\t\tvar flags = this._func === 'ilike' ? 'i' : '';\n\n\t\t\t\t\tthis._regex = new RegExp('^' + regex_str + '$', flags);\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_evaluateString',\n\t\tvalue: function _evaluateString(tupleA, tupleB, row, statementSession) {\n\t\t\tvar a, value, i;\n\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'constant':\n\t\t\t\t\treturn this._args[0];\n\t\t\t\tcase 'lower':\n\t\t\t\tcase 'upper':\n\t\t\t\t\ta = this._args[0].evaluate(tupleA, tupleB, row, statementSession);\n\n\t\t\t\t\tif (a === null) return null;else if (this._func === 'lower') {\n\t\t\t\t\t\treturn a.toLowerCase();\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn a.toUpperCase();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'concat':\n\t\t\t\t\tvalue = '';\n\t\t\t\t\tfor (i = 0; i < this._args.length; i++) {\n\t\t\t\t\t\ta = this._args[i].evaluate(tupleA, tupleB, row, statementSession);\n\t\t\t\t\t\tif (a === null) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalue += a;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_evaluateNumber',\n\t\tvalue: function _evaluateNumber(tupleA, tupleB, row, statementSession) {\n\t\t\t// no args\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'constant':\n\t\t\t\t\treturn this._args[0];\n\t\t\t}\n\n\t\t\t// unary and binary functions\n\t\t\tvar valueA = this._args.length > 0 ? this._args[0].evaluate(tupleA, tupleB, row, statementSession) : undefined;\n\t\t\tvar valueB = this._args.length > 1 ? this._args[1].evaluate(tupleA, tupleB, row, statementSession) : undefined;\n\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'add':\n\t\t\t\t\tif (valueA === null || valueB === null) return null;\n\t\t\t\t\treturn valueA + valueB;\n\t\t\t\tcase 'sub':\n\t\t\t\t\tif (valueA === null || valueB === null) return null;\n\t\t\t\t\treturn valueA - valueB;\n\t\t\t\tcase 'mul':\n\t\t\t\t\tif (valueA === null || valueB === null) return null;\n\t\t\t\t\treturn valueA * valueB;\n\t\t\t\tcase 'div':\n\t\t\t\t\tif (valueA === null || valueB === null) return null;\n\t\t\t\t\treturn valueA / valueB;\n\t\t\t\tcase 'mod':\n\t\t\t\t\tif (valueA === null || valueB === null) return null;\n\t\t\t\t\treturn valueA % valueB;\n\n\t\t\t\tcase 'abs':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn Math.abs(valueA);\n\n\t\t\t\tcase 'floor':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn Math.floor(valueA);\n\n\t\t\t\tcase 'ceil':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn Math.ceil(valueA);\n\n\t\t\t\tcase 'round':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn Math.round(valueA);\n\n\t\t\t\tcase 'minus':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn -valueA;\n\n\t\t\t\tcase 'rand':\n\t\t\t\t\treturn Math.random();\n\n\t\t\t\tcase 'rownum':\n\t\t\t\t\treturn row + 1;\n\n\t\t\t\tcase 'strlen':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn valueA.length;\n\n\t\t\t\tcase 'year':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn valueA.getFullYear();\n\t\t\t\tcase 'month':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn valueA.getMonth() + 1;\n\t\t\t\tcase 'dayofmonth':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn valueA.getDate();\n\t\t\t\tcase 'hour':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn valueA.getHours();\n\t\t\t\tcase 'minute':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn valueA.getMinutes();\n\t\t\t\tcase 'second':\n\t\t\t\t\tif (valueA === null) return null;\n\t\t\t\t\treturn valueA.getSeconds();\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_checkArgsDataType',\n\t\tvalue: function _checkArgsDataType(schemaA, schemaB, types_expected) {\n\t\t\tvar i,\n\t\t\t    types_given = [];\n\n\t\t\tif (this._args.length != types_expected.length) {\n\t\t\t\tthrow 'this should not happen: #args != #types';\n\t\t\t}\n\n\t\t\tfor (i = 0; i < types_expected.length; i++) {\n\t\t\t\tthis._args[i].check(schemaA, schemaB);\n\t\t\t\ttypes_given.push(this._args[i].getDataType());\n\t\t\t}\n\n\t\t\tfor (i = 0; i < types_given.length; i++) {\n\t\t\t\tif (types_given[i] !== types_expected[i]) {\n\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-function-expects-type', {\n\t\t\t\t\t\tfunc: this._func,\n\t\t\t\t\t\texpected: types_expected,\n\t\t\t\t\t\tgiven: types_given\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: 'getDataType',\n\t\tvalue: function getDataType() {\n\t\t\tif (this._dataTypeCalculated) {\n\t\t\t\treturn this._dataTypeCalculated;\n\t\t\t}\n\t\t\treturn this._dataType;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check(schemaA, schemaB) {\n\t\t\tswitch (this._dataType) {\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn this._checkString(schemaA, schemaB);\n\t\t\t\tcase 'number':\n\t\t\t\t\treturn this._checkNumber(schemaA, schemaB);\n\t\t\t\tcase 'boolean':\n\t\t\t\t\treturn this._checkBoolean(schemaA, schemaB);\n\t\t\t\tcase 'date':\n\t\t\t\t\treturn this._checkDate(schemaA, schemaB);\n\t\t\t\tcase 'null':\n\t\t\t\t\treturn this._checkNull(schemaA, schemaB);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_checkNull',\n\t\tvalue: function _checkNull(schemaA, schemaB) {\n\t\t\tvar i, dataType;\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'constant':\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'coalesce':\n\t\t\t\t\tif (this._args.length === 0) {\n\t\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t\t\t}\n\n\t\t\t\t\t// all arguments must be of same type or null\n\t\t\t\t\tthis._args[0].check(schemaA, schemaB);\n\t\t\t\t\tthis._dataTypeCalculated = this._args[0].getDataType();\n\n\t\t\t\t\tfor (i = 1; i < this._args.length; i++) {\n\t\t\t\t\t\tthis._args[i].check(schemaA, schemaB);\n\t\t\t\t\t\tdataType = this._args[i].getDataType();\n\n\t\t\t\t\t\tif (this._dataType === 'null' && dataType !== 'null') {\n\t\t\t\t\t\t\tthis._dataTypeCalculated = dataType;\n\t\t\t\t\t\t} else if (dataType !== 'null' && this._dataType !== dataType) {\n\t\t\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-function-expects-arguments-of-same-type', { func: 'COALESCE()' }));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'caseWhen':\n\t\t\t\tcase 'caseWhenElse':\n\t\t\t\t\t// conditions are on i%2 === 0\n\t\t\t\t\t// values on i%2 === 1\n\n\t\t\t\t\t// check conditions to be boolean\n\t\t\t\t\tfor (i = 0; i < this._args.length; i += 2) {\n\t\t\t\t\t\tthis._args[i].check(schemaA, schemaB);\n\t\t\t\t\t\tif (this._args[i].getDataType() !== 'boolean') {\n\t\t\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-case-when-condition-must-be-boolean'));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// all values must be of same type\n\t\t\t\t\tthis._args[1].check(schemaA, schemaB);\n\t\t\t\t\tthis._dataTypeCalculated = this._args[1].getDataType();\n\n\t\t\t\t\tfor (i = 3; i < this._args.length; i += 2) {\n\t\t\t\t\t\tthis._args[i].check(schemaA, schemaB);\n\t\t\t\t\t\tdataType = this._args[i].getDataType();\n\n\t\t\t\t\t\tif (this._dataType === 'null' && dataType !== 'null') {\n\t\t\t\t\t\t\tthis._dataTypeCalculated = dataType;\n\t\t\t\t\t\t} else if (dataType !== 'null' && this._dataType !== dataType) {\n\t\t\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-case-when-expects-results-of-same-type'));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_checkString',\n\t\tvalue: function _checkString(schemaA, schemaB) {\n\t\t\tvar i, dataType;\n\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'constant':\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'lower':\n\t\t\t\tcase 'upper':\n\t\t\t\t\treturn this._checkArgsDataType(schemaA, schemaB, ['string']);\n\t\t\t\tcase 'concat':\n\t\t\t\t\tif (this._args.length === 0) {\n\t\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t\t\t}\n\n\t\t\t\t\t// all arguments must be of type String or null\n\t\t\t\t\tthis._args[0].check(schemaA, schemaB);\n\t\t\t\t\tthis._dataTypeCalculated = 'string';\n\n\t\t\t\t\tfor (i = 1; i < this._args.length; i++) {\n\t\t\t\t\t\tthis._args[i].check(schemaA, schemaB);\n\t\t\t\t\t\tdataType = this._args[i].getDataType();\n\n\t\t\t\t\t\tif (this._dataType === 'null' && dataType !== 'null') {\n\t\t\t\t\t\t\tthis._dataTypeCalculated = dataType;\n\t\t\t\t\t\t} else if (dataType !== 'null' && this._dataType !== dataType) {\n\t\t\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-function-expects-arguments-of-same-type', { func: 'CONCAT()' }));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_checkNumber',\n\t\tvalue: function _checkNumber(schemaA, schemaB) {\n\t\t\tswitch (this._func) {\n\t\t\t\tcase 'constant':\n\t\t\t\tcase 'rand':\n\t\t\t\tcase 'rownum':\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'add':\n\t\t\t\tcase 'sub':\n\t\t\t\tcase 'mul':\n\t\t\t\tcase 'div':\n\t\t\t\tcase 'mod':\n\t\t\t\t\treturn this._checkArgsDataType(schemaA, schemaB, ['number', 'number']);\n\t\t\t\tcase 'abs':\n\t\t\t\tcase 'floor':\n\t\t\t\tcase 'ceil':\n\t\t\t\tcase 'round':\n\t\t\t\tcase 'minus':\n\t\t\t\t\treturn this._checkArgsDataType(schemaA, schemaB, ['number']);\n\t\t\t\tcase 'strlen':\n\t\t\t\t\treturn this._checkArgsDataType(schemaA, schemaB, ['string']);\n\n\t\t\t\tcase 'year':\n\t\t\t\tcase 'month':\n\t\t\t\tcase 'dayofmonth':\n\t\t\t\tcase 'hour':\n\t\t\t\tcase 'minute':\n\t\t\t\tcase 'second':\n\t\t\t\t\treturn this._checkArgsDataType(schemaA, schemaB, ['date']);\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow 'this should not happen!';\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'toString',\n\t\tvalue: function toString() {\n\t\t\tvar str, i;\n\n\t\t\tstr = this._func + '(';\n\t\t\tfor (i = 0; i < this._args.length; i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tstr += ', ';\n\t\t\t\t}\n\t\t\t\tstr += this._args[i] === null ? 'null' : this._args[i].toString();\n\t\t\t}\n\t\t\treturn str + ')';\n\t\t}\n\t}, {\n\t\tkey: 'getFormulaHtml',\n\t\tvalue: function getFormulaHtml() {\n\t\t\t/*jshint validthis:true */\n\t\t\tfunction printValue(val, type) {\n\t\t\t\tif (val === null) {\n\t\t\t\t\treturn 'null';\n\t\t\t\t}\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\treturn val;\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\treturn \"'\" + val + \"'\";\n\t\t\t\t\tcase 'date':\n\t\t\t\t\t\treturn val.getFullYear() + '-' + (val.getMonth() + 1 < 10 ? '0' + (val.getMonth() + 1) : val.getMonth() + 1) + '-' + (val.getDate() < 10 ? '0' + val.getDate() : val.getDate());\n\t\t\t\t\tcase 'null':\n\t\t\t\t\t\treturn 'null';\n\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\treturn val ? 'true' : 'false';\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('unknown type ' + type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction printFunction(func_name) {\n\t\t\t\tvar str, i;\n\n\t\t\t\tstr = (func_name || this._func) + '(';\n\t\t\t\tfor (i = 0; i < this._args.length; i++) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tstr += ', ';\n\t\t\t\t\t}\n\t\t\t\t\tstr += this._args[i].getFormulaHtml();\n\t\t\t\t}\n\t\t\t\treturn str + ')';\n\t\t\t}\n\n\t\t\tfunction printCase(hasElse) {\n\t\t\t\t// conditions are on i%2 === 0\n\t\t\t\t// values on i%2 === 1\n\t\t\t\t// else is the very last element (if present)\n\n\t\t\t\tvar str = 'CASE';\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < this._args.length - (hasElse ? 2 : 0); i += 2) {\n\t\t\t\t\tstr += ' WHEN ' + this._args[i].getFormulaHtml() + ' THEN ' + this._args[i + 1].getFormulaHtml();\n\t\t\t\t}\n\t\t\t\tif (hasElse === true) {\n\t\t\t\t\tstr += ' ELSE ' + this._args[this._args.length - 1].getFormulaHtml();\n\t\t\t\t}\n\n\t\t\t\treturn str + ' END';\n\t\t\t}\n\n\t\t\tfunction binary(func_name) {\n\t\t\t\tvar s = '';\n\n\t\t\t\ts += '<span> ' + (func_name || this._func) + ' </span>';\n\t\t\t\ts = this._args[0].getFormulaHtml() + s;\n\t\t\t\ts += this._args[1].getFormulaHtml();\n\t\t\t\treturn '<span>' + s + '</span>';\n\t\t\t}\n\n\t\t\tfunction getFormula() {\n\t\t\t\tswitch (this._func) {\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\t\treturn printValue(this._args[0], this._dataTypeCalculated || this._dataType);\n\t\t\t\t\tcase 'rand':\n\t\t\t\t\tcase 'rownum':\n\t\t\t\t\tcase 'abs':\n\t\t\t\t\tcase 'ceil':\n\t\t\t\t\tcase 'floor':\n\t\t\t\t\tcase 'round':\n\t\t\t\t\tcase 'year':\n\t\t\t\t\tcase 'month':\n\t\t\t\t\tcase 'dayofmonth':\n\t\t\t\t\tcase 'hour':\n\t\t\t\t\tcase 'minute':\n\t\t\t\t\tcase 'second':\n\t\t\t\t\tcase 'adddate':\n\t\t\t\t\tcase 'subdate':\n\t\t\t\t\tcase 'concat':\n\t\t\t\t\tcase 'upper':\n\t\t\t\t\tcase 'lower':\n\t\t\t\t\tcase 'date':\n\t\t\t\t\tcase 'coalesce':\n\t\t\t\t\t\treturn printFunction.call(this);\n\t\t\t\t\tcase 'strlen':\n\t\t\t\t\t\treturn printFunction.call(this, 'length');\n\n\t\t\t\t\tcase 'minus':\n\t\t\t\t\t\treturn printFunction.call(this, '-');\n\n\t\t\t\t\tcase 'not':\n\t\t\t\t\t\treturn printFunction.call(this, '!');\n\n\t\t\t\t\tcase 'caseWhen':\n\t\t\t\t\tcase 'caseWhenElse':\n\t\t\t\t\t\treturn printCase.call(this, this._func === 'caseWhenElse');\n\n\t\t\t\t\tcase 'add':\n\t\t\t\t\tcase 'sub':\n\t\t\t\t\tcase 'mul':\n\t\t\t\t\tcase 'div':\n\t\t\t\t\tcase 'mod':\n\n\t\t\t\t\tcase 'and':\n\t\t\t\t\tcase 'or':\n\t\t\t\t\tcase 'xor':\n\n\t\t\t\t\tcase '=':\n\t\t\t\t\tcase '>=':\n\t\t\t\t\tcase '<=':\n\t\t\t\t\tcase '>':\n\t\t\t\t\tcase '<':\n\t\t\t\t\tcase '!=':\n\t\t\t\t\tcase 'like':\n\t\t\t\t\tcase 'ilike':\n\t\t\t\t\t\treturn binary.call(this, {\n\t\t\t\t\t\t\t'add': '+',\n\t\t\t\t\t\t\t'sub': '-',\n\t\t\t\t\t\t\t'mul': '*',\n\t\t\t\t\t\t\t'div': '/',\n\t\t\t\t\t\t\t'mod': '%',\n\n\t\t\t\t\t\t\t'>=': '≥',\n\t\t\t\t\t\t\t'<=': '≤',\n\t\t\t\t\t\t\t'>': '&gt;',\n\t\t\t\t\t\t\t'<': '&lt;',\n\t\t\t\t\t\t\t'!=': '≠'\n\t\t\t\t\t\t}[this._func] || this._func);\n\t\t\t\t}\n\n\t\t\t\treturn this.toString();\n\t\t\t}\n\n\t\t\tif (this._wrappedInBrackets === true) {\n\t\t\t\treturn '( ' + getFormula.call(this) + ' )';\n\t\t\t} else {\n\t\t\t\treturn getFormula.call(this);\n\t\t\t}\n\t\t}\n\t}], [{\n\t\tkey: '_condition_compare',\n\t\tvalue: function _condition_compare(valueA, valueB, type, comperator) {\n\t\t\tif (valueA === null || valueB === null) {\n\t\t\t\t// null compared with any not null value => 'unknown'\n\n\t\t\t\tswitch (comperator) {\n\t\t\t\t\tcase '=':\n\t\t\t\t\tcase '>=':\n\t\t\t\t\tcase '<=':\n\t\t\t\t\t\tif (valueA === valueB) return true;\n\t\t\t\t\t\treturn 'unknown';\n\t\t\t\t\tcase '<':\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\tif (valueA === valueB) return false;\n\t\t\t\t\t\treturn 'unknown';\n\t\t\t\t\tcase '!=':\n\t\t\t\t\t\treturn valueA !== valueB;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('unknown operator');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'string':\n\t\t\t\t\tswitch (comperator) {\n\t\t\t\t\t\tcase '=':\n\t\t\t\t\t\t\treturn valueA == valueB;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\treturn valueA > valueB;\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\treturn valueA < valueB;\n\t\t\t\t\t\tcase '>=':\n\t\t\t\t\t\t\treturn valueA >= valueB;\n\t\t\t\t\t\tcase '<=':\n\t\t\t\t\t\t\treturn valueA <= valueB;\n\t\t\t\t\t\tcase '!=':\n\t\t\t\t\t\t\treturn valueA !== valueB;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Error('unknown operator');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'date':\n\t\t\t\t\tswitch (comperator) {\n\t\t\t\t\t\tcase '=':\n\t\t\t\t\t\t\treturn valueA.getTime() == valueB.getTime();\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\treturn valueA > valueB;\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\treturn valueA < valueB;\n\t\t\t\t\t\tcase '>=':\n\t\t\t\t\t\t\treturn valueA >= valueB;\n\t\t\t\t\t\tcase '<=':\n\t\t\t\t\t\t\treturn valueA <= valueB;\n\t\t\t\t\t\tcase '!=':\n\t\t\t\t\t\t\treturn valueA.getTime() !== valueB.getTime();\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Error('unknown operator');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'boolean':\n\t\t\t\t\tif (typeof valueA !== 'boolean' || typeof valueB !== 'boolean') throw new Error('operands have different type');\n\n\t\t\t\t\tswitch (comperator) {\n\t\t\t\t\t\tcase '=':\n\t\t\t\t\t\t\treturn valueA == valueB;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\treturn valueA > valueB;\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\treturn valueA < valueB;\n\t\t\t\t\t\tcase '>=':\n\t\t\t\t\t\t\treturn valueA >= valueB;\n\t\t\t\t\t\tcase '<=':\n\t\t\t\t\t\t\treturn valueA <= valueB;\n\t\t\t\t\t\tcase '!=':\n\t\t\t\t\t\t\treturn valueA !== valueB;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Error('unknown operator');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('unknown type ' + type);\n\t\t\t}\n\t\t}\n\t}]);\n\treturn ValueExprGeneric;\n}(ValueExpr);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/ValueExpr.js\n// module id = 46\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/ValueExpr.js?");
},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(48), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/get-prototype-of.js\n// module id = 47\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/object/get-prototype-of.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(49);\nmodule.exports = __webpack_require__(25).Object.getPrototypeOf;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/get-prototype-of.js\n// module id = 48\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/object/get-prototype-of.js?")},function(module,exports,__webpack_require__){eval("// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject = __webpack_require__(6);\nvar $getPrototypeOf = __webpack_require__(50);\n\n__webpack_require__(23)('getPrototypeOf', function () {\n  return function getPrototypeOf(it) {\n    return $getPrototypeOf(toObject(it));\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.get-prototype-of.js\n// module id = 49\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es6.object.get-prototype-of.js?")},function(module,exports,__webpack_require__){eval("// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(10);\nvar toObject = __webpack_require__(6);\nvar IE_PROTO = __webpack_require__(18)('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gpo.js\n// module id = 50\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-gpo.js?")},function(module,exports,__webpack_require__){eval('"use strict";\n\nexports.__esModule = true;\n\nvar _typeof2 = __webpack_require__(52);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (self, call) {\n  if (!self) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/possibleConstructorReturn.js\n// module id = 51\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/helpers/possibleConstructorReturn.js?')},function(module,exports,__webpack_require__){eval('"use strict";\n\nexports.__esModule = true;\n\nvar _iterator = __webpack_require__(53);\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = __webpack_require__(72);\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {\n  return typeof obj === "undefined" ? "undefined" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/typeof.js\n// module id = 52\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/helpers/typeof.js?')},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(54), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/symbol/iterator.js\n// module id = 53\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/symbol/iterator.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(55);\n__webpack_require__(67);\nmodule.exports = __webpack_require__(71).f('iterator');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/symbol/iterator.js\n// module id = 54\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/symbol/iterator.js?")},function(module,exports,__webpack_require__){eval("'use strict';\nvar $at = __webpack_require__(56)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(57)(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.string.iterator.js\n// module id = 55\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es6.string.iterator.js?")},function(module,exports,__webpack_require__){eval("var toInteger = __webpack_require__(16);\nvar defined = __webpack_require__(7);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_string-at.js\n// module id = 56\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_string-at.js?")},function(module,exports,__webpack_require__){eval("'use strict';\nvar LIBRARY = __webpack_require__(58);\nvar $export = __webpack_require__(24);\nvar redefine = __webpack_require__(59);\nvar hide = __webpack_require__(28);\nvar has = __webpack_require__(10);\nvar Iterators = __webpack_require__(60);\nvar $iterCreate = __webpack_require__(61);\nvar setToStringTag = __webpack_require__(65);\nvar getPrototypeOf = __webpack_require__(50);\nvar ITERATOR = __webpack_require__(66)('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-define.js\n// module id = 57\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_iter-define.js?")},function(module,exports){eval("module.exports = true;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_library.js\n// module id = 58\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_library.js?")},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(28);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_redefine.js\n// module id = 59\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_redefine.js?")},function(module,exports){eval("module.exports = {};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iterators.js\n// module id = 60\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_iterators.js?")},function(module,exports,__webpack_require__){eval("'use strict';\nvar create = __webpack_require__(62);\nvar descriptor = __webpack_require__(37);\nvar setToStringTag = __webpack_require__(65);\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(28)(IteratorPrototype, __webpack_require__(66)('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-create.js\n// module id = 61\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_iter-create.js?")},function(module,exports,__webpack_require__){eval("// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(30);\nvar dPs = __webpack_require__(63);\nvar enumBugKeys = __webpack_require__(22);\nvar IE_PROTO = __webpack_require__(18)('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(35)('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(64).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-create.js\n// module id = 62\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-create.js?")},function(module,exports,__webpack_require__){eval("var dP = __webpack_require__(29);\nvar anObject = __webpack_require__(30);\nvar getKeys = __webpack_require__(8);\n\nmodule.exports = __webpack_require__(33) ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dps.js\n// module id = 63\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-dps.js?")},function(module,exports,__webpack_require__){eval("var document = __webpack_require__(20).document;\nmodule.exports = document && document.documentElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_html.js\n// module id = 64\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_html.js?")},function(module,exports,__webpack_require__){eval("var def = __webpack_require__(29).f;\nvar has = __webpack_require__(10);\nvar TAG = __webpack_require__(66)('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_set-to-string-tag.js\n// module id = 65\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_set-to-string-tag.js?")},function(module,exports,__webpack_require__){eval("var store = __webpack_require__(19)('wks');\nvar uid = __webpack_require__(21);\nvar Symbol = __webpack_require__(20).Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks.js\n// module id = 66\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_wks.js?")},function(module,exports,__webpack_require__){eval("__webpack_require__(68);\nvar global = __webpack_require__(20);\nvar hide = __webpack_require__(28);\nvar Iterators = __webpack_require__(60);\nvar TO_STRING_TAG = __webpack_require__(66)('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/web.dom.iterable.js\n// module id = 67\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/web.dom.iterable.js?")},function(module,exports,__webpack_require__){eval("'use strict';\nvar addToUnscopables = __webpack_require__(69);\nvar step = __webpack_require__(70);\nvar Iterators = __webpack_require__(60);\nvar toIObject = __webpack_require__(11);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(57)(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.array.iterator.js\n// module id = 68\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es6.array.iterator.js?")},function(module,exports){eval("module.exports = function () { /* empty */ };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_add-to-unscopables.js\n// module id = 69\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_add-to-unscopables.js?")},function(module,exports){eval("module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-step.js\n// module id = 70\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_iter-step.js?")},function(module,exports,__webpack_require__){eval("exports.f = __webpack_require__(66);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks-ext.js\n// module id = 71\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_wks-ext.js?")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(73), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/symbol.js\n// module id = 72\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/symbol.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(74);\n__webpack_require__(84);\n__webpack_require__(85);\n__webpack_require__(86);\nmodule.exports = __webpack_require__(25).Symbol;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/symbol/index.js\n// module id = 73\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/symbol/index.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n// ECMAScript 6 symbols shim\nvar global = __webpack_require__(20);\nvar has = __webpack_require__(10);\nvar DESCRIPTORS = __webpack_require__(33);\nvar $export = __webpack_require__(24);\nvar redefine = __webpack_require__(59);\nvar META = __webpack_require__(75).KEY;\nvar $fails = __webpack_require__(34);\nvar shared = __webpack_require__(19);\nvar setToStringTag = __webpack_require__(65);\nvar uid = __webpack_require__(21);\nvar wks = __webpack_require__(66);\nvar wksExt = __webpack_require__(71);\nvar wksDefine = __webpack_require__(76);\nvar enumKeys = __webpack_require__(77);\nvar isArray = __webpack_require__(80);\nvar anObject = __webpack_require__(30);\nvar toIObject = __webpack_require__(11);\nvar toPrimitive = __webpack_require__(36);\nvar createDesc = __webpack_require__(37);\nvar _create = __webpack_require__(62);\nvar gOPNExt = __webpack_require__(81);\nvar $GOPD = __webpack_require__(83);\nvar $DP = __webpack_require__(29);\nvar $keys = __webpack_require__(8);\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function';\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  __webpack_require__(82).f = gOPNExt.f = $getOwnPropertyNames;\n  __webpack_require__(79).f = $propertyIsEnumerable;\n  __webpack_require__(78).f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !__webpack_require__(58)) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    replacer = args[1];\n    if (typeof replacer == 'function') $replacer = replacer;\n    if ($replacer || !isArray(replacer)) replacer = function (key, value) {\n      if ($replacer) value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(28)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.symbol.js\n// module id = 74\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es6.symbol.js?")},function(module,exports,__webpack_require__){eval("var META = __webpack_require__(21)('meta');\nvar isObject = __webpack_require__(31);\nvar has = __webpack_require__(10);\nvar setDesc = __webpack_require__(29).f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !__webpack_require__(34)(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_meta.js\n// module id = 75\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_meta.js?")},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(20);\nvar core = __webpack_require__(25);\nvar LIBRARY = __webpack_require__(58);\nvar wksExt = __webpack_require__(71);\nvar defineProperty = __webpack_require__(29).f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks-define.js\n// module id = 76\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_wks-define.js?")},function(module,exports,__webpack_require__){eval("// all enumerable object keys, includes symbols\nvar getKeys = __webpack_require__(8);\nvar gOPS = __webpack_require__(78);\nvar pIE = __webpack_require__(79);\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_enum-keys.js\n// module id = 77\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_enum-keys.js?");
},function(module,exports){eval("exports.f = Object.getOwnPropertySymbols;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gops.js\n// module id = 78\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-gops.js?")},function(module,exports){eval("exports.f = {}.propertyIsEnumerable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-pie.js\n// module id = 79\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-pie.js?")},function(module,exports,__webpack_require__){eval("// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(13);\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-array.js\n// module id = 80\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_is-array.js?")},function(module,exports,__webpack_require__){eval("// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = __webpack_require__(11);\nvar gOPN = __webpack_require__(82).f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gopn-ext.js\n// module id = 81\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-gopn-ext.js?")},function(module,exports,__webpack_require__){eval("// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = __webpack_require__(9);\nvar hiddenKeys = __webpack_require__(22).concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gopn.js\n// module id = 82\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-gopn.js?")},function(module,exports,__webpack_require__){eval("var pIE = __webpack_require__(79);\nvar createDesc = __webpack_require__(37);\nvar toIObject = __webpack_require__(11);\nvar toPrimitive = __webpack_require__(36);\nvar has = __webpack_require__(10);\nvar IE8_DOM_DEFINE = __webpack_require__(32);\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(33) ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gopd.js\n// module id = 83\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_object-gopd.js?")},function(module,exports){eval("\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.to-string.js\n// module id = 84\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es6.object.to-string.js?")},function(module,exports,__webpack_require__){eval("__webpack_require__(76)('asyncIterator');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es7.symbol.async-iterator.js\n// module id = 85\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es7.symbol.async-iterator.js?")},function(module,exports,__webpack_require__){eval("__webpack_require__(76)('observable');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es7.symbol.observable.js\n// module id = 86\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es7.symbol.observable.js?")},function(module,exports,__webpack_require__){eval('"use strict";\n\nexports.__esModule = true;\n\nvar _setPrototypeOf = __webpack_require__(88);\n\nvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\nvar _create = __webpack_require__(92);\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _typeof2 = __webpack_require__(52);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));\n  }\n\n  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/inherits.js\n// module id = 87\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/helpers/inherits.js?')},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(89), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/set-prototype-of.js\n// module id = 88\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/object/set-prototype-of.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(90);\nmodule.exports = __webpack_require__(25).Object.setPrototypeOf;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/set-prototype-of.js\n// module id = 89\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/object/set-prototype-of.js?")},function(module,exports,__webpack_require__){eval("// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = __webpack_require__(24);\n$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(91).set });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.set-prototype-of.js\n// module id = 90\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es6.object.set-prototype-of.js?")},function(module,exports,__webpack_require__){eval("// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = __webpack_require__(31);\nvar anObject = __webpack_require__(30);\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = __webpack_require__(26)(Function.call, __webpack_require__(83).f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_set-proto.js\n// module id = 91\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_set-proto.js?")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(93), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/create.js\n// module id = 92\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/object/create.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(94);\nvar $Object = __webpack_require__(25).Object;\nmodule.exports = function create(P, D) {\n  return $Object.create(P, D);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/create.js\n// module id = 93\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/object/create.js?")},function(module,exports,__webpack_require__){eval("var $export = __webpack_require__(24);\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: __webpack_require__(62) });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.create.js\n// module id = 94\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es6.object.create.js?")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(96), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/regexp/escape.js\n// module id = 95\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/regexp/escape.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(97);\nmodule.exports = __webpack_require__(25).RegExp.escape;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/regexp/escape.js\n// module id = 96\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/regexp/escape.js?")},function(module,exports,__webpack_require__){eval("// https://github.com/benjamingr/RexExp.escape\nvar $export = __webpack_require__(24);\nvar $re = __webpack_require__(98)(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/core.regexp.escape.js\n// module id = 97\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/core.regexp.escape.js?")},function(module,exports){eval("module.exports = function (regExp, replace) {\n  var replacer = replace === Object(replace) ? function (part) {\n    return replace[part];\n  } : replace;\n  return function (it) {\n    return String(it).replace(regExp, replacer);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_replacer.js\n// module id = 98\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_replacer.js?")},function(module,exports,__webpack_require__){eval('"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\nexports.ExecutionError = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ExecutionError = exports.ExecutionError = function (_Error) {\n\t(0, _inherits3.default)(ExecutionError, _Error);\n\n\tfunction ExecutionError(message, codeInfo) {\n\t\t(0, _classCallCheck3.default)(this, ExecutionError);\n\n\t\t/* codeInfo\n   {\n      location: {\n          start: { offset: 0, line: 0, column: 0 },\n          end:   { offset: 0, line: 0, column: 0 },\n      },\n      text: \'\'\n   };\n   */\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (ExecutionError.__proto__ || (0, _getPrototypeOf2.default)(ExecutionError)).call(this, message));\n\n\t\tif (codeInfo) {\n\t\t\t_this.message = message;\n\t\t\t_this.codeInfo = codeInfo;\n\t\t} else {\n\t\t\t_this.message = message;\n\t\t}\n\t\treturn _this;\n\t}\n\n\treturn ExecutionError;\n}(Error);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/ExecutionError.js\n// module id = 99\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/ExecutionError.js?')},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Column = undefined;\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * a column of a relation\n * @constructor\n * @param   {String} name         the name of the column\n * @param   {String} relAlias     the relation alias of the name (or null)\n * @param   {String} optionalType optional type of the column\n * @returns {Column} returns a column with the given attributes\n */\nvar Column = exports.Column = function () {\n\tfunction Column(name, relAlias, optionalType) {\n\t\t(0, _classCallCheck3.default)(this, Column);\n\n\t\tthis._name = name;\n\t\tthis._relAlias = relAlias;\n\t\tthis._type = optionalType;\n\t}\n\n\t(0, _createClass3.default)(Column, [{\n\t\tkey: 'getName',\n\t\tvalue: function getName() {\n\t\t\treturn this._name;\n\t\t}\n\t}, {\n\t\tkey: 'getRelAlias',\n\t\tvalue: function getRelAlias() {\n\t\t\treturn this._relAlias;\n\t\t}\n\t}, {\n\t\tkey: 'getType',\n\t\tvalue: function getType() {\n\t\t\treturn this._type;\n\t\t}\n\t}, {\n\t\tkey: 'setRelAlias',\n\t\tvalue: function setRelAlias(relAlias) {\n\t\t\tthis._relAlias = relAlias;\n\t\t}\n\t}, {\n\t\tkey: 'toString',\n\t\tvalue: function toString() {\n\t\t\treturn Column.printColumn(this._name, this._relAlias);\n\t\t}\n\t}, {\n\t\tkey: 'equals',\n\t\tvalue: function equals(columnB) {\n\t\t\treturn this._name === columnB._name && this._relAlias === columnB._relAlias;\n\t\t}\n\t}], [{\n\t\tkey: 'printColumn',\n\t\tvalue: function printColumn(name, relAlias) {\n\t\t\tvar pName;\n\t\t\tif (typeof name == 'number') pName = '[' + name + ']';else pName = name;\n\n\t\t\tif (relAlias === null) return pName;\n\t\t\treturn relAlias + '.' + pName;\n\t\t}\n\t}]);\n\treturn Column;\n}();\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Column.js\n// module id = 100\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Column.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Schema = undefined;\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _Column = __webpack_require__(100);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * the schema of a relation\n * @constructor\n * @returns {Schema} returns a Schema\n */\nvar Schema = exports.Schema = function () {\n\tfunction Schema() {\n\t\t(0, _classCallCheck3.default)(this, Schema);\n\n\t\tthis._names = [];\n\t\tthis._relAliases = [];\n\t\tthis._types = [];\n\t\tthis._size = 0;\n\n\t\t// key: name, value: [] of columns\n\t\tthis._colIndexPerName = {};\n\t}\n\n\t(0, _createClass3.default)(Schema, [{\n\t\tkey: 'getSize',\n\t\tvalue: function getSize() {\n\t\t\treturn this._size;\n\t\t}\n\t}, {\n\t\tkey: 'addColumn',\n\t\tvalue: function addColumn(name, relAlias, type) {\n\t\t\tif (!(type === 'string' || type === 'date' || type === 'number' || type === 'boolean')) throw new Error('unknown type! ' + type);\n\n\t\t\tthis._names.push(name);\n\t\t\tthis._relAliases.push(relAlias);\n\t\t\tthis._types.push(type);\n\t\t\tvar index = this._size;\n\n\t\t\tif (this.isUnique(index) === false) {\n\t\t\t\tthrow new Error(i18n.t('db.messages.exec.error-column-not-unique', { column: relAlias + '.' + name }));\n\t\t\t}\n\n\t\t\t//names\n\t\t\tthis._addColToIndex(name, index);\n\n\t\t\tthis._size++;\n\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: 'addColumn2',\n\t\tvalue: function addColumn2(column) {\n\t\t\treturn this.addColumn(column.getName(), column.getRelAlias(), column.getType());\n\t\t}\n\t}, {\n\t\tkey: '_addColToIndex',\n\t\tvalue: function _addColToIndex(name, index) {\n\t\t\tif (typeof this._colIndexPerName[name] == 'undefined') {\n\t\t\t\tthis._colIndexPerName[name] = [index];\n\t\t\t} else {\n\t\t\t\tthis._colIndexPerName[name].push(index);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_removeColFromIndex',\n\t\tvalue: function _removeColFromIndex(index) {\n\t\t\tvar name = this._names[index];\n\t\t\tvar indices = this._colIndexPerName[name];\n\t\t\tindices.splice(indices.indexOf(index, 0), 1);\n\t\t\tif (indices.length === 0) delete this._colIndexPerName[name];\n\t\t}\n\t}, {\n\t\tkey: 'removeColumn',\n\t\tvalue: function removeColumn(index) {\n\t\t\tthis._names.splice(index, 1);\n\t\t\tthis._relAliases.splice(index, 1);\n\t\t\tthis._types.splice(index, 1);\n\t\t\tthis._size--;\n\n\t\t\t// update names because index is 1 lower at all following columns\n\t\t\tfor (var i = index; i < this._size; i++) {\n\t\t\t\tvar name = this._names[i];\n\t\t\t\tvar indices = this._colIndexPerName[name];\n\t\t\t\tfor (var j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'copy',\n\t\tvalue: function copy() {\n\t\t\tvar res = new Schema();\n\t\t\tfor (var i = 0; i < this._size; i++) {\n\t\t\t\tres.addColumn(this._names[i], this._relAliases[i], this._types[i]);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'isUnique',\n\t\tvalue: function isUnique(index) {\n\t\t\tfor (var j = 0; j < this._size; j++) {\n\t\t\t\tif (index == j) continue;\n\n\t\t\t\tif (this._names[index] === this._names[j] && this._relAliases[index] === this._relAliases[j]) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: 'getColumn',\n\t\tvalue: function getColumn(index) {\n\t\t\treturn new _Column.Column(this._names[index], this._relAliases[index], this._types[index]);\n\t\t}\n\t}, {\n\t\tkey: 'getColumns',\n\t\tvalue: function getColumns() {\n\t\t\tvar a = [];\n\t\t\tfor (var i = 0; i < this._size; i++) {\n\t\t\t\ta.push(this.getColumn(i));\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}, {\n\t\tkey: 'getColumnIndex',\n\t\tvalue: function getColumnIndex(name, relAlias, throwsExceptions) {\n\t\t\tif (typeof throwsExceptions == 'undefined') throwsExceptions = true;\n\n\t\t\tvar indices = this.getColumnIndexArray(name, relAlias);\n\n\t\t\tif (indices.length === 0) {\n\t\t\t\tif (throwsExceptions) {\n\t\t\t\t\tvar error = 'db.messages.exec.error-column-not-found-' + (typeof name === 'string' ? 'name' : 'index');\n\t\t\t\t\tthrow new Error(i18n.t(error, { column: _Column.Column.printColumn(name, relAlias), schema: this.toString() }));\n\t\t\t\t} else return -1;\n\t\t\t} else if (indices.length == 1) return indices[0];else throw new Error(i18n.t('db.messages.exec.error-column-ambiguous', {\n\t\t\t\tcolumn: _Column.Column.printColumn(name, relAlias),\n\t\t\t\tschema: this.toString()\n\t\t\t}));\n\t\t}\n\n\t\t/**\n   * returns an array of Columns that appear in both\n   * schemas (fully qualified)\n   * @param {Schema} schemaB the other schema\n   * @returns {Column[]} array of Column objects\n   */\n\n\t}, {\n\t\tkey: 'getConflictingColumnsArray',\n\t\tvalue: function getConflictingColumnsArray(schemaB) {\n\t\t\tvar i, index;\n\t\t\tvar conflicts = [];\n\n\t\t\tfor (i = 0; i < this._size; i++) {\n\t\t\t\tindex = schemaB.getColumnIndex(this._names[i], this._relAliases[i], false);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tconflicts.push(this.getColumn(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn conflicts;\n\t\t}\n\t}, {\n\t\tkey: 'getColumnIndexArray',\n\t\tvalue: function getColumnIndexArray(name, relAlias) {\n\t\t\tvar index;\n\t\t\tif (typeof name === 'string') {\n\t\t\t\tvar indices = this._colIndexPerName[name];\n\t\t\t\tif (typeof indices == 'undefined' || indices === null) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tif (relAlias === null) {\n\t\t\t\t\treturn indices; // contains all indices of columns with the given name\n\t\t\t\t}\n\n\t\t\t\t// check relAlias for all columns with the same name\n\t\t\t\tfor (var i = 0; i < indices.length; i++) {\n\t\t\t\t\tindex = indices[i];\n\t\t\t\t\tif (this._relAliases[index] === relAlias) {\n\t\t\t\t\t\treturn [index]; // found full qualified name; must be unique => only hit\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// name is the column index (starting at 1)!!\n\t\t\t\tindex = name - 1;\n\n\t\t\t\tif (name < 1 || name > this._size) throw new Error(i18n.t('db.messages.exec.error-column-index-out-of-range', {\n\t\t\t\t\tcolumn: _Column.Column.printColumn(name, relAlias),\n\t\t\t\t\tschema: this.toString()\n\t\t\t\t}));\n\n\t\t\t\tif (relAlias === null) return [index];\n\n\t\t\t\t// check if column has the given relAlias\n\t\t\t\tif (this._relAliases[index] === relAlias) return [index];\n\t\t\t}\n\n\t\t\treturn [];\n\t\t}\n\t}, {\n\t\tkey: 'getType',\n\t\tvalue: function getType(index) {\n\t\t\treturn this._types[index];\n\t\t}\n\t}, {\n\t\tkey: 'equals',\n\t\tvalue: function equals(schemaB) {\n\t\t\tif (this.equalsTypeOnly(schemaB) === false) return false;\n\n\t\t\tfor (var i = 0; i < this._size; i++) {\n\t\t\t\tif (this._names[i] !== schemaB._names[i] || this._relAliases[i] !== schemaB._relAliases[i]) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: 'equalsTypeOnly',\n\t\tvalue: function equalsTypeOnly(schemaB) {\n\t\t\tif (this._size != schemaB._size) return false;\n\n\t\t\tfor (var i = 0; i < this._size; i++) {\n\t\t\t\tif (this._types[i] !== schemaB._types[i]) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// no index => all\n\n\t}, {\n\t\tkey: 'setRelAlias',\n\t\tvalue: function setRelAlias(relAlias, index) {\n\t\t\tvar setRelAliasAtIndex = function setRelAliasAtIndex(schema, relAlias, index) {\n\t\t\t\tschema._relAliases[index] = relAlias;\n\n\t\t\t\tif (schema.isUnique(index) === false) {\n\t\t\t\t\tthrow new Error(i18n.t('db.messages.exec.error-could-not-change-rel-alias-ambiguity', { alias: relAlias }));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (typeof index == 'undefined') {\n\t\t\t\t// set all relAliases\n\t\t\t\tfor (var i = 0; i < this._size; i++) {\n\t\t\t\t\tsetRelAliasAtIndex(this, relAlias, i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsetRelAliasAtIndex(this, relAlias, index);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'setName',\n\t\tvalue: function setName(newName, index) {\n\t\t\tvar oldName = this._names[index];\n\n\t\t\t// update index\n\t\t\tthis._removeColFromIndex(index);\n\t\t\tthis._addColToIndex(newName, index);\n\n\t\t\tthis._names[index] = newName;\n\n\t\t\tif (this.isUnique(index) === false) {\n\t\t\t\tthrow new Error(i18n.t('db.messages.exec.error-could-not-change-rel-alias-ambiguity', {\n\t\t\t\t\tnewName: newName,\n\t\t\t\t\toldName: oldName,\n\t\t\t\t\tschema: this.toString()\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'needsFullName',\n\t\tvalue: function needsFullName(index) {\n\t\t\treturn this._colIndexPerName[this._names[index]].length > 1;\n\t\t}\n\t}, {\n\t\tkey: 'getName',\n\t\tvalue: function getName(index) {\n\t\t\treturn this._names[index];\n\t\t}\n\t}, {\n\t\tkey: 'getFullName',\n\t\tvalue: function getFullName(index) {\n\t\t\treturn (this._relAliases[index] ? this._relAliases[index] + '.' : '') + this._names[index];\n\t\t}\n\t}, {\n\t\tkey: 'toString',\n\t\tvalue: function toString() {\n\t\t\tvar list = [];\n\n\t\t\tfor (var i = 0; i < this._size; i++) {\n\t\t\t\tvar c = this.getColumn(i);\n\t\t\t\tvar type = this.getType(i);\n\t\t\t\tvar name = c.toString();\n\t\t\t\t/*if(this.needsFullName(i))\n     name = c.toString();\n     else\n     name = c.getName();*/\n\n\t\t\t\tlist.push(name + ' : ' + type);\n\t\t\t}\n\t\t\treturn '[' + list.join(', ') + ']';\n\t\t}\n\n\t\t/**\n   * concatinates the two given schemas\n   * @param   {Schema} schemaA a Schema\n   * @param   {Schema} schemaB a Schema\n   * @returns {Schema} concatinated schema\n   */\n\n\t}], [{\n\t\tkey: 'concat',\n\t\tvalue: function concat(schemaA, schemaB) {\n\t\t\tvar schema = schemaA.copy();\n\n\t\t\tvar numColsB = schemaB.getSize();\n\t\t\tfor (var i = 0; i < numColsB; i++) {\n\t\t\t\tvar col = schemaB.getColumn(i);\n\t\t\t\tvar type = schemaB.getType(i);\n\t\t\t\tschema.addColumn(col.getName(), col.getRelAlias(), type);\n\t\t\t}\n\t\t\treturn schema;\n\t\t}\n\n\t\t/**\n   * concatinates the two given schemas like required by a natural join\n   * @param   {Schema}  schemaA             the first Schema\n   * @param   {Schema}  schemaB             the second Schema\n   * @param   {Boolean} keepColsFromSchemaA wether the columns of the left (true)\n   *                                      or the right (false) schema should be kept\n   *                                      if they have the same name\n   * @param   {Array}   [restrictToColumns] optional argument to indicate that only the columns\n   *                                      with names listed in the Array of Strings should\n   *                                      be considered for the equality search.\n   *                                      This is used for the USING() clause in SQL that is\n   *                                      actually a restricted version of a natural join\n   * @returns {Object}  an object {keep, schema} where keep is an Object describing which columns/indices\n   *                                             of which schema schould be kept and which not\n   */\n\n\t}, {\n\t\tkey: 'concatNatural',\n\t\tvalue: function concatNatural(schemaA, schemaB, keepColsFromSchemaA, restrictToColumns) {\n\t\t\tif (typeof keepColsFromSchemaA === 'undefined') keepColsFromSchemaA = true;\n\t\t\t// use only a certain set of columns (all by default)\n\t\t\tif (typeof restrictToColumns === 'undefined') restrictToColumns = false;\n\n\t\t\tvar sizeA = schemaA.getSize();\n\t\t\tvar sizeB = schemaB.getSize();\n\t\t\tvar work = {\n\t\t\t\tkeepA: new Array(sizeA),\n\t\t\t\tkeepB: new Array(sizeB),\n\t\t\t\tsize: -1, // size of schema\n\n\t\t\t\tkeepIndicesA: [],\n\t\t\t\tkeepIndicesB: []\n\t\t\t};\n\t\t\tvar i, j;\n\n\t\t\t// init\n\t\t\tfor (i = 0; i < sizeA; i++) {\n\t\t\t\twork.keepA[i] = true;\n\t\t\t}\n\t\t\tfor (i = 0; i < sizeB; i++) {\n\t\t\t\twork.keepB[i] = true;\n\t\t\t}\n\n\t\t\t// find columns with the same name in schemaA and schemaB\n\t\t\tfor (i = 0; i < sizeA; i++) {\n\t\t\t\tvar candidate = schemaA.getColumn(i);\n\t\t\t\tif (restrictToColumns !== false && restrictToColumns.indexOf(candidate.getName()) === -1) {\n\t\t\t\t\t// skip column if it is not in the restriction set\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar colIndicesInA = schemaA.getColumnIndexArray(candidate.getName(), null);\n\t\t\t\tvar colIndicesInB = schemaB.getColumnIndexArray(candidate.getName(), null);\n\n\t\t\t\tif (colIndicesInA.length === 0 || colIndicesInB.length === 0) continue;\n\n\t\t\t\tif (keepColsFromSchemaA) {\n\t\t\t\t\t// keep the all columns (with this name) in A and none (with this name) in B\n\t\t\t\t\tfor (j = 0; j < colIndicesInB.length; j++) {\n\t\t\t\t\t\twork.keepB[colIndicesInB[j]] = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// keep the all columns (with this name) in B and none (with this name) in A\n\t\t\t\t\tfor (j = 0; j < colIndicesInA.length; j++) {\n\t\t\t\t\t\twork.keepA[colIndicesInA[j]] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// generate concatenated schema from work-information\n\t\t\tvar schema = new Schema();\n\t\t\tvar col;\n\t\t\tfor (i = 0; i < sizeA; i++) {\n\t\t\t\tif (work.keepA[i] === false) continue;\n\n\t\t\t\tcol = schemaA.getColumn(i);\n\t\t\t\tschema.addColumn(col.getName(), col.getRelAlias(), schemaA.getType(i));\n\t\t\t}\n\t\t\tfor (i = 0; i < sizeB; i++) {\n\t\t\t\tif (work.keepB[i] === false) continue;\n\n\t\t\t\tcol = schemaB.getColumn(i);\n\t\t\t\tschema.addColumn(col.getName(), col.getRelAlias(), schemaB.getType(i));\n\t\t\t}\n\n\t\t\twork.size = schema.getSize();\n\n\t\t\t// create arrays with the indices we want to keep\n\t\t\tfor (i = 0; i < sizeA; i++) {\n\t\t\t\tif (work.keepA[i] === false) continue;\n\t\t\t\twork.keepIndicesA.push(i);\n\t\t\t}\n\t\t\tfor (i = 0; i < sizeB; i++) {\n\t\t\t\tif (work.keepB[i] === false) continue;\n\t\t\t\twork.keepIndicesB.push(i);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tkeep: work,\n\t\t\t\tschema: schema\n\t\t\t};\n\t\t}\n\t}]);\n\treturn Schema;\n}();\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Schema.js\n// module id = 101\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Schema.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Table = undefined;\n\nvar _getIterator2 = __webpack_require__(103);\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _stringify = __webpack_require__(108);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _map = __webpack_require__(110);\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _Schema = __webpack_require__(101);\n\nvar _Relation = __webpack_require__(132);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Table = exports.Table = function () {\n\tfunction Table() {\n\t\t(0, _classCallCheck3.default)(this, Table);\n\n\t\tthis._rows = [];\n\t\tthis._schema = new _Schema.Schema();\n\t}\n\n\t(0, _createClass3.default)(Table, [{\n\t\tkey: 'addRow',\n\t\tvalue: function addRow(dataArray) {\n\t\t\tthis._rows.push(dataArray);\n\t\t}\n\t}, {\n\t\tkey: 'addRows',\n\t\tvalue: function addRows(rows) {\n\t\t\tfor (var i = 0; i < rows.length; i++) {\n\t\t\t\tthis.addRow(rows[i]);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'setSchema',\n\t\tvalue: function setSchema(schema) {\n\t\t\tif (schema instanceof _Schema.Schema === false) throw new Error(\"illegal argument: no schema\");\n\n\t\t\tthis._schema = schema;\n\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._schema;\n\t\t}\n\t}, {\n\t\tkey: 'getRow',\n\t\tvalue: function getRow(i) {\n\t\t\treturn this._rows[i];\n\t\t}\n\t}, {\n\t\tkey: 'getRows',\n\t\tvalue: function getRows() {\n\t\t\treturn this._rows;\n\t\t}\n\t}, {\n\t\tkey: 'getNumRows',\n\t\tvalue: function getNumRows() {\n\t\t\treturn this._rows.length;\n\t\t}\n\t}, {\n\t\tkey: 'getNumCols',\n\t\tvalue: function getNumCols() {\n\t\t\treturn this._schema.getSize();\n\t\t}\n\t}, {\n\t\tkey: 'getValueHtmlAt',\n\t\tvalue: function getValueHtmlAt(row, col) {\n\t\t\tvar value = this._rows[row][col];\n\t\t\tvar type = this._schema.getType(col);\n\n\t\t\tvar text;\n\n\t\t\tif (value === null) {\n\t\t\t\ttext = 'null';\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'number':\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\ttext = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'date':\n\t\t\t\t\t\ttext = value.getFullYear() + '-' + (value.getMonth() + 1 < 10 ? '0' + (value.getMonth() + 1) : value.getMonth() + 1) + '-' + (value.getDate() < 10 ? '0' + value.getDate() : value.getDate());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\ttext = value ? 'true' : 'false';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('unknown type ' + type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn '<span class=\"' + (value === null ? 'null ' + type : type) + '\">' + text + '</span>';\n\t\t}\n\t}, {\n\t\tkey: 'getHtml',\n\t\tvalue: function getHtml(unqualifiedColumnNames, maxRows, offset) {\n\t\t\toffset = offset || 0;\n\n\t\t\tvar numCols = this.getNumCols();\n\t\t\tvar i;\n\n\t\t\tvar thead = '<thead><tr>';\n\t\t\tfor (i = 0; i < numCols; i++) {\n\t\t\t\tvar c = this._schema.getColumn(i);\n\n\t\t\t\tif (unqualifiedColumnNames) thead += '<th>' + c.getName() + '</th>';else thead += '<th>' + c.toString() + '</th>';\n\t\t\t}\n\t\t\tthead += '</tr></thead>';\n\n\t\t\tvar tbody = '<tbody>';\n\t\t\tvar numRows = this.getNumRows();\n\t\t\tvar end = numRows;\n\t\t\tif (maxRows) end = Math.min(numRows, offset + maxRows);\n\n\t\t\tfor (i = offset; i < end; i++) {\n\t\t\t\tvar tr = '<tr>';\n\t\t\t\tfor (var j = 0; j < numCols; j++) {\n\t\t\t\t\ttr += '<td>' + this.getValueHtmlAt(i, j) + '</td>';\n\t\t\t\t}tbody += tr + '</tr>';\n\t\t\t}\n\n\t\t\treturn '<table>' + thead + tbody + '</table>';\n\t\t}\n\t}, {\n\t\tkey: 'equals',\n\t\tvalue: function equals(table) {\n\t\t\tif (table instanceof Table === false) throw new Error(\"can not compare\");\n\n\t\t\t// compare schema\n\t\t\tif (this._schema.equals(table._schema) === false) return false;\n\n\t\t\t// compare rows\n\t\t\tif (this._rows.length != table._rows.length) return false;\n\n\t\t\tfor (var i = 0; i < this._rows.length; i++) {\n\t\t\t\tif (Table.rowEqualsRow(this._rows[i], table._rows[i]) == false) return false;\n\t\t\t}return true;\n\t\t}\n\t}, {\n\t\tkey: 'eliminateDuplicateRows',\n\t\tvalue: function eliminateDuplicateRows() {\n\t\t\tvar uniqueRows = new _map2.default();\n\t\t\tfor (var i = 0; i < this._rows.length; i++) {\n\t\t\t\tvar key = (0, _stringify2.default)(this._rows[i]);\n\t\t\t\tif (uniqueRows.has(key) === false) {\n\t\t\t\t\tuniqueRows.set(key, this._rows[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._rows = [];\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = (0, _getIterator3.default)(uniqueRows.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar value = _step.value;\n\n\t\t\t\t\tthis._rows.push(value);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'sort',\n\t\tvalue: function sort(sortByColumnIndices, sortAscending) {\n\t\t\tvar size = this.getNumCols();\n\t\t\tvar i;\n\n\t\t\tif (typeof sortByColumnIndices == 'undefined') {\n\t\t\t\tsortByColumnIndices = [];\n\t\t\t\tfor (i = 0; i < size; i++) {\n\t\t\t\t\tsortByColumnIndices[i] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof sortAscending == 'undefined') {\n\t\t\t\tsortAscending = [];\n\t\t\t\tfor (i = 0; i < sortByColumnIndices.length; i++) {\n\t\t\t\t\tsortAscending[i] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check indices\n\t\t\tif (sortByColumnIndices.length > size) throw new Error('invalid sort cols');\n\n\t\t\tfor (i = 0; i < sortByColumnIndices.length; i++) {\n\t\t\t\tif (sortByColumnIndices[i] >= size || sortByColumnIndices[i] < 0) throw new Error('invalid sort cols');\n\t\t\t}\n\n\t\t\t// check sort order array\n\t\t\tvar sortByColumnIndicesLength = sortByColumnIndices.length;\n\t\t\tif (sortByColumnIndicesLength != sortAscending.length) throw new Error('invalid sort cols');\n\n\t\t\tvar sortByColumnIndicesTypes = [];\n\t\t\tfor (i = 0; i < sortByColumnIndices.length; i++) {\n\t\t\t\tsortByColumnIndicesTypes[i] = this._schema.getType(sortByColumnIndices[i]);\n\t\t\t}\n\n\t\t\tvar compare = function compare(rowA, rowB, col, mul, type) {\n\t\t\t\tvar o1 = rowA[col];\n\t\t\t\tvar o2 = rowB[col];\n\n\t\t\t\tif (o1 == null && o2 == null) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} else if (o1 == null && o2 != null) {\n\t\t\t\t\treturn mul * 1;\n\t\t\t\t} else if (o1 != null && o2 == null) {\n\t\t\t\t\treturn mul * -1;\n\t\t\t\t} else if (type == 'number' || type == 'date' || type == 'boolean') {\n\t\t\t\t\treturn mul * (o1 - o2);\n\t\t\t\t} else if (typeof o1 == 'string') {\n\t\t\t\t\treturn mul * o1.localeCompare(o2);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar compareAll = function compareAll(rowA, rowB) {\n\t\t\t\tvar mul, col, type;\n\n\t\t\t\tvar last = 0;\n\t\t\t\tfor (var i = 0; i < sortByColumnIndicesLength; i++) {\n\t\t\t\t\tmul = sortAscending[i] ? 1 : -1;\n\t\t\t\t\tcol = sortByColumnIndices[i];\n\t\t\t\t\ttype = sortByColumnIndicesTypes[i];\n\n\t\t\t\t\tlast = compare(rowA, rowB, col, mul, type);\n\t\t\t\t\tif (last === 0) continue;\n\n\t\t\t\t\treturn last;\n\t\t\t\t}\n\t\t\t\treturn last;\n\t\t\t};\n\n\t\t\tthis._rows.sort(compareAll);\n\t\t}\n\t}, {\n\t\tkey: 'copy',\n\t\tvalue: function copy() {\n\t\t\tvar res = new Table();\n\t\t\tres.setSchema(this.getSchema().copy());\n\t\t\tres.addRows(this.getRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'createRelation',\n\t\tvalue: function createRelation(name) {\n\t\t\tvar relation = new _Relation.Relation(name);\n\t\t\trelation.setSchema(this.getSchema().copy());\n\t\t\trelation.addRows(this.getRows());\n\t\t\treturn relation;\n\t\t}\n\t}], [{\n\t\tkey: 'rowEqualsRow',\n\t\tvalue: function rowEqualsRow(rowA, rowB) {\n\t\t\tif (rowA.length != rowB.length) return false;\n\n\t\t\tfor (var i = 0; i < rowA.length; i++) {\n\t\t\t\tif (rowA[i] !== rowB[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}]);\n\treturn Table;\n}();\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Table.js\n// module id = 102\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Table.js?");
},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(104), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/get-iterator.js\n// module id = 103\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/get-iterator.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(67);\n__webpack_require__(55);\nmodule.exports = __webpack_require__(105);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/get-iterator.js\n// module id = 104\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/get-iterator.js?")},function(module,exports,__webpack_require__){eval("var anObject = __webpack_require__(30);\nvar get = __webpack_require__(106);\nmodule.exports = __webpack_require__(25).getIterator = function (it) {\n  var iterFn = get(it);\n  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/core.get-iterator.js\n// module id = 105\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/core.get-iterator.js?")},function(module,exports,__webpack_require__){eval("var classof = __webpack_require__(107);\nvar ITERATOR = __webpack_require__(66)('iterator');\nvar Iterators = __webpack_require__(60);\nmodule.exports = __webpack_require__(25).getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/core.get-iterator-method.js\n// module id = 106\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/core.get-iterator-method.js?")},function(module,exports,__webpack_require__){eval("// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(13);\nvar TAG = __webpack_require__(66)('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_classof.js\n// module id = 107\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_classof.js?")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(109), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/json/stringify.js\n// module id = 108\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/json/stringify.js?')},function(module,exports,__webpack_require__){eval("var core = __webpack_require__(25);\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/json/stringify.js\n// module id = 109\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/json/stringify.js?")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(111), __esModule: true };\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/map.js\n// module id = 110\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/babel-runtime/core-js/map.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(84);\n__webpack_require__(55);\n__webpack_require__(67);\n__webpack_require__(112);\n__webpack_require__(125);\n__webpack_require__(128);\n__webpack_require__(130);\nmodule.exports = __webpack_require__(25).Map;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/map.js\n// module id = 111\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/fn/map.js?")},function(module,exports,__webpack_require__){eval("'use strict';\nvar strong = __webpack_require__(113);\nvar validate = __webpack_require__(120);\nvar MAP = 'Map';\n\n// 23.1 Map Objects\nmodule.exports = __webpack_require__(121)(MAP, function (get) {\n  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key) {\n    var entry = strong.getEntry(validate(this, MAP), key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value) {\n    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.map.js\n// module id = 112\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es6.map.js?")},function(module,exports,__webpack_require__){eval("'use strict';\nvar dP = __webpack_require__(29).f;\nvar create = __webpack_require__(62);\nvar redefineAll = __webpack_require__(114);\nvar ctx = __webpack_require__(26);\nvar anInstance = __webpack_require__(115);\nvar forOf = __webpack_require__(116);\nvar $iterDefine = __webpack_require__(57);\nvar step = __webpack_require__(70);\nvar setSpecies = __webpack_require__(119);\nvar DESCRIPTORS = __webpack_require__(33);\nvar fastKey = __webpack_require__(75).fastKey;\nvar validate = __webpack_require__(120);\nvar SIZE = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function (that, key) {\n  // fast case\n  var index = fastKey(key);\n  var entry;\n  if (index !== 'F') return that._i[index];\n  // frozen object case\n  for (entry = that._f; entry; entry = entry.n) {\n    if (entry.k == key) return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;         // collection type\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\n          entry.r = true;\n          if (entry.p) entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = validate(this, NAME);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.n;\n          var prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if (prev) prev.n = next;\n          if (next) next.p = prev;\n          if (that._f == entry) that._f = next;\n          if (that._l == entry) that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        validate(this, NAME);\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.n : this._f) {\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while (entry && entry.r) entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(validate(this, NAME), key);\n      }\n    });\n    if (DESCRIPTORS) dP(C.prototype, 'size', {\n      get: function () {\n        return validate(this, NAME)[SIZE];\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var entry = getEntry(that, key);\n    var prev, index;\n    // change existing entry\n    if (entry) {\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if (!that._f) that._f = entry;\n      if (prev) prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if (index !== 'F') that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function (C, NAME, IS_MAP) {\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function (iterated, kind) {\n      this._t = validate(iterated, NAME); // target\n      this._k = kind;                     // kind\n      this._l = undefined;                // previous\n    }, function () {\n      var that = this;\n      var kind = that._k;\n      var entry = that._l;\n      // revert to the last existing entry\n      while (entry && entry.r) entry = entry.p;\n      // get next entry\n      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if (kind == 'keys') return step(0, entry.k);\n      if (kind == 'values') return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_collection-strong.js\n// module id = 113\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_collection-strong.js?")},function(module,exports,__webpack_require__){eval("var hide = __webpack_require__(28);\nmodule.exports = function (target, src, safe) {\n  for (var key in src) {\n    if (safe && target[key]) target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_redefine-all.js\n// module id = 114\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_redefine-all.js?")},function(module,exports){eval("module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_an-instance.js\n// module id = 115\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_an-instance.js?")},function(module,exports,__webpack_require__){eval("var ctx = __webpack_require__(26);\nvar call = __webpack_require__(117);\nvar isArrayIter = __webpack_require__(118);\nvar anObject = __webpack_require__(30);\nvar toLength = __webpack_require__(15);\nvar getIterFn = __webpack_require__(106);\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_for-of.js\n// module id = 116\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_for-of.js?")},function(module,exports,__webpack_require__){eval("// call something on iterator step with safe closing on error\nvar anObject = __webpack_require__(30);\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-call.js\n// module id = 117\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_iter-call.js?")},function(module,exports,__webpack_require__){eval("// check on default Array iterator\nvar Iterators = __webpack_require__(60);\nvar ITERATOR = __webpack_require__(66)('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-array-iter.js\n// module id = 118\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_is-array-iter.js?")},function(module,exports,__webpack_require__){eval("'use strict';\nvar global = __webpack_require__(20);\nvar core = __webpack_require__(25);\nvar dP = __webpack_require__(29);\nvar DESCRIPTORS = __webpack_require__(33);\nvar SPECIES = __webpack_require__(66)('species');\n\nmodule.exports = function (KEY) {\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_set-species.js\n// module id = 119\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_set-species.js?")},function(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(31);\nmodule.exports = function (it, TYPE) {\n  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_validate-collection.js\n// module id = 120\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_validate-collection.js?")},function(module,exports,__webpack_require__){eval("'use strict';\nvar global = __webpack_require__(20);\nvar $export = __webpack_require__(24);\nvar meta = __webpack_require__(75);\nvar fails = __webpack_require__(34);\nvar hide = __webpack_require__(28);\nvar redefineAll = __webpack_require__(114);\nvar forOf = __webpack_require__(116);\nvar anInstance = __webpack_require__(115);\nvar isObject = __webpack_require__(31);\nvar setToStringTag = __webpack_require__(65);\nvar dP = __webpack_require__(29).f;\nvar each = __webpack_require__(122)(0);\nvar DESCRIPTORS = __webpack_require__(33);\n\nmodule.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\n  var Base = global[NAME];\n  var C = Base;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var proto = C && C.prototype;\n  var O = {};\n  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {\n    new C().entries().next();\n  }))) {\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    C = wrapper(function (target, iterable) {\n      anInstance(target, C, NAME, '_c');\n      target._c = new Base();\n      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);\n    });\n    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {\n      var IS_ADDER = KEY == 'add' || KEY == 'set';\n      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {\n        anInstance(this, C, KEY);\n        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;\n        var result = this._c[KEY](a === 0 ? 0 : a, b);\n        return IS_ADDER ? this : result;\n      });\n    });\n    IS_WEAK || dP(C.prototype, 'size', {\n      get: function () {\n        return this._c.size;\n      }\n    });\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F, O);\n\n  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_collection.js\n// module id = 121\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_collection.js?")},function(module,exports,__webpack_require__){eval("// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx = __webpack_require__(26);\nvar IObject = __webpack_require__(12);\nvar toObject = __webpack_require__(6);\nvar toLength = __webpack_require__(15);\nvar asc = __webpack_require__(123);\nmodule.exports = function (TYPE, $create) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  var create = $create || asc;\n  return function ($this, callbackfn, that) {\n    var O = toObject($this);\n    var self = IObject(O);\n    var f = ctx(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var val, res;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      val = self[index];\n      res = f(val, index, O);\n      if (TYPE) {\n        if (IS_MAP) result[index] = res;   // map\n        else if (res) switch (TYPE) {\n          case 3: return true;             // some\n          case 5: return val;              // find\n          case 6: return index;            // findIndex\n          case 2: result.push(val);        // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-methods.js\n// module id = 122\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_array-methods.js?")},function(module,exports,__webpack_require__){eval("// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = __webpack_require__(124);\n\nmodule.exports = function (original, length) {\n  return new (speciesConstructor(original))(length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-species-create.js\n// module id = 123\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_array-species-create.js?")},function(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(31);\nvar isArray = __webpack_require__(80);\nvar SPECIES = __webpack_require__(66)('species');\n\nmodule.exports = function (original) {\n  var C;\n  if (isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-species-constructor.js\n// module id = 124\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_array-species-constructor.js?")},function(module,exports,__webpack_require__){eval("// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export = __webpack_require__(24);\n\n$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(126)('Map') });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es7.map.to-json.js\n// module id = 125\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es7.map.to-json.js?")},function(module,exports,__webpack_require__){eval('// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar classof = __webpack_require__(107);\nvar from = __webpack_require__(127);\nmodule.exports = function (NAME) {\n  return function toJSON() {\n    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn\'t generic");\n    return from(this);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_collection-to-json.js\n// module id = 126\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_collection-to-json.js?')},function(module,exports,__webpack_require__){eval("var forOf = __webpack_require__(116);\n\nmodule.exports = function (iter, ITERATOR) {\n  var result = [];\n  forOf(iter, false, result.push, result, ITERATOR);\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-from-iterable.js\n// module id = 127\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_array-from-iterable.js?")},function(module,exports,__webpack_require__){eval("// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of\n__webpack_require__(129)('Map');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es7.map.of.js\n// module id = 128\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es7.map.of.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n// https://tc39.github.io/proposal-setmap-offrom/\nvar $export = __webpack_require__(24);\n\nmodule.exports = function (COLLECTION) {\n  $export($export.S, COLLECTION, { of: function of() {\n    var length = arguments.length;\n    var A = Array(length);\n    while (length--) A[length] = arguments[length];\n    return new this(A);\n  } });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_set-collection-of.js\n// module id = 129\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_set-collection-of.js?")},function(module,exports,__webpack_require__){eval("// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from\n__webpack_require__(131)('Map');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es7.map.from.js\n// module id = 130\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/es7.map.from.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n// https://tc39.github.io/proposal-setmap-offrom/\nvar $export = __webpack_require__(24);\nvar aFunction = __webpack_require__(27);\nvar ctx = __webpack_require__(26);\nvar forOf = __webpack_require__(116);\n\nmodule.exports = function (COLLECTION) {\n  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {\n    var mapFn = arguments[1];\n    var mapping, A, n, cb;\n    aFunction(this);\n    mapping = mapFn !== undefined;\n    if (mapping) aFunction(mapFn);\n    if (source == undefined) return new this();\n    A = [];\n    if (mapping) {\n      n = 0;\n      cb = ctx(mapFn, arguments[2], 2);\n      forOf(source, false, function (nextItem) {\n        A.push(cb(nextItem, n++));\n      });\n    } else {\n      forOf(source, false, A.push, A);\n    }\n    return new this(A);\n  } });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_set-collection-from.js\n// module id = 131\n// module chunks = 0 1\n//# sourceURL=webpack:///./~/core-js/library/modules/_set-collection-from.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Relation = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Table = __webpack_require__(102);\n\nvar _Schema = __webpack_require__(101);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * the base of all relational algebra statements\n * @param   {String} functionName the name of the relation\n * @returns {Relation}\n * @constructor\n * @augments RANode\n */\nvar Relation = exports.Relation = function (_RANode) {\n\t(0, _inherits3.default)(Relation, _RANode);\n\n\tfunction Relation(functionName) {\n\t\t(0, _classCallCheck3.default)(this, Relation);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (Relation.__proto__ || (0, _getPrototypeOf2.default)(Relation)).call(this, functionName));\n\n\t\t_this._table = new _Table.Table();\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(Relation, [{\n\t\tkey: 'setChild',\n\t\tvalue: function setChild() {\n\t\t\tthrow new Error('not implemented: needs to be overwritten');\n\t\t}\n\t}, {\n\t\tkey: 'setSchema',\n\t\tvalue: function setSchema(schema, doNotSetRelAlias) {\n\t\t\tthis._schema = schema.copy();\n\t\t\tif (doNotSetRelAlias !== true) this._schema.setRelAlias(this._functionName);\n\t\t\tthis._table.setSchema(this._schema);\n\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: 'addRow',\n\t\tvalue: function addRow(arr) {\n\t\t\tthis._table.addRow(arr);\n\t\t}\n\t}, {\n\t\tkey: 'addRows',\n\t\tvalue: function addRows(arr) {\n\t\t\tthis._table.addRows(arr);\n\t\t}\n\t}, {\n\t\tkey: 'getResultNumRows',\n\t\tvalue: function getResultNumRows() {\n\t\t\treturn this._resultNumRows;\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tthis._returnOrCreateSession(session);\n\n\t\t\tvar res = this._table.copy();\n\n\t\t\tres.eliminateDuplicateRows();\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._table.getSchema();\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\t// noop\n\t\t}\n\t}, {\n\t\tkey: 'hasChild',\n\t\tvalue: function hasChild() {\n\t\t\treturn false;\n\t\t}\n\t}, {\n\t\tkey: 'copy',\n\t\tvalue: function copy() {\n\t\t\tvar c = new Relation(this._functionName);\n\t\t\tc.setSchema(this._schema);\n\t\t\tc._table = this._table.copy();\n\t\t\treturn c;\n\t\t}\n\t}]);\n\treturn Relation;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Relation.js\n// module id = 132\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Relation.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.RANode = undefined;\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * the base class for all relational algebra operations\n *\n * the calculation of an expression must follow the following 3 steps:\n * - the instances of the operators get plugged together building a operator tree\n *   at this stage no checking is done\n * - the `check()` function  is called recursively to check the correct nesting\n *   of the expressions like schema compability or existence of columns\n *   used in an projection\n *   The `check()` function also calculates the output schema for the specific\n *   operator.\n * - after check has been called the actual result is calculated when `getResult()` is called\n *   the results are not cached and return a new of Table that is independant of the results\n *   of their operands\n *   the session object is created automatically at the root of the tree\n * @constructor\n * @abstract\n * @returns {RANode} this is an abstract class\n */\nvar RANode = exports.RANode = function () {\n\tfunction RANode(functionName) {\n\t\t(0, _classCallCheck3.default)(this, RANode);\n\n\t\tthis._functionName = functionName || '';\n\t\tthis._child = null;\n\t\tthis._child2 = null;\n\t\tthis._codeInfo = null;\n\t\tthis._metaData = {};\n\t\tthis._resultNumRows = -1;\n\t\tthis._wrappedInBrackets = false;\n\t\tthis._warnings = [];\n\t}\n\n\t(0, _createClass3.default)(RANode, [{\n\t\tkey: 'setCodeInfoObject',\n\t\tvalue: function setCodeInfoObject(codeInfo) {\n\t\t\t/*codeInfo =\n   {\n   \tlocation: {\n   \t\tstart: { offset: 0, line: 0, column: 0 },\n   \t\tend:   { offset: 0, line: 0, column: 0 },\n   \t},\n   \ttext: ''\n   }*/\n\n\t\t\tthis._codeInfo = codeInfo;\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: 'addWarning',\n\t\tvalue: function addWarning(msg, codeInfo) {\n\t\t\tvar w = {\n\t\t\t\tmessage: msg\n\t\t\t};\n\t\t\tif (codeInfo) {\n\t\t\t\tw.codeInfo = codeInfo;\n\t\t\t}\n\n\t\t\tif (!this._warnings) this._warnings = [];\n\n\t\t\tthis._warnings.push(w);\n\t\t}\n\t}, {\n\t\tkey: 'getWarnings',\n\t\tvalue: function getWarnings(recursive) {\n\t\t\tvar acc = this._warnings ? this._warnings.slice() : [];\n\n\t\t\tif (recursive === true && this.hasChild()) acc = acc.concat(this.getChild().getWarnings(true));\n\t\t\tif (recursive === true && this.hasChild2()) acc = acc.concat(this.getChild2().getWarnings(true));\n\n\t\t\treturn acc;\n\t\t}\n\t}, {\n\t\tkey: 'setWrappedInBrackets',\n\t\tvalue: function setWrappedInBrackets(wrappedInBrackets) {\n\t\t\tthis._wrappedInBrackets = wrappedInBrackets === undefined ? true : wrappedInBrackets;\n\t\t}\n\t}, {\n\t\tkey: 'throwExecutionError',\n\t\tvalue: function throwExecutionError(message) {\n\t\t\tthrow new _ExecutionError.ExecutionError(message, this._codeInfo);\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\tthrow new Error('not implemented: needs to be overwritten');\n\t\t}\n\t}, {\n\t\tkey: 'getChild',\n\t\tvalue: function getChild() {\n\t\t\treturn this._child;\n\t\t}\n\t}, {\n\t\tkey: 'getChild2',\n\t\tvalue: function getChild2() {\n\t\t\treturn this._child2;\n\t\t}\n\t}, {\n\t\tkey: 'hasChild2',\n\t\tvalue: function hasChild2() {\n\t\t\treturn typeof this._child2 != 'undefined' && this._child2 !== null;\n\t\t}\n\t}, {\n\t\tkey: 'hasChild',\n\t\tvalue: function hasChild() {\n\t\t\treturn typeof this._child != 'undefined' && this._child !== null;\n\t\t}\n\t}, {\n\t\tkey: 'setChild',\n\t\tvalue: function setChild(child) {\n\t\t\tthis._child = child;\n\t\t}\n\t}, {\n\t\tkey: 'setChild2',\n\t\tvalue: function setChild2(child2) {\n\t\t\tthrow new Error('not implemented: needs to be overwritten');\n\t\t}\n\t}, {\n\t\tkey: 'setMetaData',\n\t\tvalue: function setMetaData(key, value) {\n\t\t\tif (!this._metaData) this._metaData = {};\n\t\t\tthis._metaData[key] = value;\n\t\t}\n\t}, {\n\t\tkey: 'hasMetaData',\n\t\tvalue: function hasMetaData(key) {\n\t\t\tif (!this._metaData) return false;\n\t\t\treturn typeof this._metaData[key] !== 'undefined';\n\t\t}\n\t}, {\n\t\tkey: 'getMetaData',\n\t\tvalue: function getMetaData(key) {\n\t\t\treturn this._metaData[key];\n\t\t}\n\t}, {\n\t\tkey: 'getResultNumRows',\n\t\tvalue: function getResultNumRows() {\n\t\t\tif (typeof this._resultNumRows == 'undefined' || this._resultNumRows == -1) throw new Error('result num rows not set! call only after getResult');\n\n\t\t\treturn this._resultNumRows;\n\t\t}\n\t}, {\n\t\tkey: 'setResultNumRows',\n\t\tvalue: function setResultNumRows(num) {\n\t\t\tthis._resultNumRows = num;\n\t\t}\n\n\t\t/**\n   * every implementation has to call\n   *  `session = this._returnOrCreateSession(session);`\n   * to initialize the session if necessary\n   *\n   * @param {Object} [session] the session object or undefined if called on a root node\n   */\n\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tthrow new Error('not implemented: needs to be overwritten');\n\t\t}\n\n\t\t/**\n   * this method is called in every getResult() method\n   *\n   * this is actually a hack due to the lack of a statement object\n   * there is no place to store data that can be used\n   * by all operators\n   *\n   * the method will create a new session when called with undefined\n   * or just returns the argument\n   *\n   * @param   {Object} session the already initialized session object or undefined\n   * @returns {Object} [[Description]]\n   */\n\n\t}, {\n\t\tkey: '_returnOrCreateSession',\n\t\tvalue: function _returnOrCreateSession(session) {\n\t\t\tif (typeof session === 'undefined') {\n\t\t\t\t// create a new session\n\t\t\t\treturn {\n\t\t\t\t\tstatement_timestamp: new Date()\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn session;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'getArgumentHtml',\n\t\tvalue: function getArgumentHtml() {\n\t\t\treturn '';\n\t\t}\n\t}, {\n\t\tkey: 'getFormulaHtml',\n\t\tvalue: function getFormulaHtml(printChildren, isChildElement) {\n\t\t\tprintChildren = typeof printChildren === 'undefined' ? true : printChildren;\n\n\t\t\t// used to prevent brackets for the root element\n\t\t\tisChildElement = typeof isChildElement === 'undefined' ? true : isChildElement;\n\n\t\t\tvar s = '';\n\t\t\tif (this.hasChild() && this.hasChild2()) {\n\t\t\t\t// binary functions\n\t\t\t\ts += '<span class=\"math\"> ' + this._functionName + ' </span>';\n\t\t\t\ts += '<sub> ' + this.getArgumentHtml() + ' </sub>';\n\n\t\t\t\tif (printChildren === true) {\n\t\t\t\t\ts = this.getChild().getFormulaHtml(printChildren) + s;\n\t\t\t\t\ts += this.getChild2().getFormulaHtml(printChildren);\n\t\t\t\t}\n\t\t\t} else if (this.hasChild()) {\n\t\t\t\ts += '<span class=\"math\"> ' + this._functionName + ' </span>';\n\t\t\t\ts += '<sub> ' + this.getArgumentHtml() + ' </sub>';\n\n\t\t\t\tif (printChildren === true) {\n\t\t\t\t\ts += this.getChild().getFormulaHtml(printChildren);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts += '<span class=\"math\">' + this._functionName + '</span>';\n\t\t\t}\n\n\t\t\ts = '<span>' + s + '</span>';\n\n\t\t\tif (this._wrappedInBrackets === true && isChildElement === true) {\n\t\t\t\treturn '(' + s + ')';\n\t\t\t} else {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthrow new Error('not implemented: needs to be overwritten');\n\t\t}\n\t}]);\n\treturn RANode;\n}();\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/RANode.js\n// module id = 133\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/RANode.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Projection = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Table = __webpack_require__(102);\n\nvar _Schema = __webpack_require__(101);\n\nvar _Column = __webpack_require__(100);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra projection operator\n * @constructor\n * @extends RANode\n * @param   {RANode} child  the child expression\n * @param   {RANode} proj array of {name, relAlias, child} or Column (mixed)\n * @returns {RANode}\n */\nvar Projection = exports.Projection = function (_RANode) {\n\t(0, _inherits3.default)(Projection, _RANode);\n\n\tfunction Projection(child, proj) {\n\t\t(0, _classCallCheck3.default)(this, Projection);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (Projection.__proto__ || (0, _getPrototypeOf2.default)(Projection)).call(this, '&pi;'));\n\n\t\t_this._proj = null;\n\t\t_this._projIndeces = null; // set by check\n\t\t_this._projectedSchema = null;\n\n\t\t_this.setChild(child);\n\t\tif (typeof proj !== 'undefined') _this.setProjection(proj);\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(Projection, [{\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\tif (this._proj === null) return this._child.getSchema();\n\n\t\t\treturn this._projectedSchema;\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tif (this._proj === null) return this._child.getResult(session);\n\n\t\t\tvar org = this._child.getResult(session);\n\t\t\tvar res = new _Table.Table();\n\t\t\tres.setSchema(this.getSchema());\n\n\t\t\tvar numCols = res.getNumCols();\n\t\t\tvar numRows = org.getNumRows();\n\n\t\t\tvar i, j, orgRow, resRow;\n\t\t\tfor (i = 0; i < numRows; i++) {\n\t\t\t\torgRow = org.getRow(i);\n\t\t\t\tresRow = new Array(numCols);\n\t\t\t\tfor (j = 0; j < numCols; j++) {\n\t\t\t\t\tif (this._projIndeces[j] === -1) {\n\t\t\t\t\t\tresRow[j] = this._proj[j].child.evaluate(orgRow, null, i, session);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresRow[j] = orgRow[this._projIndeces[j]];\n\t\t\t\t\t}\n\t\t\t\t\t//resRow[j] = i+1; //ROWNUM\n\t\t\t\t}\n\t\t\t\tres.addRow(resRow);\n\t\t\t}\n\n\t\t\tres.eliminateDuplicateRows();\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\n\t\t/**\n   * sets the projection of the node\n   * @param proj array of {name, relAlias, child} or Column\n   */\n\n\t}, {\n\t\tkey: 'setProjection',\n\t\tvalue: function setProjection(proj) {\n\t\t\tif (this.hasChild() === false) throw new Error(\"no child set\");\n\n\t\t\tthis._proj = proj;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\n\t\t\t// check if all parts are part of the schema\n\t\t\tvar unprojectedSchema = this._child.getSchema();\n\t\t\tvar proj = this._proj;\n\t\t\tvar childSchema = this._child.getSchema();\n\t\t\tvar name, relAlias;\n\t\t\tvar col, index, i;\n\n\t\t\ttry {\n\n\t\t\t\t// handle if column name == X.* => replace entry in proj with real names\n\t\t\t\tfor (i = 0; i < proj.length; i++) {\n\t\t\t\t\tif (proj[i] instanceof _Column.Column === false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tname = proj[i].getName();\n\t\t\t\t\trelAlias = proj[i].getRelAlias();\n\t\t\t\t\tif (name !== '*') continue;\n\n\t\t\t\t\tproj.splice(i, 1);\n\n\t\t\t\t\tvar found = 0;\n\t\t\t\t\tfor (var j = 0; j < childSchema.getSize(); j++) {\n\t\t\t\t\t\tcol = childSchema.getColumn(j);\n\t\t\t\t\t\tif (relAlias !== null && col.getRelAlias() != relAlias) continue;\n\n\t\t\t\t\t\tproj.splice(i + found, 0, col); //TODO: add {name, child, relalias}\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (found === 0) this.throwExecutionError(i18n.t('db.messages.exec.error-no-columns-match-alias-star'));\n\t\t\t\t}\n\n\t\t\t\t// call check for all expression\n\t\t\t\tfor (i = 0; i < proj.length; i++) {\n\t\t\t\t\tif (proj[i] instanceof _Column.Column) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tproj[i].child.check(unprojectedSchema, null);\n\t\t\t\t\tif (proj[i].child.getDataType() === 'null') {\n\t\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-datatype-not-specified-for-col', {\n\t\t\t\t\t\t\tindex: i + 1,\n\t\t\t\t\t\t\tcolumn: proj[i].child._codeInfo.text\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// search for indices with the names\n\t\t\t\tthis._projIndeces = [];\n\t\t\t\tfor (i = 0; i < proj.length; i++) {\n\t\t\t\t\tif (proj[i] instanceof _Column.Column === false) {\n\t\t\t\t\t\tindex = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname = proj[i].getName();\n\t\t\t\t\t\trelAlias = proj[i].getRelAlias();\n\t\t\t\t\t\tindex = childSchema.getColumnIndex(name, relAlias);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._projIndeces[i] = index;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof _ExecutionError.ExecutionError) throw e;else this.throwExecutionError(i18n.t('db.messages.exec.error-invalid-projection-error', {\n\t\t\t\t\targument: this.getArgumentHtml(),\n\t\t\t\t\terror: e.message\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// create projected schema\n\t\t\tvar projectedSchema = new _Schema.Schema();\n\t\t\tfor (i = 0; i < this._projIndeces.length; i++) {\n\t\t\t\tindex = this._projIndeces[i];\n\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tprojectedSchema.addColumn(proj[i].name, proj[i].relAlias, proj[i].child.getDataType());\n\t\t\t\t} else {\n\t\t\t\t\tcol = unprojectedSchema.getColumn(index);\n\t\t\t\t\tvar type = unprojectedSchema.getType(index);\n\t\t\t\t\tprojectedSchema.addColumn(col.getName(), col.getRelAlias(), type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._projectedSchema = projectedSchema;\n\t\t}\n\t}, {\n\t\tkey: 'getArgumentHtml',\n\t\tvalue: function getArgumentHtml() {\n\t\t\tvar i,\n\t\t\t    args = [];\n\t\t\tvar tmp, p;\n\n\t\t\tfor (i = 0; i < this._proj.length; i++) {\n\t\t\t\tp = this._proj[i];\n\n\t\t\t\tif (p instanceof _Column.Column === true) {\n\t\t\t\t\targs.push(p.toString());\n\t\t\t\t} else {\n\t\t\t\t\ttmp = p.child.getFormulaHtml();\n\t\t\t\t\ttmp += '→';\n\t\t\t\t\ttmp += p.relAlias === null ? '' : p.relAlias + '.';\n\t\t\t\t\ttmp += p.name;\n\n\t\t\t\t\targs.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn args.join(', ');\n\t\t}\n\t}]);\n\treturn Projection;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Projection.js\n// module id = 134\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Projection.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Union = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Table = __webpack_require__(102);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * This is the Union operation\n * The two child expression must have a union compatible schema.\n * The schema of the left child is used as the output schema.\n *\n * Union is done by concatenating the two results (left||right)\n *\n * @constructor\n * @extends RANode\n * @param   {RANode} child  left child expression\n * @param   {RANode} child2 right child expression\n * @returns {Union}\n */\nvar Union = exports.Union = function (_RANode) {\n\t(0, _inherits3.default)(Union, _RANode);\n\n\tfunction Union(child, child2) {\n\t\t(0, _classCallCheck3.default)(this, Union);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (Union.__proto__ || (0, _getPrototypeOf2.default)(Union)).call(this, '∪'));\n\n\t\t_this.setChild(child);\n\t\t_this.setChild2(child2);\n\n\t\t_this._schema = null; // is set by check\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(Union, [{\n\t\tkey: 'setChild2',\n\t\tvalue: function setChild2(child2) {\n\t\t\tthis._child2 = child2;\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._schema;\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar res = new _Table.Table();\n\t\t\tvar orgA = this.getChild().getResult(session);\n\t\t\tvar orgB = this.getChild2().getResult(session);\n\t\t\tres.setSchema(this._schema);\n\n\t\t\t// copy\n\t\t\tres.addRows(orgA.getRows());\n\t\t\tres.addRows(orgB.getRows());\n\n\t\t\tres.eliminateDuplicateRows();\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\t\t\tthis._child2.check();\n\n\t\t\tif (this._child.getSchema().equalsTypeOnly(this._child2.getSchema()) == false) {\n\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-schemas-not-unifiable', {\n\t\t\t\t\tschemaA: this._child.getSchema(),\n\t\t\t\t\tschemaB: this._child2.getSchema()\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// schema of union is the left schema\n\t\t\tthis._schema = this._child.getSchema().copy();\n\t\t}\n\t}]);\n\treturn Union;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Union.js\n// module id = 135\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Union.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Intersect = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Table = __webpack_require__(102);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Calculates the intersection of two relations\n * The order of the rows is kept.\n * The output schema will be the schema of the left child\n *\n * @constructor\n * @extends RANode\n * @param   {RANode} child  the left child expression\n * @param   {RANode} child2 the right child expression\n * @returns {Intersect}\n */\nvar Intersect = exports.Intersect = function (_RANode) {\n\t(0, _inherits3.default)(Intersect, _RANode);\n\n\tfunction Intersect(child, child2) {\n\t\t(0, _classCallCheck3.default)(this, Intersect);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (Intersect.__proto__ || (0, _getPrototypeOf2.default)(Intersect)).call(this, '∩'));\n\n\t\t_this.setChild(child);\n\t\t_this.setChild2(child2);\n\n\t\t_this._schema = null; // is set by check\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(Intersect, [{\n\t\tkey: 'setChild2',\n\t\tvalue: function setChild2(child2) {\n\t\t\tthis._child2 = child2;\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._schema;\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar res = new _Table.Table();\n\t\t\tvar orgA = this.getChild().getResult(session);\n\t\t\tvar orgB = this.getChild2().getResult(session);\n\t\t\tres.setSchema(this._schema);\n\n\t\t\t// copy\n\t\t\tvar numRowsA = orgA.getNumRows();\n\t\t\tvar numRowsB = orgB.getNumRows();\n\t\t\tvar numCols = orgA.getNumCols();\n\t\t\tfor (var i = 0; i < numRowsA; i++) {\n\t\t\t\tvar rowA = orgA.getRow(i);\n\t\t\t\tfor (var j = 0; j < numRowsB; j++) {\n\t\t\t\t\tvar rowB = orgB.getRow(j);\n\t\t\t\t\tvar equals = true;\n\n\t\t\t\t\tfor (var k = 0; k < numCols; k++) {\n\t\t\t\t\t\tif (rowA[k] !== rowB[k]) {\n\t\t\t\t\t\t\tequals = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (equals) {\n\t\t\t\t\t\tres.addRow(rowA);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\t\t\tthis._child2.check();\n\n\t\t\tif (this._child.getSchema().equalsTypeOnly(this._child2.getSchema()) == false) {\n\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-schemas-not-unifiable', {\n\t\t\t\t\tschemaA: this._child.getSchema(),\n\t\t\t\t\tschemaB: this._child2.getSchema()\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// schema is the left schema\n\t\t\tthis._schema = this._child.getSchema().copy();\n\t\t}\n\t}]);\n\treturn Intersect;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Intersect.js\n// module id = 136\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Intersect.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Division = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Difference = __webpack_require__(138);\n\nvar _Projection = __webpack_require__(134);\n\nvar _CrossJoin = __webpack_require__(139);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra division operator\n *\n * @constructor\n * @extends RANode\n * @param   {RANode} child  the left child expression\n * @param   {RANode} child2 the right child expression\n * @returns {Division}\n */\nvar Division = exports.Division = function (_RANode) {\n\t(0, _inherits3.default)(Division, _RANode);\n\n\tfunction Division(child, child2) {\n\t\t(0, _classCallCheck3.default)(this, Division);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (Division.__proto__ || (0, _getPrototypeOf2.default)(Division)).call(this, '÷'));\n\n\t\t_this.setChild(child);\n\t\t_this.setChild2(child2);\n\n\t\t// is set by check\n\t\t_this._delegate = null;\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(Division, [{\n\t\tkey: 'setChild2',\n\t\tvalue: function setChild2(child2) {\n\t\t\tthis._child2 = child2;\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._delegate.getSchema();\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar res = this._delegate.getResult(session);\n\n\t\t\tres.eliminateDuplicateRows();\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\t\t\tthis._child2.check();\n\n\t\t\t// schema r' is (sch(left) \\ sch(right))\n\t\t\tvar schemaA = this._child.getSchema();\n\t\t\tvar schemaB = this._child2.getSchema();\n\t\t\tvar numColsA = schemaA.getSize();\n\t\t\tvar numColsB = schemaB.getSize();\n\n\t\t\tvar schema = schemaA.copy();\n\t\t\tfor (var i = 0; i < numColsB; i++) {\n\t\t\t\tvar index = schema.getColumnIndex(schemaB.getColumn(i).getName(), null, false);\n\t\t\t\tif (index > -1) schema.removeColumn(index);\n\t\t\t}\n\n\t\t\tif (schema.getSize() === numColsA) {\n\t\t\t\t// size has not changed => schemaB not part of schemaA\n\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-schema-a-not-part-of-schema-b', {\n\t\t\t\t\tschemaA: schemaB,\n\t\t\t\t\tschemaB: schemaA\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// (R % S) := (pi r'(R)) - ( ( (pi r'(R) x (S) )) - (R) )\n\t\t\tthis._delegate = new _Difference.Difference(new _Projection.Projection(this._child, schema.getColumns()).setCodeInfoObject(this._codeInfo), new _Projection.Projection(new _Difference.Difference(new _CrossJoin.CrossJoin(new _Projection.Projection(this._child, schema.getColumns()).setCodeInfoObject(this._codeInfo), this._child2).setCodeInfoObject(this._codeInfo), this._child).setCodeInfoObject(this._codeInfo), schema.getColumns()).setCodeInfoObject(this._codeInfo));\n\t\t\tthis._delegate.check();\n\t\t}\n\t}]);\n\treturn Division;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Division.js\n// module id = 137\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Division.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Difference = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Table = __webpack_require__(102);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra difference operator\n *\n * @constructor\n * @extends RANode\n * @param   {RANode} child  the left child expression\n * @param   {RANode} child2 the right child expression\n * @returns {Difference}\n */\nvar Difference = exports.Difference = function (_RANode) {\n\t(0, _inherits3.default)(Difference, _RANode);\n\n\tfunction Difference(child, child2) {\n\t\t(0, _classCallCheck3.default)(this, Difference);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (Difference.__proto__ || (0, _getPrototypeOf2.default)(Difference)).call(this, '-'));\n\n\t\t_this.setChild(child);\n\t\t_this.setChild2(child2);\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(Difference, [{\n\t\tkey: 'setChild2',\n\t\tvalue: function setChild2(child2) {\n\t\t\tthis._child2 = child2;\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._child.getSchema();\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar res = new _Table.Table();\n\t\t\tvar orgA = this.getChild().getResult(session);\n\t\t\tvar orgB = this.getChild2().getResult(session);\n\t\t\tres.setSchema(this._schema);\n\n\t\t\t// copy\n\t\t\tfor (var i = 0; i < orgA.getNumRows(); i++) {\n\t\t\t\tvar rowA = orgA.getRow(i);\n\t\t\t\tvar notFound = true;\n\t\t\t\tfor (var j = 0; j < orgB.getNumRows(); j++) {\n\t\t\t\t\tif (_Table.Table.rowEqualsRow(rowA, orgB.getRow(j))) {\n\t\t\t\t\t\tnotFound = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (notFound) res.addRow(rowA);\n\t\t\t}\n\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\t\t\tthis._child2.check();\n\n\t\t\tif (this._child.getSchema().equalsTypeOnly(this._child2.getSchema()) == false) {\n\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-schemas-not-unifiable', {\n\t\t\t\t\tschemaA: this._child.getSchema(),\n\t\t\t\t\tschemaB: this._child2.getSchema()\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// schema of union is the left schema\n\t\t\tthis._schema = this._child.getSchema().copy();\n\t\t}\n\t}]);\n\treturn Difference;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Difference.js\n// module id = 138\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Difference.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CrossJoin = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _Join2 = __webpack_require__(140);\n\nvar _ValueExpr = __webpack_require__(46);\n\nvar ValueExpr = _interopRequireWildcard(_ValueExpr);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra inner Join operator\n *\n * this is just a wrapper for {@link Join} with true as condition\n *\n * @extends RANode\n * @constructor\n * @param   {RANode}               child     the left child expression\n * @param   {RANode}               child2    the right child expression\n * @returns {CrossJoin}\n */\nvar CrossJoin = exports.CrossJoin = function (_Join) {\n  (0, _inherits3.default)(CrossJoin, _Join);\n\n  function CrossJoin(child, child2) {\n    (0, _classCallCheck3.default)(this, CrossJoin);\n    return (0, _possibleConstructorReturn3.default)(this, (CrossJoin.__proto__ || (0, _getPrototypeOf2.default)(CrossJoin)).call(this, child, child2, new ValueExpr.ValueExprGeneric('boolean', 'constant', [true]), 'inner', '⨯'));\n  }\n\n  (0, _createClass3.default)(CrossJoin, [{\n    key: 'getArgumentHtml',\n    value: function getArgumentHtml() {\n      return '';\n    }\n  }]);\n  return CrossJoin;\n}(_Join2.Join);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/CrossJoin.js\n// module id = 139\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/CrossJoin.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Join = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Table = __webpack_require__(102);\n\nvar _Schema = __webpack_require__(101);\n\nvar _ValueExpr = __webpack_require__(46);\n\nvar ValueExpr = _interopRequireWildcard(_ValueExpr);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra Join operator\n *\n * @extends RANode\n * @constructor\n * @param   {RANode}               child     the left child expression\n * @param   {RANode}               child2    the right child expression\n * @param   {null|ValueExpr|Array} condition condition is either a ValueExpr evaluating to boolean\n *                                         or an Array of unqualified column names as strings for the using clause or\n *                                         null for a natural join\n * @param   {String}               joinType  joinType is either inner, left or right\n * @returns {Join}\n */\nvar Join = exports.Join = function (_RANode) {\n\t(0, _inherits3.default)(Join, _RANode);\n\n\tfunction Join(child, child2, condition, joinType, functionNameOverride) {\n\t\t(0, _classCallCheck3.default)(this, Join);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (Join.__proto__ || (0, _getPrototypeOf2.default)(Join)).call(this, functionNameOverride || '⨝'));\n\n\t\t_this._condition = condition;\n\t\tif (joinType !== 'inner' && joinType !== 'left' && joinType !== 'right') throw new Error('unknown joinType: ' + joinType);\n\n\t\t_this._joinType = joinType;\n\t\t_this._isNaturalJoin = condition === null || condition instanceof Array;\n\n\t\t// this is used for the USING() clause for SQL where the natural join is restricted to some columns\n\t\tif (condition instanceof Array) {\n\t\t\tif (condition.length === 0) throw 'this should not happen array has to have at least one element';\n\n\t\t\t_this._restrictToColumns = condition;\n\t\t} else {\n\t\t\t_this._restrictToColumns = false;\n\t\t}\n\n\t\t_this.setChild(child);\n\t\t_this.setChild2(child2);\n\t\tif (_this._isNaturalJoin === false && condition instanceof ValueExpr.ValueExpr === false) throw new Error('no condition given');\n\n\t\t_this._schema = null;\n\t\t_this._keepColumns = null;\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(Join, [{\n\t\tkey: 'setChild2',\n\t\tvalue: function setChild2(child2) {\n\t\t\tthis._child2 = child2;\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._schema;\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar createNullArray = function createNullArray(size) {\n\t\t\t\tvar a = new Array(size);\n\t\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\t\ta[i] = null;\n\t\t\t\t}return a;\n\t\t\t};\n\t\t\tvar createNaturalRowArray = function createNaturalRowArray(rowA, rowB, keepIndicesA, keepIndicesB) {\n\t\t\t\tvar row = new Array(rowSize);\n\t\t\t\tvar col = 0;\n\t\t\t\tfor (var k = 0; k < keepIndicesA.length; k++) {\n\t\t\t\t\trow[col++] = rowA[keepIndicesA[k]];\n\t\t\t\t}\n\t\t\t\tfor (var _k = 0; _k < keepIndicesB.length; _k++) {\n\t\t\t\t\trow[col++] = rowB[keepIndicesB[_k]];\n\t\t\t\t}\n\t\t\t\treturn row;\n\t\t\t};\n\n\t\t\tvar res = new _Table.Table();\n\t\t\tres.setSchema(this.getSchema());\n\n\t\t\tvar orgA = this._child.getResult(session);\n\t\t\tvar orgB = this._child2.getResult(session);\n\n\t\t\tvar condition = this._condition;\n\n\t\t\t// nested loop join\n\t\t\tvar numRowsA = orgA.getNumRows();\n\t\t\tvar numRowsB = orgB.getNumRows();\n\t\t\tvar numColsA = orgA.getNumCols();\n\t\t\tvar numColsB = orgB.getNumCols();\n\t\t\tvar isNaturalJoin = this._isNaturalJoin;\n\n\t\t\tvar rowSize, keepIndicesA, keepIndicesB;\n\t\t\tif (isNaturalJoin) {\n\t\t\t\trowSize = this._keepColumns.size;\n\t\t\t\tkeepIndicesA = this._keepColumns.keepIndicesA;\n\t\t\t\tkeepIndicesB = this._keepColumns.keepIndicesB;\n\t\t\t}\n\n\t\t\tvar nullArrayLeft, nullArrayRight;\n\n\t\t\tvar row;\n\t\t\tif (this._joinType === 'inner') {\n\t\t\t\tfor (var i = 0; i < numRowsA; i++) {\n\t\t\t\t\tvar rowA = orgA.getRow(i);\n\n\t\t\t\t\tfor (var j = 0; j < numRowsB; j++) {\n\t\t\t\t\t\tvar rowB = orgB.getRow(j);\n\n\t\t\t\t\t\tif (condition.evaluate(rowA, rowB, i, session) !== true) continue;\n\n\t\t\t\t\t\t// add row\n\t\t\t\t\t\tif (!isNaturalJoin) row = rowA.concat(rowB);else {\n\t\t\t\t\t\t\trow = createNaturalRowArray(rowA, rowB, keepIndicesA, keepIndicesB);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tres.addRow(row);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (this._joinType === 'left') {\n\t\t\t\tnullArrayRight = createNullArray(this.getSchema().getSize() - numColsA); // == size of new B\n\n\t\t\t\tfor (var _i = 0; _i < numRowsA; _i++) {\n\t\t\t\t\tvar _rowA = orgA.getRow(_i);\n\t\t\t\t\tvar match = false;\n\n\t\t\t\t\tfor (var _j = 0; _j < numRowsB; _j++) {\n\t\t\t\t\t\tvar _rowB = orgB.getRow(_j);\n\n\t\t\t\t\t\tif (condition.evaluate(_rowA, _rowB, _i, session) === true) {\n\t\t\t\t\t\t\tif (!isNaturalJoin) res.addRow(_rowA.concat(_rowB));else {\n\t\t\t\t\t\t\t\tres.addRow(createNaturalRowArray(_rowA, _rowB, keepIndicesA, keepIndicesB));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (match === false) {\n\t\t\t\t\t\tres.addRow(_rowA.concat(nullArrayRight));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (this._joinType === 'right') {\n\t\t\t\tnullArrayLeft = createNullArray(this.getSchema().getSize() - numColsB); // == size of new A\n\n\t\t\t\tfor (var _j2 = 0; _j2 < numRowsB; _j2++) {\n\t\t\t\t\tvar _rowB2 = orgB.getRow(_j2);\n\t\t\t\t\tvar _match = false;\n\n\t\t\t\t\tfor (var _i2 = 0; _i2 < numRowsA; _i2++) {\n\t\t\t\t\t\tvar _rowA2 = orgA.getRow(_i2);\n\n\t\t\t\t\t\tif (condition.evaluate(_rowA2, _rowB2, _i2, session) === true) {\n\t\t\t\t\t\t\tif (!isNaturalJoin) res.addRow(_rowA2.concat(_rowB2));else {\n\t\t\t\t\t\t\t\tres.addRow(createNaturalRowArray(_rowA2, _rowB2, keepIndicesA, keepIndicesB));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_match = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_match == false) {\n\t\t\t\t\t\tres.addRow(nullArrayLeft.concat(_rowB2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres.eliminateDuplicateRows();\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\t\t\tthis._child2.check();\n\t\t\tvar schemaA = this._child.getSchema();\n\t\t\tvar schemaB = this._child2.getSchema();\n\n\t\t\tif (this._isNaturalJoin) {\n\t\t\t\t// check if columns of using clause appear in both schemas\n\t\t\t\tif (this._restrictToColumns !== false) {\n\t\t\t\t\tfor (var i = 0; i < this._restrictToColumns.length; i++) {\n\t\t\t\t\t\tif (schemaA.getColumnIndexArray(this._restrictToColumns[i], null).length === 0 || schemaB.getColumnIndexArray(this._restrictToColumns[i], null).length === 0) {\n\t\t\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-column-not-in-both-schemas', { column: this._restrictToColumns[i] }));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// generate natural condition\n\t\t\t\tthis._condition = Join.getNaturalJoinCondition(schemaA, schemaB, this._restrictToColumns);\n\t\t\t\tthis.setMetaData('naturalJoinConditions', Join.getNaturalJoinConditionArray(schemaA, schemaB, this._restrictToColumns));\n\n\t\t\t\tvar tmp = _Schema.Schema.concatNatural(schemaA, schemaB, this._joinType !== 'right', this._restrictToColumns);\n\t\t\t\tthis._schema = tmp.schema;\n\t\t\t\tthis._keepColumns = tmp.keep;\n\t\t\t} else {\n\t\t\t\t// check columns appearing in both schemas\n\t\t\t\tvar conflicts = schemaA.getConflictingColumnsArray(schemaB);\n\t\t\t\tif (conflicts.length > 0) {\n\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-join-would-produce-non-unique-columns', { conflicts: conflicts.join(', ') }));\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tthis._schema = _Schema.Schema.concat(this._child.getSchema(), this._child2.getSchema());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.throwExecutionError(e.message);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._condition.check(schemaA, schemaB);\n\t\t\tif (this._condition.getDataType() !== 'boolean') {\n\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-condition-must-be-boolean'));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'getArgumentHtml',\n\t\tvalue: function getArgumentHtml() {\n\t\t\tif (this._isNaturalJoin) return '';\n\t\t\treturn this._condition.getFormulaHtml();\n\t\t}\n\t}], [{\n\t\tkey: 'getNaturalJoinConditionArray',\n\t\tvalue: function getNaturalJoinConditionArray(schemaA, schemaB, restrictToColumns) {\n\t\t\tif (typeof restrictToColumns === 'undefined') {\n\t\t\t\trestrictToColumns = false;\n\t\t\t}\n\t\t\tvar numColsA = schemaA.getSize();\n\n\t\t\tvar conditions = [];\n\n\t\t\t// find columns with the same name in schemaA and schemaB\n\t\t\tfor (var i = 0; i < numColsA; i++) {\n\t\t\t\tvar a = schemaA.getColumn(i);\n\t\t\t\tif (restrictToColumns !== false && restrictToColumns.indexOf(a.getName()) === -1) {\n\t\t\t\t\t// skip all but certain columns (for joins with USING())\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar indices = schemaB.getColumnIndexArray(a.getName(), null, false);\n\t\t\t\tif (indices.length === 0) continue;\n\n\t\t\t\tfor (var j = 0; j < indices.length; j++) {\n\t\t\t\t\tvar index = indices[j];\n\n\t\t\t\t\tvar b = schemaB.getColumn(index);\n\n\t\t\t\t\t// the column indices are set manually\n\t\t\t\t\tvar equals = new ValueExpr.ValueExprGeneric('boolean', '=', [new ValueExpr.ValueExprColumnValue(a.getName(), a.getRelAlias(), i), new ValueExpr.ValueExprColumnValue(b.getName(), b.getRelAlias(), numColsA + index)]);\n\t\t\t\t\tconditions.push(equals);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn conditions;\n\t\t}\n\t}, {\n\t\tkey: 'getNaturalJoinCondition',\n\t\tvalue: function getNaturalJoinCondition(schemaA, schemaB, restrictToColumns) {\n\t\t\tvar conditions = Join.getNaturalJoinConditionArray(schemaA, schemaB, restrictToColumns);\n\t\t\tvar length = conditions.length;\n\t\t\tswitch (length) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn new ValueExpr.ValueExprGeneric('boolean', 'constant', [true]);\n\n\t\t\t\tcase 1:\n\t\t\t\t\treturn conditions[0];\n\n\t\t\t\tdefault:\n\t\t\t\t\tvar cond = new ValueExpr.ValueExprGeneric('boolean', 'and', [conditions[0], conditions[1]]);\n\t\t\t\t\tfor (var i = 2; i < length; i++) {\n\t\t\t\t\t\tcond = new ValueExpr.ValueExprGeneric('boolean', 'and', [cond, conditions[i]]);\n\t\t\t\t\t}\n\t\t\t\t\treturn cond;\n\t\t\t}\n\t\t}\n\t}]);\n\treturn Join;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Join.js\n// module id = 140\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Join.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Selection = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Table = __webpack_require__(102);\n\nvar _ValueExpr = __webpack_require__(46);\n\nvar ValueExpr = _interopRequireWildcard(_ValueExpr);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Selection = exports.Selection = function (_RANode) {\n\t(0, _inherits3.default)(Selection, _RANode);\n\n\tfunction Selection(child, condition) {\n\t\t(0, _classCallCheck3.default)(this, Selection);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (Selection.__proto__ || (0, _getPrototypeOf2.default)(Selection)).call(this, '&sigma;'));\n\n\t\t_this._condition = condition;\n\n\t\t_this.setChild(child);\n\t\tif (condition instanceof ValueExpr.ValueExpr == false) throw new Error('no condition given');\n\n\t\t_this._schema = null;\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(Selection, [{\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._schema;\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar res = new _Table.Table();\n\t\t\tvar org = this.getChild().getResult(session);\n\t\t\tres.setSchema(org.getSchema());\n\n\t\t\t// copy\n\t\t\tvar condition = this._condition;\n\t\t\tvar numRows = org.getNumRows();\n\t\t\tfor (var i = 0; i < numRows; i++) {\n\t\t\t\tvar row = org.getRow(i);\n\n\t\t\t\tif (condition.evaluate(row, null, i, session) === true) res.addRow(row);\n\t\t\t}\n\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\n\t\t\t// schema of union is the left schema\n\t\t\tthis._schema = this._child.getSchema();\n\n\t\t\tthis._condition.check(this._schema);\n\t\t\tif (this._condition.getDataType() !== 'boolean') {\n\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-condition-must-be-boolean'));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'getArgumentHtml',\n\t\tvalue: function getArgumentHtml() {\n\t\t\treturn this._condition.getFormulaHtml();\n\t\t}\n\t}]);\n\treturn Selection;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/Selection.js\n// module id = 141\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/Selection.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.GroupBy = undefined;\n\nvar _stringify = __webpack_require__(108);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Table = __webpack_require__(102);\n\nvar _Schema = __webpack_require__(101);\n\nvar _Column = __webpack_require__(100);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra group-by operator\n *\n * @extends RANode\n * @constructor\n * @param   {RANode}  child              the child expression\n * @param   {Array}   groupByCols        Array of {name, relalias} objects\n * @param   {Array}   aggregateFunctions Array of {aggFunction, col{name, relAlias}} objects\n * @returns {GroupBy}\n */\nvar GroupBy = exports.GroupBy = function (_RANode) {\n\t(0, _inherits3.default)(GroupBy, _RANode);\n\n\tfunction GroupBy(child, groupByCols, aggregateFunctions) {\n\t\t(0, _classCallCheck3.default)(this, GroupBy);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (GroupBy.__proto__ || (0, _getPrototypeOf2.default)(GroupBy)).call(this, '&gamma;'));\n\n\t\t_this.setChild(child);\n\n\t\t_this._groupByCols = groupByCols;\n\t\t_this._aggregateFunctions = aggregateFunctions;\n\n\t\t_this._schema = null;\n\t\t_this._groupByColumnIndices = null;\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(GroupBy, [{\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._schema;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\t\t\tvar childSchema = this._child.getSchema();\n\n\t\t\tthis._groupByColumnIndices = new Array(this._groupByCols.length);\n\n\t\t\tfor (var i = 0; i < this._groupByCols.length; i++) {\n\t\t\t\tthis._groupByColumnIndices[i] = childSchema.getColumnIndex(this._groupByCols[i].name, this._groupByCols[i].relAlias);\n\t\t\t}\n\n\t\t\tfor (var _i = 0; _i < this._aggregateFunctions.length; _i++) {\n\t\t\t\tvar f = this._aggregateFunctions[_i];\n\n\t\t\t\tswitch (f.aggFunction) {\n\t\t\t\t\tcase 'COUNT_ALL':\n\t\t\t\t\tcase 'COUNT':\n\t\t\t\t\tcase 'SUM':\n\t\t\t\t\tcase 'AVG':\n\t\t\t\t\tcase 'MIN':\n\t\t\t\t\tcase 'MAX':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('should not happen; unknown aggregate function');\n\t\t\t\t}\n\n\t\t\t\tif (f.aggFunction != 'COUNT_ALL') this._aggregateFunctions[_i].colIndex = childSchema.getColumnIndex(f.col.name, f.col.relAlias);\n\t\t\t}\n\n\t\t\t// create new Schema\n\t\t\tthis._schema = new _Schema.Schema();\n\t\t\tfor (var _i2 = 0; _i2 < this._groupByColumnIndices.length; _i2++) {\n\t\t\t\tthis._schema.addColumn2(childSchema.getColumn(this._groupByColumnIndices[_i2]));\n\t\t\t}\n\t\t\tfor (var _i3 = 0; _i3 < this._aggregateFunctions.length; _i3++) {\n\t\t\t\tvar func = this._aggregateFunctions[_i3];\n\t\t\t\tvar type;\n\t\t\t\tvar colType = childSchema.getType(func.colIndex);\n\n\t\t\t\tswitch (func.aggFunction) {\n\t\t\t\t\tcase 'MIN':\n\t\t\t\t\tcase 'MAX':\n\t\t\t\t\t\ttype = colType;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'SUM':\n\t\t\t\t\tcase 'AVG':\n\t\t\t\t\t\tif (colType !== 'number') this.throwExecutionError(i18n.t('db.messages.exec.error-func-not-defined-for-column-type', {\n\t\t\t\t\t\t\tfunc: func.aggFunction,\n\t\t\t\t\t\t\tcolType: colType\n\t\t\t\t\t\t}));\n\t\t\t\t\t\ttype = colType;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'COUNT_ALL':\n\t\t\t\t\tcase 'COUNT':\n\t\t\t\t\t\ttype = 'number';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('unknown aggregate function ' + func.aggFunction);\n\t\t\t\t}\n\t\t\t\tthis._schema.addColumn(func.name, null, type);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'getArgumentHtml',\n\t\tvalue: function getArgumentHtml() {\n\t\t\tvar group = [];\n\t\t\tvar agg = [];\n\t\t\tvar i;\n\n\t\t\tfor (i = 0; i < this._groupByCols.length; i++) {\n\t\t\t\tgroup.push(_Column.Column.printColumn(this._groupByCols[i].name, this._groupByCols[i].relAlias));\n\t\t\t}\n\t\t\tfor (i = 0; i < this._aggregateFunctions.length; i++) {\n\t\t\t\tvar func = this._aggregateFunctions[i];\n\t\t\t\tvar s;\n\t\t\t\tif (func.aggFunction == 'COUNT_ALL') s = 'COUNT(*)';else s = func.aggFunction + '(' + _Column.Column.printColumn(func.col.name, func.col.relAlias) + ')';\n\n\t\t\t\ts += '→' + func.name;\n\t\t\t\tagg.push(s);\n\t\t\t}\n\n\t\t\treturn group.join(', ') + '; ' + agg.join(', ');\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar org = this.getChild().getResult(session);\n\t\t\tvar res = new _Table.Table();\n\t\t\tres.setSchema(this._schema);\n\n\t\t\tvar hasGroupCols = this._groupByCols.length > 0;\n\t\t\tvar groupsOfRows; // might be sparcely filled\n\t\t\tvar numberOfGroups = 0; // === number of rows in result table\n\n\t\t\tif (hasGroupCols) {\n\t\t\t\tvar hashtable = {};\n\t\t\t\tfor (var i = 0; i < org.getNumRows(); i++) {\n\t\t\t\t\tvar row = org.getRow(i);\n\t\t\t\t\tvar keyTuple = new Array(this._groupByColumnIndices.length);\n\n\t\t\t\t\tfor (var j = 0; j < this._groupByColumnIndices.length; j++) {\n\t\t\t\t\t\tkeyTuple[j] = row[this._groupByColumnIndices[j]];\n\t\t\t\t\t}\n\n\t\t\t\t\tvar key = (0, _stringify2.default)(keyTuple);\n\t\t\t\t\tif (typeof hashtable[key] != 'undefined') {\n\t\t\t\t\t\thashtable[key].rows.push(row);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thashtable[key] = {\n\t\t\t\t\t\t\trows: [row],\n\t\t\t\t\t\t\tresultTuple: keyTuple,\n\t\t\t\t\t\t\trownumber: i\n\t\t\t\t\t\t};\n\t\t\t\t\t\tnumberOfGroups++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgroupsOfRows = new Array(org.getNumRows()); // sparcely filled\n\n\t\t\t\t// write hashtable into sparcely filled array to preserve ordering\n\t\t\t\tvar _entry = void 0;\n\t\t\t\tfor (var _key in hashtable) {\n\t\t\t\t\tif (!hashtable.hasOwnProperty(_key)) continue;\n\n\t\t\t\t\t_entry = hashtable[_key];\n\t\t\t\t\tgroupsOfRows[_entry.rownumber] = _entry;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// no grouping attributes => entire relation is one group\n\t\t\t\tnumberOfGroups = 1;\n\t\t\t\tgroupsOfRows = new Array(numberOfGroups);\n\n\t\t\t\tgroupsOfRows[0] = {\n\t\t\t\t\trows: org.getRows(),\n\t\t\t\t\tresultTuple: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// min and max for strings, numbers and dates\n\t\t\tvar generic_min = function generic_min(a, b) {\n\t\t\t\tif (a < b) return a;\n\t\t\t\treturn b;\n\t\t\t};\n\t\t\tvar generic_max = function generic_max(a, b) {\n\t\t\t\tif (a > b) return a;\n\t\t\t\treturn b;\n\t\t\t};\n\n\t\t\t// execute aggregate functions\n\t\t\tvar aggValue, group, value;\n\t\t\tvar entry = void 0;\n\t\t\tfor (var h = 0; h < groupsOfRows.length; h++) {\n\t\t\t\tif (!groupsOfRows[h]) continue; // skipp unfilled rows\n\n\t\t\t\tentry = groupsOfRows[h];\n\t\t\t\tgroup = entry.rows;\n\n\t\t\t\tfor (var _i4 = 0; _i4 < this._aggregateFunctions.length; _i4++) {\n\t\t\t\t\tvar func = this._aggregateFunctions[_i4];\n\n\t\t\t\t\tif (func.aggFunction == 'COUNT_ALL') {\n\t\t\t\t\t\taggValue = group.length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//var colType = this._child.getSchema().getType(func.colIndex);\n\t\t\t\t\t\tswitch (func.aggFunction) {\n\t\t\t\t\t\t\tcase 'COUNT':\n\t\t\t\t\t\t\t\taggValue = 0;\n\n\t\t\t\t\t\t\t\tfor (var _j = 0; _j < group.length; _j++) {\n\t\t\t\t\t\t\t\t\tvalue = group[_j][func.colIndex];\n\t\t\t\t\t\t\t\t\tif (value !== null) aggValue++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'MIN':\n\t\t\t\t\t\t\tcase 'MAX':\n\t\t\t\t\t\t\t\taggValue = null;\n\t\t\t\t\t\t\t\tvar c = func.aggFunction == 'MIN' ? generic_min : generic_max;\n\n\t\t\t\t\t\t\t\tfor (var _j2 = 0; _j2 < group.length; _j2++) {\n\t\t\t\t\t\t\t\t\tvalue = group[_j2][func.colIndex];\n\t\t\t\t\t\t\t\t\tif (aggValue === null) aggValue = value;else aggValue = c(aggValue, value);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'AVG':\n\t\t\t\t\t\t\tcase 'SUM':\n\t\t\t\t\t\t\t\tvar sum = 0;\n\t\t\t\t\t\t\t\tvar counter = 0;\n\n\t\t\t\t\t\t\t\tfor (var _j3 = 0; _j3 < group.length; _j3++) {\n\t\t\t\t\t\t\t\t\tvalue = group[_j3][func.colIndex];\n\t\t\t\t\t\t\t\t\tif (value !== null) {\n\t\t\t\t\t\t\t\t\t\tsum += value;\n\t\t\t\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (counter === 0) {\n\t\t\t\t\t\t\t\t\taggValue = null;\n\t\t\t\t\t\t\t\t} else if (func.aggFunction == 'SUM') {\n\t\t\t\t\t\t\t\t\taggValue = sum;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t//AVG\n\t\t\t\t\t\t\t\t\taggValue = sum / counter;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow new Error('this should not happen');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tentry.resultTuple.push(aggValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// write into result-table\n\t\t\tfor (var _i5 = 0; _i5 < groupsOfRows.length; _i5++) {\n\t\t\t\tif (!groupsOfRows[_i5]) continue;\n\t\t\t\tres.addRow(groupsOfRows[_i5].resultTuple);\n\t\t\t}\n\n\t\t\tres.eliminateDuplicateRows();\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}]);\n\treturn GroupBy;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/GroupBy.js\n// module id = 142\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/GroupBy.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.OrderBy = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra order-by operator\n *\n * @constructor\n * @extends RANode\n * @param   {RANode}  child     child expression\n * @param   {Array}   orderCols Array of Column\n * @param   {Array}   orderAsc  Array of Boolean indicating the sort direction (true == asc)\n * @returns {OrderBy}\n */\nvar OrderBy = exports.OrderBy = function (_RANode) {\n\t(0, _inherits3.default)(OrderBy, _RANode);\n\n\tfunction OrderBy(child, orderCols, orderAsc) {\n\t\t(0, _classCallCheck3.default)(this, OrderBy);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (OrderBy.__proto__ || (0, _getPrototypeOf2.default)(OrderBy)).call(this, '&tau;'));\n\n\t\t_this.setChild(child);\n\n\t\t_this._orderCols = orderCols;\n\t\t_this._orderAsc = orderAsc;\n\n\t\tif (_this._orderAsc.length != _this._orderCols.length) throw new Error('order cols not correct');\n\n\t\t_this._orderIndices = null;\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(OrderBy, [{\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._child.getSchema();\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar res = this.getChild().getResult(session).copy();\n\t\t\tres.eliminateDuplicateRows();\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\n\t\t\tres.sort(this._orderIndices, this._orderAsc);\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\t\t\tvar schema = this._child.getSchema();\n\n\t\t\tthis._orderIndices = [];\n\n\t\t\tfor (var i = 0; i < this._orderCols.length; i++) {\n\t\t\t\tvar col = this._orderCols[i];\n\t\t\t\tvar index = schema.getColumnIndex(col.getName(), col.getRelAlias());\n\n\t\t\t\tthis._orderIndices.push(index);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'getArgumentHtml',\n\t\tvalue: function getArgumentHtml() {\n\t\t\tvar list = [];\n\n\t\t\tfor (var i = 0; i < this._orderCols.length; i++) {\n\t\t\t\tvar s = this._orderCols[i].toString() + ' ' + (this._orderAsc[i] ? 'asc' : 'desc');\n\t\t\t\tlist.push(s);\n\t\t\t}\n\t\t\treturn list.join(', ');\n\t\t}\n\t}]);\n\treturn OrderBy;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/OrderBy.js\n// module id = 143\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/OrderBy.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InnerJoin = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Join = __webpack_require__(140);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra inner Join operator\n *\n * this is just a wrapper for {@link Join}\n *\n * @extends RANode\n * @constructor\n * @param   {RANode}               child     the left child expression\n * @param   {RANode}               child2    the right child expression\n * @param   {null|ValueExpr|Array} condition see condition of {@link Join}\n * @returns {InnerJoin}\n */\nvar InnerJoin = exports.InnerJoin = function (_RANode) {\n  (0, _inherits3.default)(InnerJoin, _RANode);\n\n  function InnerJoin(child, child2, condition) {\n    var _ret;\n\n    (0, _classCallCheck3.default)(this, InnerJoin);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (InnerJoin.__proto__ || (0, _getPrototypeOf2.default)(InnerJoin)).call(this, '⨝'));\n\n    return _ret = new _Join.Join(child, child2, condition, 'inner', _this._functionName), (0, _possibleConstructorReturn3.default)(_this, _ret);\n  }\n\n  return InnerJoin;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/InnerJoin.js\n// module id = 144\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/InnerJoin.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LeftOuterJoin = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _Join2 = __webpack_require__(140);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra left outer Join operator\n *\n * this is just a wrapper for {@link Join}\n *\n * @extends RANode\n * @constructor\n * @param   {RANode}               child     the left child expression\n * @param   {RANode}               child2    the right child expression\n * @param   {null|ValueExpr|Array} condition see condition of {@link Join}\n * @returns {LeftOuterJoin}\n */\nvar LeftOuterJoin = exports.LeftOuterJoin = function (_Join) {\n  (0, _inherits3.default)(LeftOuterJoin, _Join);\n\n  function LeftOuterJoin(child, child2, condition) {\n    (0, _classCallCheck3.default)(this, LeftOuterJoin);\n    return (0, _possibleConstructorReturn3.default)(this, (LeftOuterJoin.__proto__ || (0, _getPrototypeOf2.default)(LeftOuterJoin)).call(this, child, child2, condition, 'left', '⟕'));\n  }\n\n  return LeftOuterJoin;\n}(_Join2.Join);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/LeftOuterJoin.js\n// module id = 145\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/LeftOuterJoin.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RightOuterJoin = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _Join2 = __webpack_require__(140);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra right outer Join operator\n *\n * this is just a wrapper for {@link Join}\n * @param   {RANode}               child     the left child expression\n * @param   {RANode}               child2    the right child expression\n * @param   {null|ValueExpr|Array} condition see condition of {@link Join}\n * @returns {RightOuterJoin}\n * @extends RANode\n * @constructor\n */\nvar RightOuterJoin = exports.RightOuterJoin = function (_Join) {\n  (0, _inherits3.default)(RightOuterJoin, _Join);\n\n  function RightOuterJoin(child, child2, condition) {\n    (0, _classCallCheck3.default)(this, RightOuterJoin);\n    return (0, _possibleConstructorReturn3.default)(this, (RightOuterJoin.__proto__ || (0, _getPrototypeOf2.default)(RightOuterJoin)).call(this, child, child2, condition, 'right', '⟖'));\n  }\n\n  return RightOuterJoin;\n}(_Join2.Join);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/RightOuterJoin.js\n// module id = 146\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/RightOuterJoin.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.FullOuterJoin = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Join = __webpack_require__(140);\n\nvar _Union = __webpack_require__(135);\n\nvar _ValueExpr = __webpack_require__(46);\n\nvar ValueExpr = _interopRequireWildcard(_ValueExpr);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra full outer Join operator\n *\n * A full outer join B = (A left outer join B) union (A right outer join B)\n *\n * @extends RANode\n * @constructor\n * @param   {RANode}               child     the left child expression\n * @param   {RANode}               child2    the right child expression\n * @param   {null|ValueExpr|Array} condition see condition of {@link Join}\n * @returns {FullOuterJoin}\n */\nvar FullOuterJoin = exports.FullOuterJoin = function (_RANode) {\n\t(0, _inherits3.default)(FullOuterJoin, _RANode);\n\n\t// condition can be null to generate natural condition\n\tfunction FullOuterJoin(child, child2, condition) {\n\t\t(0, _classCallCheck3.default)(this, FullOuterJoin);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (FullOuterJoin.__proto__ || (0, _getPrototypeOf2.default)(FullOuterJoin)).call(this, '⟗'));\n\n\t\t_this.setChild(child);\n\t\t_this.setChild2(child2);\n\t\t_this._condition = condition;\n\t\t_this._isNaturalJoin = condition === null || condition instanceof Array;\n\n\t\t// this is used for the USING() clause for SQL where the natural join is restricted to some columns\n\t\tif (condition instanceof Array) {\n\t\t\tif (condition.length === 0) throw 'this should not happen array has to have at least one element';\n\n\t\t\t_this._restrictToColumns = condition;\n\t\t} else {\n\t\t\t_this._restrictToColumns = false;\n\t\t}\n\n\t\t// is set by check\n\t\t_this._delegate = null;\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(FullOuterJoin, [{\n\t\tkey: 'setChild2',\n\t\tvalue: function setChild2(child2) {\n\t\t\tthis._child2 = child2;\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._delegate.getSchema();\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar res = this._delegate.getResult(session);\n\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\t// full outer theta-join is union of left and right outer theta-joins\n\n\t\t\tthis._child.check();\n\t\t\tthis._child2.check();\n\t\t\tvar schemaA = this._child.getSchema();\n\t\t\tvar schemaB = this._child2.getSchema();\n\n\t\t\tif (this._isNaturalJoin) {\n\t\t\t\t// check if columns of using clause appear in both schemas\n\t\t\t\tif (this._restrictToColumns !== false) {\n\t\t\t\t\tfor (var i = 0; i < this._restrictToColumns.length; i++) {\n\t\t\t\t\t\tif (schemaA.getColumnIndexArray(this._restrictToColumns[i], null).length === 0 || schemaB.getColumnIndexArray(this._restrictToColumns[i], null).length === 0) {\n\t\t\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-column-not-in-both-schemas', { column: this._restrictToColumns[i] }));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// generate natural condition to force left and right joins of delegate to theta joins\n\t\t\t\tthis._condition = _Join.Join.getNaturalJoinCondition(schemaA, schemaB, this._restrictToColumns);\n\t\t\t\tthis.setMetaData('naturalJoinConditions', _Join.Join.getNaturalJoinConditionArray(schemaA, schemaB, this._restrictToColumns));\n\t\t\t} else {\n\t\t\t\t//this._condition = this._condition;\n\t\t\t}\n\n\t\t\tthis._condition.check(schemaA, schemaB);\n\t\t\tif (this._condition.getDataType() !== 'boolean') {\n\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-condition-must-be-boolean'));\n\t\t\t}\n\n\t\t\tthis._delegate = new _Union.Union(new _Join.Join(this._child, this._child2, this._condition, 'left'), new _Join.Join(this._child, this._child2, this._condition, 'right'));\n\t\t\tthis._delegate.check();\n\t\t}\n\t}, {\n\t\tkey: 'getArgumentHtml',\n\t\tvalue: function getArgumentHtml() {\n\t\t\tif (this._isNaturalJoin) return '';\n\t\t\treturn this._condition.getFormulaHtml();\n\t\t}\n\t}]);\n\treturn FullOuterJoin;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/FullOuterJoin.js\n// module id = 147\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/FullOuterJoin.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.SemiJoin = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Table = __webpack_require__(102);\n\nvar _Join = __webpack_require__(140);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra semi-join operator\n *\n * @extends RANode\n * @constructor\n * @param   {RANode}        child          the left child expression\n * @param   {RANode}        child2         the right child expression\n * @param   {Boolean}       isLeftSemiJoin true if if is a left semi join; false for right semi join\n * @returns {SemiJoin}\n */\nvar SemiJoin = exports.SemiJoin = function (_RANode) {\n\t(0, _inherits3.default)(SemiJoin, _RANode);\n\n\tfunction SemiJoin(child, child2, isLeftSemiJoin) {\n\t\t(0, _classCallCheck3.default)(this, SemiJoin);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (SemiJoin.__proto__ || (0, _getPrototypeOf2.default)(SemiJoin)).call(this, isLeftSemiJoin ? '⋉' : '⋊'));\n\n\t\t_this.setChild(child);\n\t\t_this.setChild2(child2);\n\n\t\t_this._isLeftSemiJoin = isLeftSemiJoin;\n\n\t\t// is set by check\n\t\t_this._condition = null;\n\t\t_this._schema = null;\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(SemiJoin, [{\n\t\tkey: 'setChild2',\n\t\tvalue: function setChild2(child2) {\n\t\t\tthis._child2 = child2;\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._schema;\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar res = new _Table.Table();\n\t\t\tres.setSchema(this.getSchema());\n\n\t\t\tvar orgA = this._child.getResult(session);\n\t\t\tvar orgB = this._child2.getResult(session);\n\n\t\t\t// copy\n\t\t\tvar condition = this._condition;\n\n\t\t\t// nested loop join\n\t\t\tvar numRowsA = orgA.getNumRows();\n\t\t\tvar numRowsB = orgB.getNumRows();\n\n\t\t\tfor (var i = 0; i < numRowsA; i++) {\n\t\t\t\tvar rowA = orgA.getRow(i);\n\n\t\t\t\tfor (var j = 0; j < numRowsB; j++) {\n\t\t\t\t\tvar rowB = orgB.getRow(j);\n\n\t\t\t\t\tif (condition.evaluate(rowA, rowB, i, session) === true) if (this._isLeftSemiJoin) res.addRow(rowA);else res.addRow(rowB);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres.eliminateDuplicateRows();\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\t\t\tthis._child2.check();\n\n\t\t\tvar schemaA = this._child.getSchema();\n\t\t\tvar schemaB = this._child2.getSchema();\n\n\t\t\tthis._condition = _Join.Join.getNaturalJoinCondition(schemaA, schemaB);\n\t\t\tthis.setMetaData('naturalJoinConditions', _Join.Join.getNaturalJoinConditionArray(schemaA, schemaB));\n\n\t\t\tif (this._isLeftSemiJoin) {\n\t\t\t\tthis._schema = schemaA;\n\t\t\t} else {\n\t\t\t\tthis._schema = schemaB;\n\t\t\t}\n\n\t\t\tthis._condition.check(schemaA, schemaB);\n\t\t\tif (this._condition.getDataType() !== 'boolean') {\n\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-condition-must-be-boolean'));\n\t\t\t}\n\t\t}\n\t}]);\n\treturn SemiJoin;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/SemiJoin.js\n// module id = 148\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/SemiJoin.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.AntiJoin = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Table = __webpack_require__(102);\n\nvar _Join = __webpack_require__(140);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra anti-join operator\n *\n * @extends RANode\n * @constructor\n * @param   {RANode}        child          the left child expression\n * @param   {RANode}        child2         the right child expression\n * @returns {AntiJoin}\n */\nvar AntiJoin = exports.AntiJoin = function (_RANode) {\n\t(0, _inherits3.default)(AntiJoin, _RANode);\n\n\tfunction AntiJoin(child, child2) {\n\t\t(0, _classCallCheck3.default)(this, AntiJoin);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (AntiJoin.__proto__ || (0, _getPrototypeOf2.default)(AntiJoin)).call(this, '▷'));\n\n\t\t_this.setChild(child);\n\t\t_this.setChild2(child2);\n\n\t\t// is set by check\n\t\t_this._condition = null;\n\t\t_this._schema = null;\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(AntiJoin, [{\n\t\tkey: 'setChild2',\n\t\tvalue: function setChild2(child2) {\n\t\t\tthis._child2 = child2;\n\t\t}\n\t}, {\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._schema;\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar res = new _Table.Table();\n\t\t\tres.setSchema(this.getSchema());\n\n\t\t\tvar orgA = this._child.getResult(session);\n\t\t\tvar orgB = this._child2.getResult(session);\n\n\t\t\t// copy\n\t\t\tvar condition = this._condition;\n\n\t\t\t// nested loop join\n\t\t\tvar numRowsA = orgA.getNumRows();\n\t\t\tvar numRowsB = orgB.getNumRows();\n\t\t\tvar rowA, rowB, partnerFound;\n\n\t\t\tfor (var i = 0; i < numRowsA; i++) {\n\t\t\t\trowA = orgA.getRow(i);\n\t\t\t\tpartnerFound = false;\n\n\t\t\t\tfor (var j = 0; j < numRowsB; j++) {\n\t\t\t\t\trowB = orgB.getRow(j);\n\n\t\t\t\t\tif (condition.evaluate(rowA, rowB, i, session) === true) {\n\t\t\t\t\t\tpartnerFound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (partnerFound === false) {\n\t\t\t\t\tres.addRow(rowA);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\t\t\tthis._child2.check();\n\n\t\t\tvar schemaA = this._child.getSchema();\n\t\t\tvar schemaB = this._child2.getSchema();\n\n\t\t\tthis._condition = _Join.Join.getNaturalJoinCondition(schemaA, schemaB);\n\t\t\tthis.setMetaData('naturalJoinConditions', _Join.Join.getNaturalJoinConditionArray(schemaA, schemaB));\n\n\t\t\tthis._schema = schemaA;\n\n\t\t\tthis._condition.check(schemaA, schemaB);\n\t\t\tif (this._condition.getDataType() !== 'boolean') {\n\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-condition-must-be-boolean'));\n\t\t\t}\n\t\t}\n\t}]);\n\treturn AntiJoin;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/AntiJoin.js\n// module id = 149\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/AntiJoin.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.RenameColumns = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nvar _Schema = __webpack_require__(101);\n\nvar _Column = __webpack_require__(100);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra anti-join operator\n *\n * the columns that should be renamed are added via `addRenaming()`\n *\n * @extends RANode\n * @constructor\n * @param   {RANode}        child the left child expression\n * @returns {RenameColumns}\n */\nvar RenameColumns = exports.RenameColumns = function (_RANode) {\n\t(0, _inherits3.default)(RenameColumns, _RANode);\n\n\tfunction RenameColumns(child) {\n\t\t(0, _classCallCheck3.default)(this, RenameColumns);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (RenameColumns.__proto__ || (0, _getPrototypeOf2.default)(RenameColumns)).call(this, '&rho;'));\n\n\t\t_this._renameList = [];\n\n\t\t_this.setChild(child);\n\t\t_this._schema = null;\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(RenameColumns, [{\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._schema;\n\t\t}\n\t}, {\n\t\tkey: 'addRenaming',\n\t\tvalue: function addRenaming(newName, oldName, oldRelAlias) {\n\t\t\tthis._renameList.push({\n\t\t\t\tnewName: newName,\n\t\t\t\toldName: oldName,\n\t\t\t\toldRelAlias: oldRelAlias\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\n\t\t\tvar schemaA = this._child.getSchema().copy();\n\t\t\tvar schema = new _Schema.Schema();\n\t\t\tvar list = this._renameList;\n\t\t\tvar i, j, oldColumn, columnRenamed, e;\n\n\t\t\t// check the rename list\n\t\t\tfor (i = 0; i < list.length; i++) {\n\t\t\t\tif (schemaA.getColumnIndex(list[i].oldName, list[i].oldRelAlias, false) === -1) {\n\t\t\t\t\tthis.throwExecutionError(i18n.t('db.messages.exec.error-column-not-found-name', {\n\t\t\t\t\t\tcolumn: _Column.Column.printColumn(list[i].oldName, list[i].oldRelAlias),\n\t\t\t\t\t\tschema: schemaA.toString()\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create the new schema\n\t\t\tfor (i = 0; i < schemaA.getSize(); i++) {\n\t\t\t\toldColumn = schemaA.getColumn(i);\n\n\t\t\t\tcolumnRenamed = false;\n\t\t\t\tfor (j = 0; j < list.length; j++) {\n\t\t\t\t\te = list[j];\n\t\t\t\t\tif (e.oldName == oldColumn.getName() && (e.oldRelAlias === null || e.oldRelAlias == oldColumn.getRelAlias())) {\n\n\t\t\t\t\t\t// add column with new name\n\t\t\t\t\t\tschema.addColumn(e.newName, oldColumn.getRelAlias(), oldColumn.getType());\n\n\t\t\t\t\t\tcolumnRenamed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (columnRenamed) continue;\n\n\t\t\t\t// add the not renamed column with its original\n\t\t\t\tschema.addColumn2(schemaA.getColumn(i));\n\t\t\t}\n\n\t\t\tthis._schema = schema;\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult(session) {\n\t\t\tsession = this._returnOrCreateSession(session);\n\n\t\t\tvar res = this._child.getResult(session).copy();\n\t\t\tres.setSchema(this.getSchema());\n\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'getArgumentHtml',\n\t\tvalue: function getArgumentHtml() {\n\t\t\tvar out = [];\n\t\t\tvar list = this._renameList;\n\t\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\t\tvar e = list[i];\n\t\t\t\tout.push(e.newName + '←' + _Column.Column.printColumn(e.oldName, e.oldRelAlias));\n\t\t\t}\n\n\t\t\treturn out.join(', ');\n\t\t}\n\t}]);\n\treturn RenameColumns;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/RenameColumns.js\n// module id = 150\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/RenameColumns.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.RenameRelation = undefined;\n\nvar _getPrototypeOf = __webpack_require__(47);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = __webpack_require__(38);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(39);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(51);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = __webpack_require__(87);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _ExecutionError = __webpack_require__(99);\n\nvar _RANode2 = __webpack_require__(133);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * relational algebra anti-join operator\n *\n * @extends RANode\n * @constructor\n * @param   {RANode}         child           the left child expression\n * @param {String} new alias for the relation as String\n * @returns {RenameRelation}\n */\nvar RenameRelation = exports.RenameRelation = function (_RANode) {\n\t(0, _inherits3.default)(RenameRelation, _RANode);\n\n\tfunction RenameRelation(child, newRelAlias) {\n\t\t(0, _classCallCheck3.default)(this, RenameRelation);\n\n\t\tvar _this = (0, _possibleConstructorReturn3.default)(this, (RenameRelation.__proto__ || (0, _getPrototypeOf2.default)(RenameRelation)).call(this, '&rho;'));\n\n\t\t_this._newRelAlias = newRelAlias;\n\n\t\t_this.setChild(child);\n\t\t_this._schema = null;\n\t\treturn _this;\n\t}\n\n\t(0, _createClass3.default)(RenameRelation, [{\n\t\tkey: 'getSchema',\n\t\tvalue: function getSchema() {\n\t\t\treturn this._schema;\n\t\t}\n\t}, {\n\t\tkey: 'check',\n\t\tvalue: function check() {\n\t\t\tthis._child.check();\n\n\t\t\ttry {\n\t\t\t\tthis._schema = this._child.getSchema().copy();\n\t\t\t\tthis._schema.setRelAlias(this._newRelAlias);\n\t\t\t} catch (e) {\n\t\t\t\tthis.throwExecutionError(e.message);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'getResult',\n\t\tvalue: function getResult() {\n\t\t\tvar res = this._child.getResult().copy();\n\t\t\tres.setSchema(this.getSchema());\n\n\t\t\tthis.setResultNumRows(res.getNumRows());\n\t\t\treturn res;\n\t\t}\n\t}, {\n\t\tkey: 'getArgumentHtml',\n\t\tvalue: function getArgumentHtml() {\n\t\t\treturn this._newRelAlias;\n\t\t}\n\t}]);\n\treturn RenameRelation;\n}(_RANode2.RANode);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/exec/RenameRelation.js\n// module id = 151\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/exec/RenameRelation.js?")},function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.replaceVariables = replaceVariables;\n/**\n * replaces all variables with there definition in the assignments of a RA statement\n * @param root\n * @param predefinedRelations\n */\nfunction replaceVariables(root, predefinedRelations) {\n\t// root is the real root node! of a statement\n\n\t// find all relations used in this branch (recursively)\n\tfunction getRelationsIn(root, whiteList) {\n\t\tvar a = [];\n\n\t\tfunction rec(parent, attrName, a) {\n\t\t\tvar child = parent[attrName];\n\n\t\t\tif (child.type === 'statement') {\n\t\t\t\t// SQL statement\n\t\t\t\trec(child, 'from', a);\n\t\t\t}\n\n\t\t\tif (child.type === 'relation' && typeof whiteList[child.name] !== 'undefined') {\n\t\t\t\t// replace\n\t\t\t\ta.push({\n\t\t\t\t\tname: child.name,\n\t\t\t\t\tline: child.line,\n\t\t\t\t\tcolumn: child.column\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof child.child !== 'undefined' && child.child !== null) {\n\t\t\t\trec(child, 'child', a);\n\t\t\t}\n\n\t\t\tif (typeof child.child2 !== 'undefined' && child.child2 !== null) {\n\t\t\t\trec(child, 'child2', a);\n\t\t\t}\n\t\t}\n\n\t\trec(root, 'child', a);\n\t\treturn a;\n\t}\n\n\tif (root.assignments.length > 0) {\n\t\tvar variables = {};\n\t\tvar variableNames = {};\n\t\tvar i;\n\n\t\t// names of declared variables\n\t\tfor (i = 0; i < root.assignments.length; i++) {\n\t\t\tvariableNames[root.assignments[i].name] = true;\n\t\t}\n\n\t\tfor (i = 0; i < root.assignments.length; i++) {\n\t\t\tvar name = root.assignments[i].name;\n\t\t\tvar child = root.assignments[i].child;\n\t\t\tvar childRelations = getRelationsIn(root.assignments[i], variableNames);\n\n\t\t\tif (typeof predefinedRelations[name] != 'undefined' || typeof variables[name] != 'undefined') {\n\t\t\t\tvar e = new Error(i18n.t('db.messages.translate.error-variable-name-conflict', { name: name }));\n\t\t\t\te.line = root.assignments[i].line;\n\t\t\t\te.column = root.assignments[i].column;\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\t// save the origin of the node\n\t\t\tif (!child.metaData) child.metaData = {};\n\t\t\tchild.metaData.fromVariable = name;\n\n\t\t\t//replace_var(name, root.child, child);\n\t\t\tvariables[name] = {\n\t\t\t\tname: name,\n\t\t\t\tchild: child, // definition\n\t\t\t\tassignmentIndex: i,\n\t\t\t\tchildRelations: childRelations // variables/relations used in definition\n\t\t\t};\n\t\t}\n\n\t\t// check for cycles with Depth-first search\n\t\tvar visited = {};\n\t\tvar finished = {};\n\t\tfor (i in variables) {\n\t\t\tif (!variables.hasOwnProperty(i)) continue;\n\n\t\t\tvisited[i] = false;\n\t\t\tfinished[i] = false;\n\t\t}\n\t\tvar dfs = function dfs(name, variables, visited, finished) {\n\t\t\tif (finished[name] === true) return;\n\t\t\tif (visited[name] === true) {\n\t\t\t\tthrow new Error(i18n.t('db.messages.translate.error-variable-cyclic-usage', { name: name }));\n\t\t\t}\n\t\t\tvisited[name] = true;\n\n\t\t\tvar childRelations = variables[name].childRelations;\n\t\t\tfor (var i = 0; i < childRelations.length; i++) {\n\t\t\t\tdfs(childRelations[i].name, variables, visited, finished);\n\t\t\t}\n\t\t\tfinished[name] = true;\n\t\t};\n\n\t\tfor (i in variables) {\n\t\t\tif (!variables.hasOwnProperty(i)) continue;\n\n\t\t\tdfs(i, variables, visited, finished);\n\t\t}\n\n\t\t// replace\n\t\t// replaces all ocurrencies of a variable named _name_ in root with child\n\t\tvar replace2 = function replace2(parent, attrName, name, newChild) {\n\t\t\tvar child = parent[attrName];\n\n\t\t\tif (child.type === 'statement') {\n\t\t\t\t// SQL statement\n\t\t\t\treplace2(child, 'from', name, newChild);\n\t\t\t}\n\n\t\t\tif (child.type == 'relation' && child.name == name) {\n\t\t\t\t// replace\n\t\t\t\tparent[attrName] = newChild;\n\t\t\t\tparent[attrName].wrappedInBrackets = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof child.child != 'undefined' && child.child !== null) {\n\t\t\t\treplace2(child, 'child', name, newChild);\n\t\t\t}\n\n\t\t\tif (typeof child.child2 != 'undefined' && child.child2 !== null) {\n\t\t\t\treplace2(child, 'child2', name, newChild);\n\t\t\t}\n\t\t};\n\n\t\t// replace all vars in all vars (except it selves)\n\t\tfor (i in variables) {\n\t\t\tif (!variables.hasOwnProperty(i)) continue;\n\n\t\t\tfor (var j in variables) {\n\t\t\t\tif (!variables.hasOwnProperty(j) || i == j) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\treplace2(variables[i], 'child', j, variables[j].child);\n\n\t\t\t\t// update variable in root node\n\t\t\t\troot.assignments[variables[i].assignmentIndex].child = variables[i].child;\n\t\t\t}\n\t\t}\n\n\t\t// replace vars in the roots child == the statement (if there is one)\n\t\tif (root.child !== null && typeof root.child !== 'undefined') {\n\t\t\tfor (i in variables) {\n\t\t\t\tif (!variables.hasOwnProperty(i)) continue;\n\n\t\t\t\treplace2(root, 'child', i, variables[i].child);\n\t\t\t}\n\t\t}\n\t} // end if assignments.length > 0\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/translate/replaceVariables.js\n// module id = 152\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/translate/replaceVariables.js?")},function(module,exports){eval('module.exports = (function() {\n  "use strict";\n\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = "SyntaxError";\n\n    if (typeof Error.captureStackTrace === "function") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n        parser  = this,\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart, groupStart: peg$parsegroupStart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(r) { return r; },\n        peg$c1 = { type: "any", description: "any character" },\n        peg$c2 = "\\r\\n",\n        peg$c3 = { type: "literal", value: "\\r\\n", description: "\\"\\\\r\\\\n\\"" },\n        peg$c4 = "\\n",\n        peg$c5 = { type: "literal", value: "\\n", description: "\\"\\\\n\\"" },\n        peg$c6 = { type: "other", description: "-- " },\n        peg$c7 = "--",\n        peg$c8 = { type: "literal", value: "--", description: "\\"--\\"" },\n        peg$c9 = /^[ \\t]/,\n        peg$c10 = { type: "class", value: "[ \\\\t]", description: "[ \\\\t]" },\n        peg$c11 = function() { return \'\'; },\n        peg$c12 = function(text) { return text; },\n        peg$c13 = "/*",\n        peg$c14 = { type: "literal", value: "/*", description: "\\"/*\\"" },\n        peg$c15 = "*/",\n        peg$c16 = { type: "literal", value: "*/", description: "\\"*/\\"" },\n        peg$c17 = { type: "other", description: "whitespace" },\n        peg$c18 = /^[ \\t\\r\\n]/,\n        peg$c19 = { type: "class", value: "[ \\\\t\\\\r\\\\n]", description: "[ \\\\t\\\\r\\\\n]" },\n        peg$c20 = { type: "other", description: "optional whitespace" },\n        peg$c21 = { type: "other", description: "whitespace without comments" },\n        peg$c22 = /^[\\r\\n\\t ]/,\n        peg$c23 = { type: "class", value: "[\\\\r\\\\n\\\\t ]", description: "[\\\\r\\\\n\\\\t ]" },\n        peg$c24 = { type: "other", description: "optional whitespace without comments" },\n        peg$c25 = { type: "other", description: "string" },\n        peg$c26 = "\'",\n        peg$c27 = { type: "literal", value: "\'", description: "\\"\'\\"" },\n        peg$c28 = /^[^\'\\n]/,\n        peg$c29 = { type: "class", value: "[^\'\\\\n]", description: "[^\'\\\\n]" },\n        peg$c30 = function(a) { return a; },\n        peg$c31 = "-",\n        peg$c32 = { type: "literal", value: "-", description: "\\"-\\"" },\n        peg$c33 = /^[0-9]/,\n        peg$c34 = { type: "class", value: "[0-9]", description: "[0-9]" },\n        peg$c35 = function(a) {return parseInt(a, 10); },\n        peg$c36 = ".",\n        peg$c37 = { type: "literal", value: ".", description: "\\".\\"" },\n        peg$c38 = function(a) {return parseFloat(a); },\n        peg$c39 = { type: "other", description: "date in ISO format (YYYY-MM-DD)" },\n        peg$c40 = function(year, month, day) {\n        \t\tyear = parseInt(year, 10);\n        \t\tmonth = parseInt(month, 10)-1;\n        \t\tday = parseInt(day, 10);\n        \t\tvar date = new Date(year, month, day);\n        \t\t\n        \t\tif(date.getFullYear() != year || date.getMonth() != month ||  date.getDate() != day){\n        \t\t\terror(i18n.t(\'db.messages.parser.error-invalid-date-format\', {str: text()}));\n        \t\t}\n        \t\treturn date;\n        \t},\n        peg$c41 = "true",\n        peg$c42 = { type: "literal", value: "true", description: "\\"true\\"" },\n        peg$c43 = function() { return true; },\n        peg$c44 = "false",\n        peg$c45 = { type: "literal", value: "false", description: "\\"false\\"" },\n        peg$c46 = function() { return false; },\n        peg$c47 = "=",\n        peg$c48 = { type: "literal", value: "=", description: "\\"=\\"" },\n        peg$c49 = { type: "other", description: "relationName" },\n        peg$c50 = /^[0-9a-zA-Z_]/,\n        peg$c51 = { type: "class", value: "[0-9a-zA-Z_]", description: "[0-9a-zA-Z_]" },\n        peg$c52 = /^[a-zA-Z]/,\n        peg$c53 = { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },\n        peg$c54 = function(a) {\n        \t\treturn a;\n        \t},\n        peg$c55 = function(relAlias, name) {\n        \t\tif(relAlias != null)\n        \t\t\trelAlias = relAlias[0];\n\n        \t\treturn {\n        \t\t\ttype: \'columnName\',\n        \t\t\tname: name,\n        \t\t\trelAlias: relAlias\n        \t\t};\n        \t},\n        peg$c56 = "[",\n        peg$c57 = { type: "literal", value: "[", description: "\\"[\\"" },\n        peg$c58 = "]",\n        peg$c59 = { type: "literal", value: "]", description: "\\"]\\"" },\n        peg$c60 = function(relAlias, index) {\n        \t\tif(relAlias != null)\n        \t\t\trelAlias = relAlias[0];\n\n        \t\treturn {\n        \t\t\ttype: \'columnName\',\n        \t\t\tname: parseInt(index, 10),\n        \t\t\trelAlias: relAlias\n        \t\t};\n        \t},\n        peg$c61 = "\\u03C0",\n        peg$c62 = { type: "literal", value: "\\u03C0", description: "\\"\\\\u03C0\\"" },\n        peg$c63 = "pi",\n        peg$c64 = { type: "literal", value: "pi", description: "\\"pi\\"" },\n        peg$c65 = "\\u03C3",\n        peg$c66 = { type: "literal", value: "\\u03C3", description: "\\"\\\\u03C3\\"" },\n        peg$c67 = "sigma",\n        peg$c68 = { type: "literal", value: "sigma", description: "\\"sigma\\"" },\n        peg$c69 = "\\u03C1",\n        peg$c70 = { type: "literal", value: "\\u03C1", description: "\\"\\\\u03C1\\"" },\n        peg$c71 = "rho",\n        peg$c72 = { type: "literal", value: "rho", description: "\\"rho\\"" },\n        peg$c73 = "\\u2190",\n        peg$c74 = { type: "literal", value: "\\u2190", description: "\\"\\\\u2190\\"" },\n        peg$c75 = "<-",\n        peg$c76 = { type: "literal", value: "<-", description: "\\"<-\\"" },\n        peg$c77 = "\\u2192",\n        peg$c78 = { type: "literal", value: "\\u2192", description: "\\"\\\\u2192\\"" },\n        peg$c79 = "->",\n        peg$c80 = { type: "literal", value: "->", description: "\\"->\\"" },\n        peg$c81 = "\\u03C8",\n        peg$c82 = { type: "literal", value: "\\u03C8", description: "\\"\\\\u03C8\\"" },\n        peg$c83 = "psi",\n        peg$c84 = { type: "literal", value: "psi", description: "\\"psi\\"" },\n        peg$c85 = "\\u03C4",\n        peg$c86 = { type: "literal", value: "\\u03C4", description: "\\"\\\\u03C4\\"" },\n        peg$c87 = "tau",\n        peg$c88 = { type: "literal", value: "tau", description: "\\"tau\\"" },\n        peg$c89 = "\\u03B3",\n        peg$c90 = { type: "literal", value: "\\u03B3", description: "\\"\\\\u03B3\\"" },\n        peg$c91 = "gamma",\n        peg$c92 = { type: "literal", value: "gamma", description: "\\"gamma\\"" },\n        peg$c93 = "\\u222A",\n        peg$c94 = { type: "literal", value: "\\u222A", description: "\\"\\\\u222A\\"" },\n        peg$c95 = "union",\n        peg$c96 = { type: "literal", value: "union", description: "\\"union\\"" },\n        peg$c97 = "\\u2229",\n        peg$c98 = { type: "literal", value: "\\u2229", description: "\\"\\\\u2229\\"" },\n        peg$c99 = "intersect",\n        peg$c100 = { type: "literal", value: "intersect", description: "\\"intersect\\"" },\n        peg$c101 = "\\xF7",\n        peg$c102 = { type: "literal", value: "\\xF7", description: "\\"\\\\xF7\\"" },\n        peg$c103 = "/",\n        peg$c104 = { type: "literal", value: "/", description: "\\"/\\"" },\n        peg$c105 = "\\\\",\n        peg$c106 = { type: "literal", value: "\\\\", description: "\\"\\\\\\\\\\"" },\n        peg$c107 = "except",\n        peg$c108 = { type: "literal", value: "except", description: "\\"except\\"" },\n        peg$c109 = "\\u2A2F",\n        peg$c110 = { type: "literal", value: "\\u2A2F", description: "\\"\\\\u2A2F\\"" },\n        peg$c111 = "x",\n        peg$c112 = { type: "literal", value: "x", description: "\\"x\\"" },\n        peg$c113 = "cross",\n        peg$c114 = { type: "literal", value: "cross", description: "\\"cross\\"" },\n        peg$c115 = "join",\n        peg$c116 = { type: "literal", value: "join", description: "\\"join\\"" },\n        peg$c117 = "\\u2A1D",\n        peg$c118 = { type: "literal", value: "\\u2A1D", description: "\\"\\\\u2A1D\\"" },\n        peg$c119 = "\\u22C8",\n        peg$c120 = { type: "literal", value: "\\u22C8", description: "\\"\\\\u22C8\\"" },\n        peg$c121 = "inner",\n        peg$c122 = { type: "literal", value: "inner", description: "\\"inner\\"" },\n        peg$c123 = "natural",\n        peg$c124 = { type: "literal", value: "natural", description: "\\"natural\\"" },\n        peg$c125 = "\\u22C9",\n        peg$c126 = { type: "literal", value: "\\u22C9", description: "\\"\\\\u22C9\\"" },\n        peg$c127 = "left",\n        peg$c128 = { type: "literal", value: "left", description: "\\"left\\"" },\n        peg$c129 = "semi",\n        peg$c130 = { type: "literal", value: "semi", description: "\\"semi\\"" },\n        peg$c131 = "\\u22CA",\n        peg$c132 = { type: "literal", value: "\\u22CA", description: "\\"\\\\u22CA\\"" },\n        peg$c133 = "right",\n        peg$c134 = { type: "literal", value: "right", description: "\\"right\\"" },\n        peg$c135 = "\\u25B7",\n        peg$c136 = { type: "literal", value: "\\u25B7", description: "\\"\\\\u25B7\\"" },\n        peg$c137 = "anti",\n        peg$c138 = { type: "literal", value: "anti", description: "\\"anti\\"" },\n        peg$c139 = "\\u27D5",\n        peg$c140 = { type: "literal", value: "\\u27D5", description: "\\"\\\\u27D5\\"" },\n        peg$c141 = "outer",\n        peg$c142 = { type: "literal", value: "outer", description: "\\"outer\\"" },\n        peg$c143 = "\\u27D6",\n        peg$c144 = { type: "literal", value: "\\u27D6", description: "\\"\\\\u27D6\\"" },\n        peg$c145 = "\\u27D7",\n        peg$c146 = { type: "literal", value: "\\u27D7", description: "\\"\\\\u27D7\\"" },\n        peg$c147 = "full",\n        peg$c148 = { type: "literal", value: "full", description: "\\"full\\"" },\n        peg$c149 = function(n) { usedRelationNames.push(n); },\n        peg$c150 = function(n, e) {\n        \t\treturn {\n        \t\t\ttype: \'assignment\',\n        \t\t\tname: n,\n        \t\t\tchild: e,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c151 = function(a, dst) {\n        \t\treturn {\n        \t\t\ttype: \'namedColumnExpr\',\n        \t\t\tname: dst,\n        \t\t\trelAlias: null,\n        \t\t\tchild: a,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c152 = function(dst, a) {\n        \t\treturn {\n        \t\t\ttype: \'namedColumnExpr\',\n        \t\t\tname: dst,\n        \t\t\trelAlias: null,\n        \t\t\tchild: a,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c153 = ",",\n        peg$c154 = { type: "literal", value: ",", description: "\\",\\"" },\n        peg$c155 = function(a, b) {\n        \t\tvar t = [a];\n        \t\tif(b !== null){\n        \t\t\tfor(var i in b){\n        \t\t\t\tt.push(b[i][3]);\n        \t\t\t}\n        \t\t}\n        \t\treturn t;\n        \t},\n        peg$c156 = function(dst, src) {\n        \t\treturn {\n        \t\t\ttype: \'colAssignment\',\n        \t\t\tsrc: src,\n        \t\t\tdst: dst,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c157 = function(src, dst) {\n        \t\treturn {\n        \t\t\ttype: \'colAssignment\',\n        \t\t\tsrc: src,\n        \t\t\tdst: dst,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c158 = function(a, b) {\n        \tvar t = [a];\n        \tif(b !== null){\n        \t\tfor(var i in b){\n        \t\t\tt.push(b[i][3]);\n        \t\t}\n        \t}\n        \treturn t;\n        },\n        peg$c159 = "asc",\n        peg$c160 = { type: "literal", value: "asc", description: "\\"asc\\"" },\n        peg$c161 = "desc",\n        peg$c162 = { type: "literal", value: "desc", description: "\\"desc\\"" },\n        peg$c163 = function(a, asc) {\n        \t\tif(asc == null)\n        \t\t\tasc = true;\n        \t\telse\n        \t\t\tasc = asc[1];\n        \t\t\n        \t\treturn {\n        \t\t\tcol: a,\n        \t\t\tasc: asc\n        \t\t};\n        \t},\n        peg$c164 = "sum",\n        peg$c165 = { type: "literal", value: "sum", description: "\\"sum\\"" },\n        peg$c166 = "count",\n        peg$c167 = { type: "literal", value: "count", description: "\\"count\\"" },\n        peg$c168 = "avg",\n        peg$c169 = { type: "literal", value: "avg", description: "\\"avg\\"" },\n        peg$c170 = "min",\n        peg$c171 = { type: "literal", value: "min", description: "\\"min\\"" },\n        peg$c172 = "max",\n        peg$c173 = { type: "literal", value: "max", description: "\\"max\\"" },\n        peg$c174 = "(",\n        peg$c175 = { type: "literal", value: "(", description: "\\"(\\"" },\n        peg$c176 = ")",\n        peg$c177 = { type: "literal", value: ")", description: "\\")\\"" },\n        peg$c178 = function(func, col) {\n        \t\treturn {\n        \t\t\taggFunction: func.toUpperCase(),\n        \t\t\tcol: col\n        \t\t};\n        \t},\n        peg$c179 = "count(*)",\n        peg$c180 = { type: "literal", value: "count(*)", description: "\\"count(*)\\"" },\n        peg$c181 = function() {\n        \t\treturn {\n        \t\t\taggFunction: \'COUNT_ALL\',\n        \t\t\tcol: null\n        \t\t};\n        \t},\n        peg$c182 = function(func, name) {\n        \t\tfunc.name = name;\n        \t\treturn func;\n        \t},\n        peg$c183 = function(name, func) {\n        \t\tfunc.name = name;\n        \t\treturn func;\n        \t},\n        peg$c184 = function(a) {\n        \t\t/* \n        \t\tif the expression is only a single unqualified column\n        \t\tit could also be a relation and should not have been interpreted \n        \t\tas an expression\n        \t\t\n        \t\ttherefore the name of the "column" is checked against all known \n        \t\trelation-names; if it matches the whole `booleanExprWithTrailingWhitspace` match fails\n        \t\t\n        \t\tif there is a boolean column that should form the whole expression\n        \t\tthe user has to wrap it in brackets\n        \t\t*/\n        \t\tif(a.type === \'valueExpr\' && a.func === \'columnValue\' && !a.wrappedInBrackets && a.args[1] === null){\n        \t\t\t//console.log(\'relation detected?\', usedRelationNames);\n        \t\t\tfor(var i = 0; i < usedRelationNames.length; i++){\n        \t\t\t\tif(usedRelationNames[i] === a.args[0]){\n        \t\t\t\t\t//console.log(\'relation detected!\', usedRelationNames);\n        \t\t\t\t\treturn false;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\t// not found in the known relations; seems to be a column\n        \t\t\treturn true;\n        \t\t}\n        \t\treturn true;\n        \t},\n        peg$c185 = function(a2, a) {\n        \t\tvar assignments = [a];\n        \t\tfor(var i in a2){\n        \t\t\tassignments.push(a2[i][0]);\n        \t\t}\n        \t\tcheckAssignments(assignments);\n\n        \t\treturn {\n        \t\t\ttype: \'root\',\n        \t\t\tassignments: assignments,\n        \t\t\tchild: null,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c186 = function(a, e) {\n        \t\tvar assignments = [];\n        \t\tfor(var i = 0; i < a.length; i++){\n        \t\t\tassignments.push(a[i][0]);\n        \t\t}\n        \t\tcheckAssignments(assignments);\n\n        \t\treturn {\n        \t\t\ttype: \'root\',\n        \t\t\tassignments: assignments,\n        \t\t\tchild: e,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c187 = function(a) {\n        \t\tvar groups = [];\n        \t\tfor(var i = 0; i < a.length; i++){\n        \t\t\tgroups.push(a[i][1]);\n        \t\t}\n\n        \t\treturn {\n        \t\t\ttype: \'groupRoot\',\n        \t\t\tgroups: groups,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c188 = function(a, b) {\n        \t\tvar headers = {};\n        \t\theaders[a.header] = a.text;\n        \t\t\n        \t\tb.map(function(e){\n        \t\t\tvar header = e[1].header;\n        \t\t\tif(headers[header])\n        \t\t\t\terror(i18n.t(\'db.messages.parser.error-group-duplicate-header\', {name: header}));\n        \t\t\t\n        \t\t\theaders[header] = e[1].text;\n        \t\t});\n        \t\t\n        \t\treturn headers;\n        \t},\n        peg$c189 = /^[a-z]/,\n        peg$c190 = { type: "class", value: "[a-z]", description: "[a-z]" },\n        peg$c191 = ":",\n        peg$c192 = { type: "literal", value: ":", description: "\\":\\"" },\n        peg$c193 = function(header, text) {\n        \t\treturn {\n        \t\t\theader: header,\n        \t\t\ttext: text\n        \t\t};\n        \t},\n        peg$c194 = "[[",\n        peg$c195 = { type: "literal", value: "[[", description: "\\"[[\\"" },\n        peg$c196 = "\\\\]]",\n        peg$c197 = { type: "literal", value: "\\\\]]", description: "\\"\\\\\\\\]]\\"" },\n        peg$c198 = "]]",\n        peg$c199 = { type: "literal", value: "]]", description: "\\"]]\\"" },\n        peg$c200 = function(header, text) {\n        \t\tswitch(header){\n        \t\t\tcase \'group\': break;\n        \t\t\tcase \'description\': break;\n        \t\t\tdefault: error(i18n.t(\'db.messages.parser.error-group-unknown-header\', {name: header}));\n        \t\t}\n        \t\t\n        \t\ttext = text.replace(/\\\\]]/g, \']]\');\n        \t\ttext = text.replace(/\\\\\\\\]]/g, \'\\\\]]\');\n\n        \t\treturn {\n        \t\t\theader: header,\n        \t\t\ttext: text\n        \t\t};\n        \t},\n        peg$c201 = function(headers, a) {\n        \t\tvar assignments = [];\n        \t\tfor(var i = 0; i < a.length; i++){\n        \t\t\tassignments.push(a[i][1]);\n        \t\t}\n        \t\tcheckAssignments(assignments);\n        \t\t\n        \t\tif(typeof headers.group === \'undefined\'){\n        \t\t\terror(i18n.t(\'db.messages.parser.error-group-header-name-missing\')+\': "group: ..........\\\\n"\');\n        \t\t}\n        \t\telse if(headers.group.trim().length === 0){\n        \t\t\terror(i18n.t(\'error-group-header-name-empty\'));\n        \t\t}\n\n        \t\treturn {\n        \t\t\ttype: \'tableGroup\',\n        \t\t\theaders: headers,\n        \t\t\tassignments: assignments,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c202 = function(first, rest) { return buildBinary(first, rest); },\n        peg$c203 = function(e) {\n        \t\te.wrappedInBrackets = true;\n        \t\treturn e;\n        \t},\n        peg$c204 = function(c) { return {type: \'intersect\', child2: c}; },\n        peg$c205 = function(c) { return {type: \'union\', child2: c}; },\n        peg$c206 = function(c) { return {type: \'difference\', child2: c}; },\n        peg$c207 = function(c) { return {type: \'crossJoin\', child2: c}; },\n        peg$c208 = function(a, c) { return {type: \'thetaJoin\', child2: c, arg:a}; },\n        peg$c209 = function(c) { return {type: \'naturalJoin\', child2: c}; },\n        peg$c210 = function(a, c) { return {type: \'leftOuterJoin\', child2: c, arg:a}; },\n        peg$c211 = function(a, c) { return {type: \'rightOuterJoin\', child2: c, arg:a}; },\n        peg$c212 = function(a, c) { return {type: \'fullOuterJoin\', child2: c, arg:a}; },\n        peg$c213 = function(c) { return {type: \'leftSemiJoin\', child2: c}; },\n        peg$c214 = function(c) { return {type: \'rightSemiJoin\', child2: c}; },\n        peg$c215 = function(c) { return {type: \'antiJoin\', child2: c}; },\n        peg$c216 = function(c) { return {type: \'division\', child2: c}; },\n        peg$c217 = function(a, c) {\n        \t\treturn {\n        \t\t\ttype: \'projection\', \n        \t\t\tchild: c,\n        \t\t\targ: a,\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c218 = function(a, c) {\n        \t\treturn {\n        \t\t\ttype: \'selection\',\n        \t\t\tchild: c,\n        \t\t\targ: a,\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c219 = function(a, c) {\n        \t\treturn {\n        \t\t\ttype: \'renameColumns\',\n        \t\t\tchild: c,\n        \t\t\targ: a,\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c220 = function(a, c) {\n        \t\treturn {\n        \t\t\ttype: \'renameRelation\', \n        \t\t\tchild: c, \n        \t\t\tnewRelAlias: a, \n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c221 = ";",\n        peg$c222 = { type: "literal", value: ";", description: "\\";\\"" },\n        peg$c223 = function(arg, arg2, c) {\n        \t\treturn {\n        \t\t\ttype: \'groupBy\', \n        \t\t\tchild: c, \n        \t\t\tgroup: arg, \n        \t\t\taggregate: arg2, \n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c224 = function(arg2, child) {\n        \t\treturn {\n        \t\t\ttype: \'groupBy\', \n        \t\t\tchild: child, \n        \t\t\tgroup: [], \n        \t\t\taggregate: arg2, \n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c225 = function(a, c) {\n        \t\treturn {\n        \t\t\ttype: \'orderBy\', \n        \t\t\tchild: c, \n        \t\t\targ: a, \n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c226 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'relation\', \n        \t\t\tname: a, \n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c227 = "!=",\n        peg$c228 = { type: "literal", value: "!=", description: "\\"!=\\"" },\n        peg$c229 = "\\u2260",\n        peg$c230 = { type: "literal", value: "\\u2260", description: "\\"\\\\u2260\\"" },\n        peg$c231 = "<>",\n        peg$c232 = { type: "literal", value: "<>", description: "\\"<>\\"" },\n        peg$c233 = function() { return \'!=\'; },\n        peg$c234 = ">=",\n        peg$c235 = { type: "literal", value: ">=", description: "\\">=\\"" },\n        peg$c236 = "\\u2265",\n        peg$c237 = { type: "literal", value: "\\u2265", description: "\\"\\\\u2265\\"" },\n        peg$c238 = function() { return \'>=\'; },\n        peg$c239 = ">",\n        peg$c240 = { type: "literal", value: ">", description: "\\">\\"" },\n        peg$c241 = "<=",\n        peg$c242 = { type: "literal", value: "<=", description: "\\"<=\\"" },\n        peg$c243 = "\\u2264",\n        peg$c244 = { type: "literal", value: "\\u2264", description: "\\"\\\\u2264\\"" },\n        peg$c245 = function() { return \'<=\'; },\n        peg$c246 = "<",\n        peg$c247 = { type: "literal", value: "<", description: "\\"<\\"" },\n        peg$c248 = { type: "other", description: "logical AND" },\n        peg$c249 = "and",\n        peg$c250 = { type: "literal", value: "and", description: "\\"and\\"" },\n        peg$c251 = "\\u2227",\n        peg$c252 = { type: "literal", value: "\\u2227", description: "\\"\\\\u2227\\"" },\n        peg$c253 = { type: "other", description: "logical XOR" },\n        peg$c254 = "xor",\n        peg$c255 = { type: "literal", value: "xor", description: "\\"xor\\"" },\n        peg$c256 = "\\u22BB",\n        peg$c257 = { type: "literal", value: "\\u22BB", description: "\\"\\\\u22BB\\"" },\n        peg$c258 = "\\u2295",\n        peg$c259 = { type: "literal", value: "\\u2295", description: "\\"\\\\u2295\\"" },\n        peg$c260 = { type: "other", description: "logical OR" },\n        peg$c261 = "or",\n        peg$c262 = { type: "literal", value: "or", description: "\\"or\\"" },\n        peg$c263 = "\\u2228",\n        peg$c264 = { type: "literal", value: "\\u2228", description: "\\"\\\\u2228\\"" },\n        peg$c265 = { type: "other", description: "logical NOT" },\n        peg$c266 = "!",\n        peg$c267 = { type: "literal", value: "!", description: "\\"!\\"" },\n        peg$c268 = "\\xAC",\n        peg$c269 = { type: "literal", value: "\\xAC", description: "\\"\\\\xAC\\"" },\n        peg$c270 = { type: "other", description: "delimiter" },\n        peg$c271 = "string",\n        peg$c272 = { type: "literal", value: "string", description: "\\"string\\"" },\n        peg$c273 = "number",\n        peg$c274 = { type: "literal", value: "number", description: "\\"number\\"" },\n        peg$c275 = "date",\n        peg$c276 = { type: "literal", value: "date", description: "\\"date\\"" },\n        peg$c277 = "boolean",\n        peg$c278 = { type: "literal", value: "boolean", description: "\\"boolean\\"" },\n        peg$c279 = function(col, type) {\n        \t\treturn {\n        \t\t\tname: col.name,\n        \t\t\trelAlias: col.relAlias,\n        \t\t\ttype: type === null ? null : type[1].toLowerCase()\n        \t\t};\n        \t},\n        peg$c280 = function(v) {\n        \t\treturn {\n        \t\t\ttype: \'date\',\n        \t\t\tvalue: v\n        \t\t};\n        \t},\n        peg$c281 = "null",\n        peg$c282 = { type: "literal", value: "null", description: "\\"null\\"" },\n        peg$c283 = "NULL",\n        peg$c284 = { type: "literal", value: "NULL", description: "\\"NULL\\"" },\n        peg$c285 = function() {\n        \t\treturn {\n        \t\t\ttype: \'null\',\n        \t\t\tvalue: null\n        \t\t};\n        \t},\n        peg$c286 = "}",\n        peg$c287 = { type: "literal", value: "}", description: "\\"}\\"" },\n        peg$c288 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'boolean\',\n        \t\t\tvalue: a,\n        \t\t\tquoted: false\n        \t\t};\n        \t},\n        peg$c289 = /^[\\-_a-z0-9.]/i,\n        peg$c290 = { type: "class", value: "[\\\\-_a-z0-9\\\\.]i", description: "[\\\\-_a-z0-9\\\\.]i" },\n        peg$c291 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'string\',\n        \t\t\tvalue: a,\n        \t\t\tquoted: false\n        \t\t};\n        \t},\n        peg$c292 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'string\',\n        \t\t\tvalue: a,\n        \t\t\tquoted: true\n        \t\t};\n        \t},\n        peg$c293 = "\\"",\n        peg$c294 = { type: "literal", value: "\\"", description: "\\"\\\\\\"\\"" },\n        peg$c295 = /^[^"\\n]/,\n        peg$c296 = { type: "class", value: "[^\\"\\\\n]", description: "[^\\"\\\\n]" },\n        peg$c297 = function(a, b) {\n        \t\tvar cols = [a];\n        \t\tvar newCol;\n        \t\tfor(var i = 0; i < b.length; i++){\n        \t\t\tnewCol = b[i][1];\n        \t\t\t\n        \t\t\t// attributes must be unique\n        \t\t\tfor(var j = 0; j < cols.length; j++){\n        \t\t\t\tif(cols[j].name == newCol.name && cols[j].relAlias == newCol.relAlias){\n        \t\t\t\t\tvar n = newCol.relAlias == null ? \'\' : newCol.relAlias+\'.\';\n        \t\t\t\t\terror(i18n.t(\'db.messages.parser.error-group-non-unique-attribute\', {name: n+newCol.name, index: i+2}));\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\t\n        \t\t\tcols.push(newCol);\n        \t\t}\n        \t\t\n        \t\treturn cols;\n        \t},\n        peg$c298 = function(a, b) {\n        \t\tvar t = [a];\n        \t\tfor(var i = 0; i < b.length; i++){\n        \t\t\tt.push(b[i][1]);\n        \t\t}\n        \t\t\n        \t\treturn t;\n        \t},\n        peg$c299 = "{",\n        peg$c300 = { type: "literal", value: "{", description: "\\"{\\"" },\n        peg$c301 = function(cols, trows) {\n        \t\tvar numCols = cols.length;\n        \t\t\n        \t\tvar rows = [], row, val, newRow;\n        \t\tfor(var i = 0; i < trows.length; i++){\n        \t\t\trow = trows[i][2];\n        \t\t\t\n        \t\t\tif(row.length != numCols)\n        \t\t\t\terror(\'expected \'+numCols+\' columns in row \'+(i+1)+\' but \'+row.length+\' found\');\n\n        \t\t\t// check types\n        \t\t\tnewRow = new Array(numCols); // for blank data only\n        \t\t\tfor(var j = 0; j < numCols; j++){\n        \t\t\t\tval = row[j];\n        \t\t\t\t\n        \t\t\t\tif(val.type === \'null\'){\n        \t\t\t\t\tnewRow[j] = null;\n        \t\t\t\t\tcontinue;\n        \t\t\t\t}\n        \t\t\t\t\n        \t\t\t\t// type not defined yet: define column type by first not null value\n        \t\t\t\tif(cols[j].type === null){\n        \t\t\t\t\tif(val.type == \'date\')\n        \t\t\t\t\t\tcols[j].type = \'date\';\n        \t\t\t\t\telse if(val.type == \'boolean\')\n        \t\t\t\t\t\tcols[j].type = \'boolean\';\n        \t\t\t\t\telse if(val.type == \'number\' || val.value.match(/^-?[0-9]+(\\.[0-9]+)?$/) && !val.quoted)\n        \t\t\t\t\t\tcols[j].type = \'number\';\n        \t\t\t\t\telse if(val.type == \'string\')\n        \t\t\t\t\t\tcols[j].type = \'string\';\n        \t\t\t\t}\n        \t\t\t\t\n        \t\t\t\tswitch(cols[j].type){\n        \t\t\t\t\tcase \'date\':\n        \t\t\t\t\t\tif(val.type !== \'date\'){\n        \t\t\t\t\t\t\terror(\'no valid date in row \'+(i+1)+\' column \'+(j+1));\n        \t\t\t\t\t\t}\n        \t\t\t\t\t\tnewRow[j] = val.value;\n        \t\t\t\t\t\tbreak;\n        \t\t\t\t\t\n        \t\t\t\t\tcase \'number\':\n        \t\t\t\t\t\tif(val.type === \'number\'){\n        \t\t\t\t\t\t\tnewRow[j] = val.value;\n        \t\t\t\t\t\t}\n        \t\t\t\t\t\telse if(val.value.match(/^-?[0-9]+$/)){\n        \t\t\t\t\t\t\tnewRow[j] = parseInt(val.value, 10);\n        \t\t\t\t\t\t}\n        \t\t\t\t\t\telse if(val.value.match(/^-?[0-9]+\\.[0-9]+$/)){\n        \t\t\t\t\t\t\tnewRow[j] = parseFloat(val.value);\n        \t\t\t\t\t\t}\n        \t\t\t\t\t\telse{\n        \t\t\t\t\t\t\terror(\'no number in row \'+(i+1)+\' column \'+(j+1) + \'; found: "\'+val.value+\'"\');\n        \t\t\t\t\t\t}\n        \t\t\t\t\t\tbreak;\n        \t\t\t\t\t\n        \t\t\t\t\tcase \'string\':\n        \t\t\t\t\t\tnewRow[j] = val.value.toString();\n        \t\t\t\t\t\tbreak;\n        \t\t\t\t\t\t\n        \t\t\t\t\tcase \'boolean\':\n        \t\t\t\t\t\tnewRow[j] = val.value;\n        \t\t\t\t\t\tbreak;\n        \t\t\t\t\t\t\n        \t\t\t\t\tdefault:\n        \t\t\t\t\t\tthrow new Error(\'should not happen: \'+cols[j].type);\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\t\n        \t\t\trows.push(newRow);\n        \t\t}\n        \t\t\n        \t\t// check if types are set for all columns (could be missing if table has no rows or only null values in a column)\n        \t\tfor(var i = 0; i < numCols; i++){\n        \t\t\tif(cols[i].type === null){\n        \t\t\t\terror(\'type for column \'+cols[i].name+\' must be set explicitly\');\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\t\n        \t\treturn {\n        \t\t\ttype: \'table\',\n        \t\t\tname: \'_inlineRelation\'+(inlineTableNum++),\n        \t\t\tcolumns: cols,\n        \t\t\trows: rows,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c302 = { type: "other", description: "boolean expression" },\n        peg$c303 = function(right) { \n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: \'or\',\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c304 = "||",\n        peg$c305 = { type: "literal", value: "||", description: "\\"||\\"" },\n        peg$c306 = function(right) { \n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'string\',\n        \t\t\tfunc: \'concat\',\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c307 = function(right) { \n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: \'xor\',\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c308 = function(right) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: \'and\',\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c309 = function(o, right) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: o,\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c310 = "like",\n        peg$c311 = { type: "literal", value: "like", description: "\\"like\\"" },\n        peg$c312 = "ilike",\n        peg$c313 = { type: "literal", value: "ilike", description: "\\"ilike\\"" },\n        peg$c314 = function(o, right) {\n        \t\tif(right.datatype !== \'string\'){\n        \t\t\terror(i18n.t(\'db.messages.parser.error-valueexpr-like-operand-no-string\'));\n        \t\t}\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: o.toLowerCase(),\n        \t\t\targs: [undefined, right],\n\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c315 = "+",\n        peg$c316 = { type: "literal", value: "+", description: "\\"+\\"" },\n        peg$c317 = function(o, right) {\n        \t\to = {\n        \t\t\t\'+\': \'add\', \n        \t\t\t\'-\': \'sub\'\n        \t\t}[o];\n        \t\t\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'number\',\n        \t\t\tfunc: o,\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c318 = "*",\n        peg$c319 = { type: "literal", value: "*", description: "\\"*\\"" },\n        peg$c320 = "%",\n        peg$c321 = { type: "literal", value: "%", description: "\\"%\\"" },\n        peg$c322 = function(o, right) {\n        \t\to = {\n        \t\t\t\'*\': \'mul\', \n        \t\t\t\'/\': \'div\',\n        \t\t\t\'%\': \'mod\'\n        \t\t}[o];\n        \t\t\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'number\',\n        \t\t\tfunc: o,\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c323 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'number\',\n        \t\t\tfunc: \'minus\',\n        \t\t\targs: [a],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c324 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: \'not\',\n        \t\t\targs: [a],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c325 = "coalesce",\n        peg$c326 = { type: "literal", value: "coalesce", description: "\\"coalesce\\"" },\n        peg$c327 = function() { return [\'coalesce\', \'null\']; },\n        peg$c328 = "concat",\n        peg$c329 = { type: "literal", value: "concat", description: "\\"concat\\"" },\n        peg$c330 = function() { return [\'concat\', \'string\']; },\n        peg$c331 = function(func, arg0, argn) {\n        \t\tvar args = [arg0];\n        \t\tfor(var i = 0; i < argn.length; i++){\n        \t\t\targs.push(argn[i][2]);\n        \t\t}\n        \t\t\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: func[1],\n        \t\t\tfunc: func[0],\n        \t\t\targs: args,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c332 = "adddate",\n        peg$c333 = { type: "literal", value: "adddate", description: "\\"adddate\\"" },\n        peg$c334 = function() { return [\'adddate\', \'date\']; },\n        peg$c335 = "subdate",\n        peg$c336 = { type: "literal", value: "subdate", description: "\\"subdate\\"" },\n        peg$c337 = function() { return [\'subdate\', \'date\']; },\n        peg$c338 = "mod",\n        peg$c339 = { type: "literal", value: "mod", description: "\\"mod\\"" },\n        peg$c340 = function() { return [\'mod\', \'number\']; },\n        peg$c341 = "add",\n        peg$c342 = { type: "literal", value: "add", description: "\\"add\\"" },\n        peg$c343 = function() { return [\'add\', \'number\']; },\n        peg$c344 = "sub",\n        peg$c345 = { type: "literal", value: "sub", description: "\\"sub\\"" },\n        peg$c346 = function() { return [\'sub\', \'number\']; },\n        peg$c347 = "mul",\n        peg$c348 = { type: "literal", value: "mul", description: "\\"mul\\"" },\n        peg$c349 = function() { return [\'mul\', \'number\']; },\n        peg$c350 = "div",\n        peg$c351 = { type: "literal", value: "div", description: "\\"div\\"" },\n        peg$c352 = function() { return [\'div\', \'number\']; },\n        peg$c353 = function(func, arg0, arg1) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: func[1],\n        \t\t\tfunc: func[0],\n        \t\t\targs: [arg0, arg1],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c354 = "upper",\n        peg$c355 = { type: "literal", value: "upper", description: "\\"upper\\"" },\n        peg$c356 = function() { return [\'upper\', \'string\']; },\n        peg$c357 = "ucase",\n        peg$c358 = { type: "literal", value: "ucase", description: "\\"ucase\\"" },\n        peg$c359 = "lower",\n        peg$c360 = { type: "literal", value: "lower", description: "\\"lower\\"" },\n        peg$c361 = function() { return [\'lower\', \'string\']; },\n        peg$c362 = "lcase",\n        peg$c363 = { type: "literal", value: "lcase", description: "\\"lcase\\"" },\n        peg$c364 = "length",\n        peg$c365 = { type: "literal", value: "length", description: "\\"length\\"" },\n        peg$c366 = function() { return [\'strlen\', \'number\']; },\n        peg$c367 = "abs",\n        peg$c368 = { type: "literal", value: "abs", description: "\\"abs\\"" },\n        peg$c369 = function() { return [\'abs\', \'number\']; },\n        peg$c370 = "floor",\n        peg$c371 = { type: "literal", value: "floor", description: "\\"floor\\"" },\n        peg$c372 = function() { return [\'floor\', \'number\']; },\n        peg$c373 = "ceil",\n        peg$c374 = { type: "literal", value: "ceil", description: "\\"ceil\\"" },\n        peg$c375 = function() { return [\'ceil\', \'number\']; },\n        peg$c376 = "round",\n        peg$c377 = { type: "literal", value: "round", description: "\\"round\\"" },\n        peg$c378 = function() { return [\'round\', \'number\']; },\n        peg$c379 = function() { return [\'date\', \'date\']; },\n        peg$c380 = "year",\n        peg$c381 = { type: "literal", value: "year", description: "\\"year\\"" },\n        peg$c382 = function() { return [\'year\', \'number\']; },\n        peg$c383 = "month",\n        peg$c384 = { type: "literal", value: "month", description: "\\"month\\"" },\n        peg$c385 = function() { return [\'month\', \'number\']; },\n        peg$c386 = "day",\n        peg$c387 = { type: "literal", value: "day", description: "\\"day\\"" },\n        peg$c388 = function() { return [\'dayofmonth\', \'number\']; },\n        peg$c389 = "hour",\n        peg$c390 = { type: "literal", value: "hour", description: "\\"hour\\"" },\n        peg$c391 = function() { return [\'hour\', \'number\']; },\n        peg$c392 = "minute",\n        peg$c393 = { type: "literal", value: "minute", description: "\\"minute\\"" },\n        peg$c394 = function() { return [\'minute\', \'number\']; },\n        peg$c395 = "second",\n        peg$c396 = { type: "literal", value: "second", description: "\\"second\\"" },\n        peg$c397 = function() { return [\'second\', \'number\']; },\n        peg$c398 = "dayofmonth",\n        peg$c399 = { type: "literal", value: "dayofmonth", description: "\\"dayofmonth\\"" },\n        peg$c400 = function(func, arg0) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: func[1],\n        \t\t\tfunc: func[0],\n        \t\t\targs: [arg0],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c401 = "rand",\n        peg$c402 = { type: "literal", value: "rand", description: "\\"rand\\"" },\n        peg$c403 = function() { return [\'rand\', \'number\']; },\n        peg$c404 = "rownum",\n        peg$c405 = { type: "literal", value: "rownum", description: "\\"rownum\\"" },\n        peg$c406 = function() { return [\'rownum\', \'number\']; },\n        peg$c407 = "now",\n        peg$c408 = { type: "literal", value: "now", description: "\\"now\\"" },\n        peg$c409 = function() { return [\'now\', \'date\']; },\n        peg$c410 = "current_timestamp",\n        peg$c411 = { type: "literal", value: "current_timestamp", description: "\\"current_timestamp\\"" },\n        peg$c412 = "transaction_timestamp",\n        peg$c413 = { type: "literal", value: "transaction_timestamp", description: "\\"transaction_timestamp\\"" },\n        peg$c414 = function() { return [\'transaction_timestamp\', \'date\']; },\n        peg$c415 = "statement_timestamp",\n        peg$c416 = { type: "literal", value: "statement_timestamp", description: "\\"statement_timestamp\\"" },\n        peg$c417 = function() { return [\'statement_timestamp\', \'date\']; },\n        peg$c418 = "clock_timestamp",\n        peg$c419 = { type: "literal", value: "clock_timestamp", description: "\\"clock_timestamp\\"" },\n        peg$c420 = function() { return [\'clock_timestamp\', \'date\']; },\n        peg$c421 = "sysdate",\n        peg$c422 = { type: "literal", value: "sysdate", description: "\\"sysdate\\"" },\n        peg$c423 = function(func) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: func[1],\n        \t\t\tfunc: func[0],\n        \t\t\targs: [],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c424 = function(v) { return [v, \'number\']; },\n        peg$c425 = function(v) { return [v, \'boolean\']; },\n        peg$c426 = function(v) { return [v, \'string\']; },\n        peg$c427 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: a[1],\n        \t\t\tfunc: \'constant\',\n        \t\t\targs: [a[0]],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c428 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'null\',\n        \t\t\tfunc: \'constant\',\n        \t\t\targs: [null],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c429 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'null\',\n        \t\t\tfunc: \'columnValue\',\n        \t\t\targs: [a.name, a.relAlias],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c430 = "case",\n        peg$c431 = { type: "literal", value: "case", description: "\\"case\\"" },\n        peg$c432 = "when",\n        peg$c433 = { type: "literal", value: "when", description: "\\"when\\"" },\n        peg$c434 = "then",\n        peg$c435 = { type: "literal", value: "then", description: "\\"then\\"" },\n        peg$c436 = function(c, r) { return {w: c, t:r} },\n        peg$c437 = "else",\n        peg$c438 = { type: "literal", value: "else", description: "\\"else\\"" },\n        peg$c439 = function(wt, r) { return r },\n        peg$c440 = "end",\n        peg$c441 = { type: "literal", value: "end", description: "\\"end\\"" },\n        peg$c442 = function(wt, e) {\n        \t\tvar args = [], i;\n        \t\tfor(i = 0; i < wt.length; i++){\n        \t\t\t// when on i%2 === 0\n        \t\t\targs.push(wt[i].w);\n        \t\t\t\n        \t\t\t// then on i%2 === 1\n        \t\t\targs.push(wt[i].t);\n        \t\t}\n        \t\t\n        \t\t// else part\n        \t\tif(e !== null){\n        \t\t\t// when on i%2 === 0\n        \t\t\t// constant true is used to give all args a unified interface\n        \t\t\targs.push({\n        \t\t\t\ttype: \'valueExpr\',\n        \t\t\t\tdatatype: \'boolean\',\n        \t\t\t\tfunc: \'constant\',\n        \t\t\t\targs: [true],\n\n        \t\t\t\tcodeInfo: getCodeInfo()\n        \t\t\t});\n        \t\t\t\n        \t\t\t// then on i%2 === 1\n        \t\t\targs.push(e);\n        \t\t}\n        \t\t\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'null\',\n        \t\t\tfunc: e === null ? \'caseWhen\' : \'caseWhenElse\',\n        \t\t\targs: args,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c443 = function(first, rest) { return buildBinaryValueExpr(first, rest); },\n        peg$c444 = "not",\n        peg$c445 = { type: "literal", value: "not", description: "\\"not\\"" },\n        peg$c446 = "natual",\n        peg$c447 = { type: "literal", value: "natual", description: "\\"natual\\"" },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$resultsCache = {},\n\n        peg$result;\n\n    if ("startRule" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error("Can\'t start parsing from rule \\"" + options.startRule + "\\".");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: "other", description: description }],\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(\n        message,\n        null,\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n          p, ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n          if (ch === "\\n") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   \'\\\\\\\\\')\n            .replace(/"/g,    \'\\\\"\')\n            .replace(/\\x08/g, \'\\\\b\')\n            .replace(/\\t/g,   \'\\\\t\')\n            .replace(/\\n/g,   \'\\\\n\')\n            .replace(/\\f/g,   \'\\\\f\')\n            .replace(/\\r/g,   \'\\\\r\')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return \'\\\\x0\' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return \'\\\\x\'  + hex(ch); })\n            .replace(/[\\u0100-\\u0FFF]/g,         function(ch) { return \'\\\\u0\' + hex(ch); })\n            .replace(/[\\u1000-\\uFFFF]/g,         function(ch) { return \'\\\\u\'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(", ")\n              + " or "\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? "\\"" + stringEscape(found) + "\\"" : "end of input";\n\n        return "Expected " + expectedDesc + " but " + foundDesc + " found.";\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 0,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseroot();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsegroupStart() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 1,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsegroupRoot();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseEOF() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 2,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c1); }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseendOfLine() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 3,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.substr(peg$currPos, 2) === peg$c2) {\n        s0 = peg$c2;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10) {\n          s0 = peg$c4;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c5); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomment() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 4,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsesingleLineComment();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsemultiLineComment();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesingleLineComment() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 5,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c7) {\n        s1 = peg$c7;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (peg$c9.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseendOfLine();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parseEOF();\n          }\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = void 0;\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c11();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c7) {\n          s1 = peg$c7;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          peg$silentFails++;\n          s3 = peg$parseendOfLine();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parseEOF();\n          }\n          peg$silentFails--;\n          if (s3 !== peg$FAILED) {\n            peg$currPos = s2;\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c11();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c7) {\n            s1 = peg$c7;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c8); }\n          }\n          if (s1 !== peg$FAILED) {\n            if (peg$c9.test(input.charAt(peg$currPos))) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c10); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$currPos;\n              s4 = [];\n              s5 = peg$currPos;\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parseendOfLine();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = void 0;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s7 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c1); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$currPos;\n                s6 = peg$currPos;\n                peg$silentFails++;\n                s7 = peg$parseendOfLine();\n                peg$silentFails--;\n                if (s7 === peg$FAILED) {\n                  s6 = void 0;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s7 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c1); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s6 = [s6, s7];\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                s3 = input.substring(s3, peg$currPos);\n              } else {\n                s3 = s4;\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$currPos;\n                peg$silentFails++;\n                s5 = peg$parseendOfLine();\n                if (s5 === peg$FAILED) {\n                  s5 = peg$parseEOF();\n                }\n                peg$silentFails--;\n                if (s5 !== peg$FAILED) {\n                  peg$currPos = s4;\n                  s4 = void 0;\n                } else {\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c12(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemultiLineComment() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 134 + 6,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c13) {\n        s1 = peg$c13;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c14); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c15) {\n          s6 = peg$c15;\n          peg$currPos += 2;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c16); }\n        }\n        peg$silentFails--;\n        if (s6 === peg$FAILED) {\n          s5 = void 0;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c1); }\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 2) === peg$c15) {\n            s6 = peg$c15;\n            peg$currPos += 2;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = void 0;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c1); }\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = input.substring(s2, peg$currPos);\n        } else {\n          s2 = s3;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c15) {\n            s3 = peg$c15;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c12(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse__() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 134 + 7,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsecomment();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsecomment();\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$c18.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c18.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c19); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          s6 = peg$parsecomment();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parsecomment();\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = [];\n          s4 = peg$parsecomment();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsecomment();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            if (peg$c18.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c19); }\n            }\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                if (peg$c18.test(input.charAt(peg$currPos))) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c19); }\n                }\n              }\n            } else {\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parsecomment();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parsecomment();\n              }\n              if (s5 !== peg$FAILED) {\n                s3 = [s3, s4, s5];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c11();\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c17); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 8,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = [];\n      s1 = peg$parsecomment();\n      if (s1 === peg$FAILED) {\n        if (peg$c18.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsecomment();\n        if (s1 === peg$FAILED) {\n          if (peg$c18.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c19); }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c20); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse__nc() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 9,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = [];\n      if (peg$c22.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c22.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c23); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_nc() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 10,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = [];\n      if (peg$c22.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c22.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c23); }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse__sl() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 134 + 11,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsecomment();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsecomment();\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$c9.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c9.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c10); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          s6 = peg$parsecomment();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parsecomment();\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = [];\n          s4 = peg$parsecomment();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsecomment();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            if (peg$c9.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c10); }\n            }\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                if (peg$c9.test(input.charAt(peg$currPos))) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                }\n              }\n            } else {\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parsecomment();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parsecomment();\n              }\n              if (s5 !== peg$FAILED) {\n                s3 = [s3, s4, s5];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c11();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_sl() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 12,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsecomment();\n      if (s2 === peg$FAILED) {\n        if (peg$c9.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n        }\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsecomment();\n        if (s2 === peg$FAILED) {\n          if (peg$c9.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c10); }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c11();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 13,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c26;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c27); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = [];\n        if (peg$c28.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c29); }\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c28.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c29); }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = input.substring(s2, peg$currPos);\n        } else {\n          s2 = s3;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 39) {\n            s3 = peg$c26;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c27); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c30(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinteger() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 134 + 14,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s3 = peg$c31;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$c33.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c34); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c33.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c34); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c35(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefloat() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 15,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s3 = peg$c31;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$c33.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c34); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c33.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c34); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s5 = peg$c36;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c37); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = [];\n            if (peg$c33.test(input.charAt(peg$currPos))) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c34); }\n            }\n            if (s7 !== peg$FAILED) {\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                if (peg$c33.test(input.charAt(peg$currPos))) {\n                  s7 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c34); }\n                }\n              }\n            } else {\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s3 = [s3, s4, s5, s6];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c38(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 16,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsefloat();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseinteger();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedateIso() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 134 + 17,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (peg$c33.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c34); }\n      }\n      if (s3 !== peg$FAILED) {\n        if (peg$c33.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c34); }\n        }\n        if (s4 !== peg$FAILED) {\n          if (peg$c33.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c34); }\n          }\n          if (s5 !== peg$FAILED) {\n            if (peg$c33.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c34); }\n            }\n            if (s6 !== peg$FAILED) {\n              s3 = [s3, s4, s5, s6];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c31;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c32); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          if (peg$c33.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c34); }\n          }\n          if (s5 !== peg$FAILED) {\n            if (peg$c33.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c34); }\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = input.substring(s3, peg$currPos);\n          } else {\n            s3 = s4;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s4 = peg$c31;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c32); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              s6 = peg$currPos;\n              if (peg$c33.test(input.charAt(peg$currPos))) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c34); }\n              }\n              if (s7 !== peg$FAILED) {\n                if (peg$c33.test(input.charAt(peg$currPos))) {\n                  s8 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c34); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s7 = [s7, s8];\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                s5 = input.substring(s5, peg$currPos);\n              } else {\n                s5 = s6;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c40(s1, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c39); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseboolean() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 18,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c41) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c43();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c44) {\n          s1 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c45); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c46();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseassignmentOperator() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 19,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c47;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserelationName() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 20,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$currPos;\n      s3 = peg$parseRESERVED_KEYWORD_RELALG();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = [];\n        if (peg$c50.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s6 !== peg$FAILED) {\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c51); }\n            }\n          }\n        } else {\n          s5 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = void 0;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        s4 = [];\n        if (peg$c52.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c53); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c52.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          s6 = [];\n          if (peg$c50.test(input.charAt(peg$currPos))) {\n            s7 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c51); }\n          }\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c51); }\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = input.substring(s5, peg$currPos);\n          } else {\n            s5 = s6;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = input.substring(s2, peg$currPos);\n        } else {\n          s2 = s3;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c54(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c49); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunqualifiedColumnName() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 21,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$currPos;\n      s3 = peg$parseRESERVED_KEYWORD_RELALG();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = [];\n        if (peg$c50.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s6 !== peg$FAILED) {\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c51); }\n            }\n          }\n        } else {\n          s5 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = void 0;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        s4 = [];\n        if (peg$c52.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c53); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c52.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          s6 = [];\n          if (peg$c50.test(input.charAt(peg$currPos))) {\n            s7 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c51); }\n          }\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c51); }\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = input.substring(s5, peg$currPos);\n          } else {\n            s5 = s6;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = input.substring(s2, peg$currPos);\n        } else {\n          s2 = s3;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c54(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecolumnName() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 134 + 22,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parserelationName();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c36;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseunqualifiedColumnName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c55(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parserelationName();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s3 = peg$c36;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c37); }\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s2 = peg$c56;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c57); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$currPos;\n            s4 = [];\n            if (peg$c33.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c34); }\n            }\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                if (peg$c33.test(input.charAt(peg$currPos))) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c34); }\n                }\n              }\n            } else {\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = input.substring(s3, peg$currPos);\n            } else {\n              s3 = s4;\n            }\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s4 = peg$c58;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c59); }\n              }\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c60(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepi() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 23,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 960) {\n          s2 = peg$c61;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c62); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2).toLowerCase() === peg$c63) {\n            s2 = input.substr(peg$currPos, 2);\n            peg$currPos += 2;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c64); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesigma() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 24,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 963) {\n          s2 = peg$c65;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c66); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c67) {\n            s2 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c68); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserho() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 25,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 961) {\n          s2 = peg$c69;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c70); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c71) {\n            s2 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c72); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsearrowLeft() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 26,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.charCodeAt(peg$currPos) === 8592) {\n        s0 = peg$c73;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c75) {\n            s2 = peg$c75;\n            peg$currPos += 2;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c76); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsearrowRight() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 27,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 8594) {\n          s2 = peg$c77;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c78); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c79) {\n            s2 = peg$c79;\n            peg$currPos += 2;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c80); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepsi() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 28,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 968) {\n          s2 = peg$c81;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {\n            s2 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c84); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetau() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 29,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 964) {\n          s2 = peg$c85;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c86); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c87) {\n            s2 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c88); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsegamma() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 30,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 947) {\n          s2 = peg$c89;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c90); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c91) {\n            s2 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c92); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunionOperator() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 31,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 8746) {\n          s2 = peg$c93;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c94); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c95) {\n            s2 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c96); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseintersectOperator() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 32,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 8745) {\n          s2 = peg$c97;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c98); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 9).toLowerCase() === peg$c99) {\n            s2 = input.substr(peg$currPos, 9);\n            peg$currPos += 9;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c100); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedivisionOperator() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 33,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 247) {\n          s2 = peg$c101;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c102); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s2 = peg$c103;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c104); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedifferenceOperator() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 34,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c31;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c32); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s2 = peg$c105;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c106); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse__();\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c107) {\n              s2 = input.substr(peg$currPos, 6);\n              peg$currPos += 6;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c108); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse__();\n              if (s3 !== peg$FAILED) {\n                s1 = [s1, s2, s3];\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecross() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 134 + 35,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10799) {\n          s2 = peg$c109;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c110); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 120) {\n            s2 = peg$c111;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c112); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse__();\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c113) {\n              s2 = input.substr(peg$currPos, 5);\n              peg$currPos += 5;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c114); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse__();\n              if (s3 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                  s4 = input.substr(peg$currPos, 4);\n                  peg$currPos += 4;\n                } else {\n                  s4 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse__();\n                  if (s5 !== peg$FAILED) {\n                    s1 = [s1, s2, s3, s4, s5];\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinner() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 36,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10781) {\n          s2 = peg$c117;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c118); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8904) {\n            s2 = peg$c119;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c120); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse__();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c121) {\n              s3 = input.substr(peg$currPos, 5);\n              peg$currPos += 5;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c122); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse__();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = null;\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                s3 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c116); }\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse__();\n                if (s4 !== peg$FAILED) {\n                  s1 = [s1, s2, s3, s4];\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenaturalJoinOperator() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 37,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10781) {\n          s2 = peg$c117;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c118); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8904) {\n            s2 = peg$c119;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c120); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse__();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c123) {\n              s3 = input.substr(peg$currPos, 7);\n              peg$currPos += 7;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c124); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse__();\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = null;\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                s3 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c116); }\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse__();\n                if (s4 !== peg$FAILED) {\n                  s1 = [s1, s2, s3, s4];\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseleftSemiJoinOperator() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 38,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 8905) {\n          s2 = peg$c125;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c126); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c127) {\n            s2 = input.substr(peg$currPos, 4);\n            peg$currPos += 4;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c128); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {\n                s4 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c130); }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parse__();\n                if (s5 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                    s6 = input.substr(peg$currPos, 4);\n                    peg$currPos += 4;\n                  } else {\n                    s6 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                  }\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parse__();\n                    if (s7 !== peg$FAILED) {\n                      s1 = [s1, s2, s3, s4, s5, s6, s7];\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserightSemiJoinOperator() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 39,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 8906) {\n          s2 = peg$c131;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c132); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c133) {\n            s2 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c134); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse__();\n            if (s3 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {\n                s4 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c130); }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parse__();\n                if (s5 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                    s6 = input.substr(peg$currPos, 4);\n                    peg$currPos += 4;\n                  } else {\n                    s6 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                  }\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parse__();\n                    if (s7 !== peg$FAILED) {\n                      s1 = [s1, s2, s3, s4, s5, s6, s7];\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseantiJoinOperator() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 134 + 40,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 9655) {\n          s2 = peg$c135;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c136); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c137) {\n            s2 = input.substr(peg$currPos, 4);\n            peg$currPos += 4;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c138); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$currPos;\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {\n                s5 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c130); }\n              }\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse__();\n              if (s4 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                  s5 = input.substr(peg$currPos, 4);\n                  peg$currPos += 4;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse__();\n                  if (s6 !== peg$FAILED) {\n                    s1 = [s1, s2, s3, s4, s5, s6];\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseleftOuterJoinOperator() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 134 + 41,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10197) {\n          s2 = peg$c139;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c140); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c127) {\n            s2 = input.substr(peg$currPos, 4);\n            peg$currPos += 4;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c128); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$currPos;\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c141) {\n                s5 = input.substr(peg$currPos, 5);\n                peg$currPos += 5;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c142); }\n              }\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse__();\n              if (s4 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                  s5 = input.substr(peg$currPos, 4);\n                  peg$currPos += 4;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse__();\n                  if (s6 !== peg$FAILED) {\n                    s1 = [s1, s2, s3, s4, s5, s6];\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserightOuterJoinOperator() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 134 + 42,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10198) {\n          s2 = peg$c143;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c144); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c133) {\n            s2 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c134); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$currPos;\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c141) {\n                s5 = input.substr(peg$currPos, 5);\n                peg$currPos += 5;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c142); }\n              }\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse__();\n              if (s4 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                  s5 = input.substr(peg$currPos, 4);\n                  peg$currPos += 4;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse__();\n                  if (s6 !== peg$FAILED) {\n                    s1 = [s1, s2, s3, s4, s5, s6];\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefullOuterJoinOperator() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 134 + 43,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10199) {\n          s2 = peg$c145;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c146); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c147) {\n            s2 = input.substr(peg$currPos, 4);\n            peg$currPos += 4;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c148); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$currPos;\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c141) {\n                s5 = input.substr(peg$currPos, 5);\n                peg$currPos += 5;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c142); }\n              }\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse__();\n              if (s4 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                  s5 = input.substr(peg$currPos, 4);\n                  peg$currPos += 4;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse__();\n                  if (s6 !== peg$FAILED) {\n                    s1 = [s1, s2, s3, s4, s5, s6];\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseassignment() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 44,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parserelationName();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$c149(s1);\n        if (s2) {\n          s2 = peg$FAILED;\n        } else {\n          s2 = void 0;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseassignmentOperator();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpression_precedence4();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c150(s1, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenamedColumnExpr() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 45,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence9();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsearrowRight();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseunqualifiedColumnName();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c151(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseunqualifiedColumnName();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsearrowLeft();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseexpr_precedence9();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c152(s1, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsecolumnName();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c54(s1);\n          }\n          s0 = s1;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselistOfNamedColumnExpressions() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 46,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenamedColumnExpr();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c153;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c154); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsenamedColumnExpr();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c153;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c154); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsenamedColumnExpr();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c155(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselistOfColumns() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 47,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecolumnName();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c153;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c154); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsecolumnName();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c153;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c154); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsecolumnName();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c155(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecolAssignment() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 48,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseunqualifiedColumnName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsearrowLeft();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsecolumnName();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c156(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsecolumnName();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsearrowRight();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseunqualifiedColumnName();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c157(s1, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselistOfColAssignments() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 49,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecolAssignment();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c153;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c154); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsecolAssignment();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c153;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c154); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsecolAssignment();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c158(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseorderDirection() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 50,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c159) {\n        s1 = input.substr(peg$currPos, 3);\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c160); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c43();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c161) {\n          s1 = input.substr(peg$currPos, 4);\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c162); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c46();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseorderByArg() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 51,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecolumnName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseorderDirection();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c163(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselistOfOrderByArgs() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 52,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseorderByArg();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c153;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c154); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseorderByArg();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c153;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c154); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseorderByArg();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c158(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseaggFunction() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 134 + 53,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c164) {\n        s2 = input.substr(peg$currPos, 3);\n        peg$currPos += 3;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c165); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c166) {\n          s2 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c167); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c168) {\n            s2 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c169); }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c170) {\n              s2 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c171); }\n            }\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c172) {\n                s2 = input.substr(peg$currPos, 3);\n                peg$currPos += 3;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c173); }\n              }\n            }\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c174;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c175); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsecolumnName();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s6 = peg$c176;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c177); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c178(s1, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c179) {\n          s1 = input.substr(peg$currPos, 8);\n          peg$currPos += 8;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c180); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c181();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseaggFunctionArgument() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 54,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseaggFunction();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsearrowRight();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseunqualifiedColumnName();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c182(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseunqualifiedColumnName();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsearrowLeft();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseaggFunction();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c183(s1, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselistOfAggFunctionArguments() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 134 + 55,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseaggFunctionArgument();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c153;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c154); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseaggFunctionArgument();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c153;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c154); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseaggFunctionArgument();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c155(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsebooleanExprWithTrailingWhitspace() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 56,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsebooleanExpr();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = peg$currPos;\n          s3 = peg$c184(s1);\n          if (s3) {\n            s3 = void 0;\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c30(s1);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 134 + 57,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parseassignment();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse__();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parseassignment();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse__();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseassignment();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c185(s2, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$parseassignment();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse__();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$parseassignment();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseexpression_precedence4();\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c186(s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsegroupRoot() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 134 + 58,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_nc();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_nc();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsetableGroup();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$parse_nc();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsetableGroup();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_nc();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c187(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetableGroupHeaders() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 134 + 59,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsetableGroupHeader();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsetableGroupHeader();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetableGroupHeader();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c188(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetableGroupHeader() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 134 + 60,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$currPos;\n      s3 = [];\n      if (peg$c189.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c190); }\n      }\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c189.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c190); }\n          }\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s4 = peg$c191;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c192); }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s2 !== peg$FAILED) {\n        peg$currPos = s1;\n        s1 = void 0;\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = [];\n        if (peg$c189.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c190); }\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c189.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c190); }\n            }\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = input.substring(s2, peg$currPos);\n        } else {\n          s2 = s3;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s3 = peg$c191;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c192); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = [];\n            s6 = peg$currPos;\n            s7 = peg$currPos;\n            peg$silentFails++;\n            s8 = peg$parseendOfLine();\n            peg$silentFails--;\n            if (s8 === peg$FAILED) {\n              s7 = void 0;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            if (s7 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s8 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c1); }\n              }\n              if (s8 !== peg$FAILED) {\n                s7 = [s7, s8];\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$currPos;\n              s7 = peg$currPos;\n              peg$silentFails++;\n              s8 = peg$parseendOfLine();\n              peg$silentFails--;\n              if (s8 === peg$FAILED) {\n                s7 = void 0;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s8 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c1); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s7 = [s7, s8];\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = input.substring(s4, peg$currPos);\n            } else {\n              s4 = s5;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c193(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        s2 = peg$currPos;\n        s3 = [];\n        if (peg$c189.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c190); }\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c189.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c190); }\n            }\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c194) {\n            s4 = peg$c194;\n            peg$currPos += 2;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c195); }\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s2 !== peg$FAILED) {\n          peg$currPos = s1;\n          s1 = void 0;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = [];\n          if (peg$c189.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c190); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c189.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c190); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = input.substring(s2, peg$currPos);\n          } else {\n            s2 = s3;\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c194) {\n              s3 = peg$c194;\n              peg$currPos += 2;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c195); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$currPos;\n              s5 = [];\n              if (input.substr(peg$currPos, 3) === peg$c196) {\n                s6 = peg$c196;\n                peg$currPos += 3;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c197); }\n              }\n              if (s6 === peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$currPos;\n                peg$silentFails++;\n                if (input.substr(peg$currPos, 2) === peg$c198) {\n                  s8 = peg$c198;\n                  peg$currPos += 2;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c199); }\n                }\n                peg$silentFails--;\n                if (s8 === peg$FAILED) {\n                  s7 = void 0;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                if (s7 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s8 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c1); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s7 = [s7, s8];\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              }\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                if (input.substr(peg$currPos, 3) === peg$c196) {\n                  s6 = peg$c196;\n                  peg$currPos += 3;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c197); }\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = peg$currPos;\n                  s7 = peg$currPos;\n                  peg$silentFails++;\n                  if (input.substr(peg$currPos, 2) === peg$c198) {\n                    s8 = peg$c198;\n                    peg$currPos += 2;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c199); }\n                  }\n                  peg$silentFails--;\n                  if (s8 === peg$FAILED) {\n                    s7 = void 0;\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s8 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c1); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      s7 = [s7, s8];\n                      s6 = s7;\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s4 = input.substring(s4, peg$currPos);\n              } else {\n                s4 = s5;\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c198) {\n                  s5 = peg$c198;\n                  peg$currPos += 2;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c199); }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c200(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetableGroup() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 134 + 61,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsetableGroupHeaders();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          s5 = peg$parse__();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseassignment();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$currPos;\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseassignment();\n                if (s6 !== peg$FAILED) {\n                  s5 = [s5, s6];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c201(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpression_precedence4() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 62,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpression_precedence3();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseunion();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsedifference();\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseunion();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsedifference();\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c202(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpression_precedence3();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpression_precedence3() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 63,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpression_precedence2();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseintersect();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseintersect();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c202(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpression_precedence2();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpression_precedence2() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 64,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpression_precedence1();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsecrossJoin();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsethetaJoin();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsenaturalJoin();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parseleftOuterJoin();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parserightOuterJoin();\n                if (s3 === peg$FAILED) {\n                  s3 = peg$parsefullOuterJoin();\n                  if (s3 === peg$FAILED) {\n                    s3 = peg$parseleftSemiJoin();\n                    if (s3 === peg$FAILED) {\n                      s3 = peg$parserightSemiJoin();\n                      if (s3 === peg$FAILED) {\n                        s3 = peg$parseantiJoin();\n                        if (s3 === peg$FAILED) {\n                          s3 = peg$parsedivision();\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsecrossJoin();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsethetaJoin();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parsenaturalJoin();\n                if (s3 === peg$FAILED) {\n                  s3 = peg$parseleftOuterJoin();\n                  if (s3 === peg$FAILED) {\n                    s3 = peg$parserightOuterJoin();\n                    if (s3 === peg$FAILED) {\n                      s3 = peg$parsefullOuterJoin();\n                      if (s3 === peg$FAILED) {\n                        s3 = peg$parseleftSemiJoin();\n                        if (s3 === peg$FAILED) {\n                          s3 = peg$parserightSemiJoin();\n                          if (s3 === peg$FAILED) {\n                            s3 = peg$parseantiJoin();\n                            if (s3 === peg$FAILED) {\n                              s3 = peg$parsedivision();\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c202(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpression_precedence1();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpression_precedence1() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 65,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parseorderBy();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsegroupBy();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parserenameRelation();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parserenameColumns();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseselection();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseprojection();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseexpression_precedence0();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpression_precedence0() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 134 + 66,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsetable();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parserelation();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s1 = peg$c174;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c175); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseexpression_precedence4();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c176;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c177); }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c203(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseintersect() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 67,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseintersectOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpression_precedence2();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c204(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunion() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 68,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseunionOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpression_precedence3();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c205(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedifference() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 69,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsedifferenceOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpression_precedence3();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c206(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecrossJoin() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 70,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecross();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpression_precedence1();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c207(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsethetaJoin() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 71,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseinner();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebooleanExprWithTrailingWhitspace();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseexpression_precedence1();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c208(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenaturalJoin() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 72,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenaturalJoinOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpression_precedence1();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c209(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseleftOuterJoin() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 73,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseleftOuterJoinOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebooleanExprWithTrailingWhitspace();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseexpression_precedence1();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c210(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserightOuterJoin() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 74,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parserightOuterJoinOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebooleanExprWithTrailingWhitspace();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseexpression_precedence1();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c211(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefullOuterJoin() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 75,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsefullOuterJoinOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebooleanExprWithTrailingWhitspace();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseexpression_precedence1();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c212(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseleftSemiJoin() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 76,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseleftSemiJoinOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpression_precedence1();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c213(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserightSemiJoin() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 77,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parserightSemiJoinOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpression_precedence1();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c214(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseantiJoin() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 78,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseantiJoinOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpression_precedence1();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c215(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedivision() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 79,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsedivisionOperator();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpression_precedence1();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c216(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseprojection() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 80,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsepi();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselistOfNamedColumnExpressions();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpression_precedence1();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c217(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselection() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 81,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsesigma();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebooleanExpr();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpression_precedence1();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c218(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserenameColumns() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 82,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parserho();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselistOfColAssignments();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpression_precedence1();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c219(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserenameRelation() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 83,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parserho();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parserelationName();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpression_precedence1();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c220(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsegroupBy() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 134 + 84,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsegamma();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselistOfColumns();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 59) {\n              s4 = peg$c221;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c222); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parselistOfAggFunctionArguments();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse__();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parseexpression_precedence1();\n                    if (s8 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c223(s2, s6, s8);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsegamma();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 59) {\n              s4 = peg$c221;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c222); }\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = [s3, s4];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n          if (s2 === peg$FAILED) {\n            s2 = null;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parselistOfAggFunctionArguments();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parse__();\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parseexpression_precedence1();\n                  if (s6 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c224(s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseorderBy() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 85,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsetau();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselistOfOrderByArgs();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpression_precedence1();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c225(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserelation() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 86,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parserelationName();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c226(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperators() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 87,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsecomparisonOperatorEquals();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsecomparisonOperatorNotEquals();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsecomparisonOperatorGreaterEquals();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsecomparisonOperatorLesserEquals();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsecomparisonOperatorGreater();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsecomparisonOperatorLesser();\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorsIsOrIsNot() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 88,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsecomparisonOperatorEquals();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsecomparisonOperatorNotEquals();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorEquals() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 89,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s0 = peg$c47;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorNotEquals() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 90,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c227) {\n        s1 = peg$c227;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c228); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 8800) {\n          s1 = peg$c229;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c230); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c231) {\n            s1 = peg$c231;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c232); }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c233();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorGreaterEquals() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 91,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c234) {\n        s1 = peg$c234;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c235); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 8805) {\n          s1 = peg$c236;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c237); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c238();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorGreater() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 92,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.charCodeAt(peg$currPos) === 62) {\n        s0 = peg$c239;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c240); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorLesserEquals() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 93,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c241) {\n        s1 = peg$c241;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c242); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 8804) {\n          s1 = peg$c243;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c244); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c245();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorLesser() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 94,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.charCodeAt(peg$currPos) === 60) {\n        s0 = peg$c246;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c247); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseand() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 95,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c249) {\n          s2 = input.substr(peg$currPos, 3);\n          peg$currPos += 3;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c250); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8743) {\n            s2 = peg$c251;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c252); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c248); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsexor() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 96,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c254) {\n          s2 = input.substr(peg$currPos, 3);\n          peg$currPos += 3;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c255); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8891) {\n            s2 = peg$c256;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c257); }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 8853) {\n              s2 = peg$c258;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c259); }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c253); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseor() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 97,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c261) {\n          s2 = input.substr(peg$currPos, 2);\n          peg$currPos += 2;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c262); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8744) {\n            s2 = peg$c263;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c264); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c260); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenot() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 98,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s2 = peg$c266;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c267); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 172) {\n            s2 = peg$c268;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c269); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c265); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetableDelimiter() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 99,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse_sl();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c153;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c154); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_sl();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_sl();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 59) {\n            s2 = peg$c221;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c222); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_sl();\n            if (s3 !== peg$FAILED) {\n              s1 = [s1, s2, s3];\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$parse__sl();\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c270); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetableColumnName() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 100,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecolumnName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c191;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c192); }\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 6).toLowerCase() === peg$c271) {\n            s4 = input.substr(peg$currPos, 6);\n            peg$currPos += 6;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c272); }\n          }\n          if (s4 === peg$FAILED) {\n            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c273) {\n              s4 = input.substr(peg$currPos, 6);\n              peg$currPos += 6;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c274); }\n            }\n            if (s4 === peg$FAILED) {\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c275) {\n                s4 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c276); }\n              }\n              if (s4 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7).toLowerCase() === peg$c277) {\n                  s4 = input.substr(peg$currPos, 7);\n                  peg$currPos += 7;\n                } else {\n                  s4 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c278); }\n                }\n              }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c279(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetableValue() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 101,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsedateIso();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c280(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 4) === peg$c281) {\n          s1 = peg$c281;\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c282); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.substr(peg$currPos, 4) === peg$c283) {\n            s1 = peg$c283;\n            peg$currPos += 4;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c284); }\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c285();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseboolean();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            peg$silentFails++;\n            s3 = peg$parsetableDelimiter();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parseendOfLine();\n              if (s3 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 125) {\n                  s3 = peg$c286;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c287); }\n                }\n              }\n            }\n            peg$silentFails--;\n            if (s3 !== peg$FAILED) {\n              peg$currPos = s2;\n              s2 = void 0;\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c288(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$currPos;\n            s2 = [];\n            if (peg$c289.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c290); }\n            }\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                if (peg$c289.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c290); }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = input.substring(s1, peg$currPos);\n            } else {\n              s1 = s2;\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c291(s1);\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 39) {\n                s1 = peg$c26;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c27); }\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = peg$currPos;\n                s3 = [];\n                if (peg$c28.test(input.charAt(peg$currPos))) {\n                  s4 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c29); }\n                }\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n                  if (peg$c28.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c29); }\n                  }\n                }\n                if (s3 !== peg$FAILED) {\n                  s2 = input.substring(s2, peg$currPos);\n                } else {\n                  s2 = s3;\n                }\n                if (s2 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 39) {\n                    s3 = peg$c26;\n                    peg$currPos++;\n                  } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c27); }\n                  }\n                  if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c292(s2);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 34) {\n                  s1 = peg$c293;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c294); }\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$currPos;\n                  s3 = [];\n                  if (peg$c295.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c296); }\n                  }\n                  while (s4 !== peg$FAILED) {\n                    s3.push(s4);\n                    if (peg$c295.test(input.charAt(peg$currPos))) {\n                      s4 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s4 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c296); }\n                    }\n                  }\n                  if (s3 !== peg$FAILED) {\n                    s2 = input.substring(s2, peg$currPos);\n                  } else {\n                    s2 = s3;\n                  }\n                  if (s2 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 34) {\n                      s3 = peg$c293;\n                      peg$currPos++;\n                    } else {\n                      s3 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c294); }\n                    }\n                    if (s3 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c292(s2);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetableHeader() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 134 + 102,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsetableColumnName();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parsetableDelimiter();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsetableColumnName();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsetableDelimiter();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetableColumnName();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c297(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetableRow() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 134 + 103,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsetableValue();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parsetableDelimiter();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsetableValue();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsetableDelimiter();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetableValue();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c298(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetable() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n      var key    = peg$currPos * 134 + 104,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c299;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c300); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsetableHeader();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_sl();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$currPos;\n              s7 = peg$parseendOfLine();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parse_();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parsetableRow();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parse_sl();\n                    if (s10 !== peg$FAILED) {\n                      s7 = [s7, s8, s9, s10];\n                      s6 = s7;\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$currPos;\n                s7 = peg$parseendOfLine();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsetableRow();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse_sl();\n                      if (s10 !== peg$FAILED) {\n                        s7 = [s7, s8, s9, s10];\n                        s6 = s7;\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 125) {\n                    s7 = peg$c286;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c287); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c301(s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsebooleanExpr() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 105,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$parseexpr_precedence9();\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c302); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_boolean_disj() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 106,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseor();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr_precedence8();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c303(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_string_concat() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 107,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c304) {\n          s2 = peg$c304;\n          peg$currPos += 2;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c305); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence8();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c306(s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_boolean_xdisj() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 108,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsexor();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr_precedence7();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c307(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_boolean_conj() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 109,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseand();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr_precedence6();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c308(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_boolean_comparison() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 110,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsecomparisonOperatorsIsOrIsNot();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsevalueExprConstantNull();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c309(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsecomparisonOperators();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseexpr_precedence4();\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c309(s2, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c310) {\n              s2 = input.substr(peg$currPos, 4);\n              peg$currPos += 4;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c311); }\n            }\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c312) {\n                s2 = input.substr(peg$currPos, 5);\n                peg$currPos += 5;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c313); }\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parsevalueExprConstants();\n                if (s4 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c314(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_number_add() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 111,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c31;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c32); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 43) {\n            s2 = peg$c315;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c316); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence3();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c317(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_number_mul() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 112,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s2 = peg$c318;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c319); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s2 = peg$c103;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c104); }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 37) {\n              s2 = peg$c320;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c321); }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence2();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c322(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_number_minus() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 113,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c31;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c32); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseexpr_precedence1();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c323(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_boolean_negation() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 114,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenot();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr_precedence0();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c324(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprFunctionsNary() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      var key    = peg$currPos * 134 + 115,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c325) {\n        s2 = input.substr(peg$currPos, 8);\n        peg$currPos += 8;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c326); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c327();\n      }\n      s1 = s2;\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c328) {\n          s2 = input.substr(peg$currPos, 6);\n          peg$currPos += 6;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c329); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c330();\n        }\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c174;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c175); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence9();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = [];\n                s7 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s8 = peg$c153;\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c154); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parse_();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parseexpr_precedence9();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parse_();\n                      if (s11 !== peg$FAILED) {\n                        s8 = [s8, s9, s10, s11];\n                        s7 = s8;\n                      } else {\n                        peg$currPos = s7;\n                        s7 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                while (s7 !== peg$FAILED) {\n                  s6.push(s7);\n                  s7 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s8 = peg$c153;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c154); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parse_();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parseexpr_precedence9();\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parse_();\n                        if (s11 !== peg$FAILED) {\n                          s8 = [s8, s9, s10, s11];\n                          s7 = s8;\n                        } else {\n                          peg$currPos = s7;\n                          s7 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s7;\n                        s7 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s7 = peg$c176;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c177); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c331(s1, s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprFunctionsBinary() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n      var key    = peg$currPos * 134 + 116,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c332) {\n        s2 = input.substr(peg$currPos, 7);\n        peg$currPos += 7;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c333); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c334();\n      }\n      s1 = s2;\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c335) {\n          s2 = input.substr(peg$currPos, 7);\n          peg$currPos += 7;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c336); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c337();\n        }\n        s1 = s2;\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c338) {\n            s2 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c339); }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c340();\n          }\n          s1 = s2;\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c341) {\n              s2 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c342); }\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s2 = peg$c343();\n            }\n            s1 = s2;\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c344) {\n                s2 = input.substr(peg$currPos, 3);\n                peg$currPos += 3;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c345); }\n              }\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s2 = peg$c346();\n              }\n              s1 = s2;\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c347) {\n                  s2 = input.substr(peg$currPos, 3);\n                  peg$currPos += 3;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c348); }\n                }\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s1;\n                  s2 = peg$c349();\n                }\n                s1 = s2;\n                if (s1 === peg$FAILED) {\n                  s1 = peg$currPos;\n                  if (input.substr(peg$currPos, 3).toLowerCase() === peg$c350) {\n                    s2 = input.substr(peg$currPos, 3);\n                    peg$currPos += 3;\n                  } else {\n                    s2 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c351); }\n                  }\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s1;\n                    s2 = peg$c352();\n                  }\n                  s1 = s2;\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c174;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c175); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence9();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s6 = peg$c153;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c154); }\n                }\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parseexpr_precedence9();\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parse_();\n                      if (s9 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 41) {\n                          s10 = peg$c176;\n                          peg$currPos++;\n                        } else {\n                          s10 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c177); }\n                        }\n                        if (s10 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c353(s1, s4, s8);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprFunctionsUnary() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 134 + 117,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c354) {\n        s2 = input.substr(peg$currPos, 5);\n        peg$currPos += 5;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c355); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c356();\n      }\n      s1 = s2;\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c357) {\n          s2 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c358); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c356();\n        }\n        s1 = s2;\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c359) {\n            s2 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c360); }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c361();\n          }\n          s1 = s2;\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c362) {\n              s2 = input.substr(peg$currPos, 5);\n              peg$currPos += 5;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c363); }\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s2 = peg$c361();\n            }\n            s1 = s2;\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              if (input.substr(peg$currPos, 6).toLowerCase() === peg$c364) {\n                s2 = input.substr(peg$currPos, 6);\n                peg$currPos += 6;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c365); }\n              }\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s2 = peg$c366();\n              }\n              s1 = s2;\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c367) {\n                  s2 = input.substr(peg$currPos, 3);\n                  peg$currPos += 3;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c368); }\n                }\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s1;\n                  s2 = peg$c369();\n                }\n                s1 = s2;\n                if (s1 === peg$FAILED) {\n                  s1 = peg$currPos;\n                  if (input.substr(peg$currPos, 5).toLowerCase() === peg$c370) {\n                    s2 = input.substr(peg$currPos, 5);\n                    peg$currPos += 5;\n                  } else {\n                    s2 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c371); }\n                  }\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s1;\n                    s2 = peg$c372();\n                  }\n                  s1 = s2;\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$currPos;\n                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c373) {\n                      s2 = input.substr(peg$currPos, 4);\n                      peg$currPos += 4;\n                    } else {\n                      s2 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c374); }\n                    }\n                    if (s2 !== peg$FAILED) {\n                      peg$savedPos = s1;\n                      s2 = peg$c375();\n                    }\n                    s1 = s2;\n                    if (s1 === peg$FAILED) {\n                      s1 = peg$currPos;\n                      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c376) {\n                        s2 = input.substr(peg$currPos, 5);\n                        peg$currPos += 5;\n                      } else {\n                        s2 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c377); }\n                      }\n                      if (s2 !== peg$FAILED) {\n                        peg$savedPos = s1;\n                        s2 = peg$c378();\n                      }\n                      s1 = s2;\n                      if (s1 === peg$FAILED) {\n                        s1 = peg$currPos;\n                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c275) {\n                          s2 = input.substr(peg$currPos, 4);\n                          peg$currPos += 4;\n                        } else {\n                          s2 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c276); }\n                        }\n                        if (s2 !== peg$FAILED) {\n                          peg$savedPos = s1;\n                          s2 = peg$c379();\n                        }\n                        s1 = s2;\n                        if (s1 === peg$FAILED) {\n                          s1 = peg$currPos;\n                          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c380) {\n                            s2 = input.substr(peg$currPos, 4);\n                            peg$currPos += 4;\n                          } else {\n                            s2 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c381); }\n                          }\n                          if (s2 !== peg$FAILED) {\n                            peg$savedPos = s1;\n                            s2 = peg$c382();\n                          }\n                          s1 = s2;\n                          if (s1 === peg$FAILED) {\n                            s1 = peg$currPos;\n                            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c383) {\n                              s2 = input.substr(peg$currPos, 5);\n                              peg$currPos += 5;\n                            } else {\n                              s2 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c384); }\n                            }\n                            if (s2 !== peg$FAILED) {\n                              peg$savedPos = s1;\n                              s2 = peg$c385();\n                            }\n                            s1 = s2;\n                            if (s1 === peg$FAILED) {\n                              s1 = peg$currPos;\n                              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c386) {\n                                s2 = input.substr(peg$currPos, 3);\n                                peg$currPos += 3;\n                              } else {\n                                s2 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c387); }\n                              }\n                              if (s2 !== peg$FAILED) {\n                                peg$savedPos = s1;\n                                s2 = peg$c388();\n                              }\n                              s1 = s2;\n                              if (s1 === peg$FAILED) {\n                                s1 = peg$currPos;\n                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c389) {\n                                  s2 = input.substr(peg$currPos, 4);\n                                  peg$currPos += 4;\n                                } else {\n                                  s2 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c390); }\n                                }\n                                if (s2 !== peg$FAILED) {\n                                  peg$savedPos = s1;\n                                  s2 = peg$c391();\n                                }\n                                s1 = s2;\n                                if (s1 === peg$FAILED) {\n                                  s1 = peg$currPos;\n                                  if (input.substr(peg$currPos, 6).toLowerCase() === peg$c392) {\n                                    s2 = input.substr(peg$currPos, 6);\n                                    peg$currPos += 6;\n                                  } else {\n                                    s2 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c393); }\n                                  }\n                                  if (s2 !== peg$FAILED) {\n                                    peg$savedPos = s1;\n                                    s2 = peg$c394();\n                                  }\n                                  s1 = s2;\n                                  if (s1 === peg$FAILED) {\n                                    s1 = peg$currPos;\n                                    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c395) {\n                                      s2 = input.substr(peg$currPos, 6);\n                                      peg$currPos += 6;\n                                    } else {\n                                      s2 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c396); }\n                                    }\n                                    if (s2 !== peg$FAILED) {\n                                      peg$savedPos = s1;\n                                      s2 = peg$c397();\n                                    }\n                                    s1 = s2;\n                                    if (s1 === peg$FAILED) {\n                                      s1 = peg$currPos;\n                                      if (input.substr(peg$currPos, 10).toLowerCase() === peg$c398) {\n                                        s2 = input.substr(peg$currPos, 10);\n                                        peg$currPos += 10;\n                                      } else {\n                                        s2 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$c399); }\n                                      }\n                                      if (s2 !== peg$FAILED) {\n                                        peg$savedPos = s1;\n                                        s2 = peg$c388();\n                                      }\n                                      s1 = s2;\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c174;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c175); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence9();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s6 = peg$c176;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c177); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c400(s1, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprFunctionsNullary() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 134 + 118,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c401) {\n        s2 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c402); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c403();\n      }\n      s1 = s2;\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c404) {\n          s2 = input.substr(peg$currPos, 6);\n          peg$currPos += 6;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c405); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c406();\n        }\n        s1 = s2;\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c407) {\n            s2 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c408); }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c409();\n          }\n          s1 = s2;\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            if (input.substr(peg$currPos, 17).toLowerCase() === peg$c410) {\n              s2 = input.substr(peg$currPos, 17);\n              peg$currPos += 17;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c411); }\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s2 = peg$c409();\n            }\n            s1 = s2;\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              if (input.substr(peg$currPos, 21).toLowerCase() === peg$c412) {\n                s2 = input.substr(peg$currPos, 21);\n                peg$currPos += 21;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c413); }\n              }\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s2 = peg$c414();\n              }\n              s1 = s2;\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                if (input.substr(peg$currPos, 19).toLowerCase() === peg$c415) {\n                  s2 = input.substr(peg$currPos, 19);\n                  peg$currPos += 19;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c416); }\n                }\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s1;\n                  s2 = peg$c417();\n                }\n                s1 = s2;\n                if (s1 === peg$FAILED) {\n                  s1 = peg$currPos;\n                  if (input.substr(peg$currPos, 15).toLowerCase() === peg$c418) {\n                    s2 = input.substr(peg$currPos, 15);\n                    peg$currPos += 15;\n                  } else {\n                    s2 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c419); }\n                  }\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s1;\n                    s2 = peg$c420();\n                  }\n                  s1 = s2;\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$currPos;\n                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c421) {\n                      s2 = input.substr(peg$currPos, 7);\n                      peg$currPos += 7;\n                    } else {\n                      s2 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c422); }\n                    }\n                    if (s2 !== peg$FAILED) {\n                      peg$savedPos = s1;\n                      s2 = peg$c420();\n                    }\n                    s1 = s2;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c174;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c175); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s4 = peg$c176;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c177); }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c423(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprConstants() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 134 + 119,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c424(s2);\n      }\n      s1 = s2;\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parseboolean();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c425(s2);\n        }\n        s1 = s2;\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parsestring();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c426(s2);\n          }\n          s1 = s2;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c427(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsevalueExprConstantNull();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprConstantNull() {\n      var s0, s1;\n\n      var key    = peg$currPos * 134 + 120,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c281) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c282); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c428(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprColumn() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 121,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecolumnName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s3 = peg$c174;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c175); }\n        }\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = void 0;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c429(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprCaseWhen() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      var key    = peg$currPos * 134 + 122,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c430) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c431); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c432) {\n            s5 = input.substr(peg$currPos, 4);\n            peg$currPos += 4;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c433); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse__();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseexpr_precedence5();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parse__();\n                if (s8 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c434) {\n                    s9 = input.substr(peg$currPos, 4);\n                    peg$currPos += 4;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c435); }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parse__();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parseexpr_precedence5();\n                      if (s11 !== peg$FAILED) {\n                        peg$savedPos = s3;\n                        s4 = peg$c436(s7, s11);\n                        s3 = s4;\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c432) {\n                s5 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c433); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse__();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseexpr_precedence5();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse__();\n                    if (s8 !== peg$FAILED) {\n                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c434) {\n                        s9 = input.substr(peg$currPos, 4);\n                        peg$currPos += 4;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c435); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        s10 = peg$parse__();\n                        if (s10 !== peg$FAILED) {\n                          s11 = peg$parseexpr_precedence5();\n                          if (s11 !== peg$FAILED) {\n                            peg$savedPos = s3;\n                            s4 = peg$c436(s7, s11);\n                            s3 = s4;\n                          } else {\n                            peg$currPos = s3;\n                            s3 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s3;\n                          s3 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c437) {\n              s5 = input.substr(peg$currPos, 4);\n              peg$currPos += 4;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c438); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse__();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseexpr_precedence5();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c439(s2, s7);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c440) {\n                s5 = input.substr(peg$currPos, 3);\n                peg$currPos += 3;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c441); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c442(s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence9() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 123,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence8();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_boolean_disj();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseexpr_rest_string_concat();\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_boolean_disj();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parseexpr_rest_string_concat();\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c443(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence8();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence8() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 124,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence7();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_boolean_xdisj();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_boolean_xdisj();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c443(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence7();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence7() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 125,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence6();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_boolean_conj();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_boolean_conj();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c443(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence6();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence6() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 126,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsevalueExprCaseWhen();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence5();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence5() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 127,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence4();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_boolean_comparison();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_boolean_comparison();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c443(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence4();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence4() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 128,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence3();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_number_add();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_number_add();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c443(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence3();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence3() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 134 + 129,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence2();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_number_mul();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_number_mul();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c443(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence2();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence2() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 130,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parseexpr_number_minus();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence1();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence1() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 131,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parseexpr_boolean_negation();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence0();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence0() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 134 + 132,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsevalueExprConstants();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsevalueExprFunctionsNullary();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsevalueExprFunctionsUnary();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsevalueExprFunctionsBinary();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsevalueExprFunctionsNary();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsevalueExprColumn();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 40) {\n                    s1 = peg$c174;\n                    peg$currPos++;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c175); }\n                  }\n                  if (s1 !== peg$FAILED) {\n                    s2 = peg$parse_();\n                    if (s2 !== peg$FAILED) {\n                      s3 = peg$parseexpr_precedence9();\n                      if (s3 !== peg$FAILED) {\n                        s4 = peg$parse_();\n                        if (s4 !== peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 41) {\n                            s5 = peg$c176;\n                            peg$currPos++;\n                          } else {\n                            s5 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c177); }\n                          }\n                          if (s5 !== peg$FAILED) {\n                            peg$savedPos = s0;\n                            s1 = peg$c203(s3);\n                            s0 = s1;\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseRESERVED_KEYWORD_RELALG() {\n      var s0;\n\n      var key    = peg$currPos * 134 + 133,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c63) {\n        s0 = input.substr(peg$currPos, 2);\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c64); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c67) {\n          s0 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c68); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c71) {\n            s0 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c72); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c87) {\n              s0 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c88); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c91) {\n                s0 = input.substr(peg$currPos, 5);\n                peg$currPos += 5;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c92); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c249) {\n                  s0 = input.substr(peg$currPos, 3);\n                  peg$currPos += 3;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c250); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2).toLowerCase() === peg$c261) {\n                    s0 = input.substr(peg$currPos, 2);\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c262); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c444) {\n                      s0 = input.substr(peg$currPos, 3);\n                      peg$currPos += 3;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c445); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c95) {\n                        s0 = input.substr(peg$currPos, 5);\n                        peg$currPos += 5;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c96); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c99) {\n                          s0 = input.substr(peg$currPos, 9);\n                          peg$currPos += 9;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c100); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 6).toLowerCase() === peg$c107) {\n                            s0 = input.substr(peg$currPos, 6);\n                            peg$currPos += 6;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c108); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                              s0 = input.substr(peg$currPos, 4);\n                              peg$currPos += 4;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c113) {\n                                s0 = input.substr(peg$currPos, 5);\n                                peg$currPos += 5;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c114); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n                                  s0 = input.substr(peg$currPos, 4);\n                                  peg$currPos += 4;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c127) {\n                                    s0 = input.substr(peg$currPos, 4);\n                                    peg$currPos += 4;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c128); }\n                                  }\n                                  if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c133) {\n                                      s0 = input.substr(peg$currPos, 5);\n                                      peg$currPos += 5;\n                                    } else {\n                                      s0 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c134); }\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c141) {\n                                        s0 = input.substr(peg$currPos, 5);\n                                        peg$currPos += 5;\n                                      } else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$c142); }\n                                      }\n                                      if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c147) {\n                                          s0 = input.substr(peg$currPos, 4);\n                                          peg$currPos += 4;\n                                        } else {\n                                          s0 = peg$FAILED;\n                                          if (peg$silentFails === 0) { peg$fail(peg$c148); }\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                          if (input.substr(peg$currPos, 6).toLowerCase() === peg$c446) {\n                                            s0 = input.substr(peg$currPos, 6);\n                                            peg$currPos += 6;\n                                          } else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) { peg$fail(peg$c447); }\n                                          }\n                                          if (s0 === peg$FAILED) {\n                                            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c129) {\n                                              s0 = input.substr(peg$currPos, 4);\n                                              peg$currPos += 4;\n                                            } else {\n                                              s0 = peg$FAILED;\n                                              if (peg$silentFails === 0) { peg$fail(peg$c130); }\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c137) {\n                                                s0 = input.substr(peg$currPos, 4);\n                                                peg$currPos += 4;\n                                              } else {\n                                                s0 = peg$FAILED;\n                                                if (peg$silentFails === 0) { peg$fail(peg$c138); }\n                                              }\n                                              if (s0 === peg$FAILED) {\n                                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c161) {\n                                                  s0 = input.substr(peg$currPos, 4);\n                                                  peg$currPos += 4;\n                                                } else {\n                                                  s0 = peg$FAILED;\n                                                  if (peg$silentFails === 0) { peg$fail(peg$c162); }\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                  if (input.substr(peg$currPos, 3).toLowerCase() === peg$c159) {\n                                                    s0 = input.substr(peg$currPos, 3);\n                                                    peg$currPos += 3;\n                                                  } else {\n                                                    s0 = peg$FAILED;\n                                                    if (peg$silentFails === 0) { peg$fail(peg$c160); }\n                                                  }\n                                                  if (s0 === peg$FAILED) {\n                                                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c430) {\n                                                      s0 = input.substr(peg$currPos, 4);\n                                                      peg$currPos += 4;\n                                                    } else {\n                                                      s0 = peg$FAILED;\n                                                      if (peg$silentFails === 0) { peg$fail(peg$c431); }\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c432) {\n                                                        s0 = input.substr(peg$currPos, 4);\n                                                        peg$currPos += 4;\n                                                      } else {\n                                                        s0 = peg$FAILED;\n                                                        if (peg$silentFails === 0) { peg$fail(peg$c433); }\n                                                      }\n                                                      if (s0 === peg$FAILED) {\n                                                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c434) {\n                                                          s0 = input.substr(peg$currPos, 4);\n                                                          peg$currPos += 4;\n                                                        } else {\n                                                          s0 = peg$FAILED;\n                                                          if (peg$silentFails === 0) { peg$fail(peg$c435); }\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c437) {\n                                                            s0 = input.substr(peg$currPos, 4);\n                                                            peg$currPos += 4;\n                                                          } else {\n                                                            s0 = peg$FAILED;\n                                                            if (peg$silentFails === 0) { peg$fail(peg$c438); }\n                                                          }\n                                                          if (s0 === peg$FAILED) {\n                                                            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c440) {\n                                                              s0 = input.substr(peg$currPos, 3);\n                                                              peg$currPos += 3;\n                                                            } else {\n                                                              s0 = peg$FAILED;\n                                                              if (peg$silentFails === 0) { peg$fail(peg$c441); }\n                                                            }\n                                                            if (s0 === peg$FAILED) {\n                                                              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c41) {\n                                                                s0 = input.substr(peg$currPos, 4);\n                                                                peg$currPos += 4;\n                                                              } else {\n                                                                s0 = peg$FAILED;\n                                                                if (peg$silentFails === 0) { peg$fail(peg$c42); }\n                                                              }\n                                                              if (s0 === peg$FAILED) {\n                                                                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c44) {\n                                                                  s0 = input.substr(peg$currPos, 5);\n                                                                  peg$currPos += 5;\n                                                                } else {\n                                                                  s0 = peg$FAILED;\n                                                                  if (peg$silentFails === 0) { peg$fail(peg$c45); }\n                                                                }\n                                                                if (s0 === peg$FAILED) {\n                                                                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c281) {\n                                                                    s0 = input.substr(peg$currPos, 4);\n                                                                    peg$currPos += 4;\n                                                                  } else {\n                                                                    s0 = peg$FAILED;\n                                                                    if (peg$silentFails === 0) { peg$fail(peg$c282); }\n                                                                  }\n                                                                }\n                                                              }\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n    \t// fallback for debugging when i18n is not defined\n    \t/*if(typeof(i18n) === \'undefined\'){\n    \t\tvar i18n = {\n    \t\t\tt: function(key, obj){\n    \t\t\t\tobj = obj || {};\n    \t\t\t\treturn key+\' \'+JSON.stringify(obj);\n    \t\t\t}\n    \t\t};\n    \t}*/\n\n    \tfunction getCodeInfo(){\n    \t\treturn {\n    \t\t\tlocation: location(),\n    \t\t\ttext: text()\n    \t\t};\n    \t}\n    \t\n    \tfunction checkAssignments(assignments){\n    \t\t// check if the defined variable names are unique\n    \t\tvar tmp = {}, name;\n    \t\t\n    \t\tfor(var i = 0; i < assignments.length; i++){\n    \t\t\tname = assignments[i].name;\n    \t\t\tif(tmp[name])\n    \t\t\t\terror(i18n.t(\'db.messages.parser.error-duplicate-variable\', {name: name}));\n    \t\t\t\n    \t\t\ttmp[name] = true;\n    \t\t}\n    \t};\n    \t\n    \tvar inlineTableNum = 1;\n    \t\n    \tfunction buildBinary(first, rest){\n    \t\t// all members of rest have a child2\n    \t\t\n    \t\tvar root = rest[0];\n    \t\troot.child = first;\n    \t\troot.codeInfo = getCodeInfo();\n    \t\t\n    \t\tvar n;\n    \t\tfor(var i = 1; i < rest.length; i++){\n    \t\t\tn = rest[i];\n    \t\t\t\n    \t\t\tn.child = root;\n    \t\t\tn.codeInfo = getCodeInfo();\n    \t\t\t\n    \t\t\troot = n;\n    \t\t}\n    \t\t\n    \t\treturn root;\n    \t}\n    \t\n    \t// builds a binary valueExpression (fills the args array)\n    \tfunction buildBinaryValueExpr(first, rest){\n    \t\t// all members of rest have a member args in the form [undefined, child2]\n    \t\t\n    \t\tvar root = rest[0];\n    \t\troot.args[0] = first;\n    \t\troot.codeInfo = getCodeInfo();\n    \t\t\n    \t\tvar n;\n    \t\tfor(var i = 1; i < rest.length; i++){\n    \t\t\tn = rest[i];\n    \t\t\t\n    \t\t\tn.args[0] = root;\n    \t\t\tn.codeInfo = getCodeInfo();\n    \t\t\t\n    \t\t\troot = n;\n    \t\t}\n    \t\t\n    \t\treturn root;\n    \t}\n    \t\n    \t// options.relationNames must be an array of strings\n    \t// containing the names of the relations\n    \tvar usedRelationNames = options.relationNames || [];\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: "end", description: "end of input" });\n      }\n\n      throw peg$buildException(\n        null,\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})();\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/parser/grammar_ra.pegjs\n// module id = 153\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/parser/grammar_ra.pegjs?');
},function(module,exports){eval('module.exports = (function() {\n  "use strict";\n\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = "SyntaxError";\n\n    if (typeof Error.captureStackTrace === "function") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n        parser  = this,\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart, dbDumpStart: peg$parsedbDumpStart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(r) { return r; },\n        peg$c1 = { type: "any", description: "any character" },\n        peg$c2 = "\\r\\n",\n        peg$c3 = { type: "literal", value: "\\r\\n", description: "\\"\\\\r\\\\n\\"" },\n        peg$c4 = "\\n",\n        peg$c5 = { type: "literal", value: "\\n", description: "\\"\\\\n\\"" },\n        peg$c6 = { type: "other", description: "-- " },\n        peg$c7 = "--",\n        peg$c8 = { type: "literal", value: "--", description: "\\"--\\"" },\n        peg$c9 = /^[ \\t]/,\n        peg$c10 = { type: "class", value: "[ \\\\t]", description: "[ \\\\t]" },\n        peg$c11 = "/*",\n        peg$c12 = { type: "literal", value: "/*", description: "\\"/*\\"" },\n        peg$c13 = "*/",\n        peg$c14 = { type: "literal", value: "*/", description: "\\"*/\\"" },\n        peg$c15 = { type: "other", description: "whitespace" },\n        peg$c16 = /^[ \\t\\r\\n]/,\n        peg$c17 = { type: "class", value: "[ \\\\t\\\\r\\\\n]", description: "[ \\\\t\\\\r\\\\n]" },\n        peg$c18 = function() { return \'\'; },\n        peg$c19 = { type: "other", description: "optional whitespace" },\n        peg$c20 = { type: "other", description: "whitespace without comments" },\n        peg$c21 = /^[\\r\\n\\t ]/,\n        peg$c22 = { type: "class", value: "[\\\\r\\\\n\\\\t ]", description: "[\\\\r\\\\n\\\\t ]" },\n        peg$c23 = { type: "other", description: "optional whitespace without comments" },\n        peg$c24 = { type: "other", description: "string" },\n        peg$c25 = "\\"",\n        peg$c26 = { type: "literal", value: "\\"", description: "\\"\\\\\\"\\"" },\n        peg$c27 = /^[^"\\^\\n]/,\n        peg$c28 = { type: "class", value: "[^\\"^\\\\n]", description: "[^\\"^\\\\n]" },\n        peg$c29 = function() { error(i18n.t(\'db.messages.parser.error-sql-string-use-single-quotes\')); },\n        peg$c30 = "\'",\n        peg$c31 = { type: "literal", value: "\'", description: "\\"\'\\"" },\n        peg$c32 = /^[^\'\\^\\n]/,\n        peg$c33 = { type: "class", value: "[^\'^\\\\n]", description: "[^\'^\\\\n]" },\n        peg$c34 = function(a) { return a; },\n        peg$c35 = "-",\n        peg$c36 = { type: "literal", value: "-", description: "\\"-\\"" },\n        peg$c37 = /^[0-9]/,\n        peg$c38 = { type: "class", value: "[0-9]", description: "[0-9]" },\n        peg$c39 = function(a) {return parseInt(a, 10); },\n        peg$c40 = ".",\n        peg$c41 = { type: "literal", value: ".", description: "\\".\\"" },\n        peg$c42 = function(a) {return parseFloat(a); },\n        peg$c43 = "true",\n        peg$c44 = { type: "literal", value: "true", description: "\\"true\\"" },\n        peg$c45 = function() { return true; },\n        peg$c46 = "false",\n        peg$c47 = { type: "literal", value: "false", description: "\\"false\\"" },\n        peg$c48 = function() { return false; },\n        peg$c49 = { type: "other", description: "relationName" },\n        peg$c50 = /^[0-9a-zA-Z_]/,\n        peg$c51 = { type: "class", value: "[0-9a-zA-Z_]", description: "[0-9a-zA-Z_]" },\n        peg$c52 = /^[a-zA-Z]/,\n        peg$c53 = { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },\n        peg$c54 = function(a) {\n        \t\tvar b = a.toLowerCase();\n        \t\tif(b === \'true\' || b === \'false\')\n        \t\t\terror(i18n.t(\'db.messages.parser.error-sql-invalid-relation-name\', {str: a}));\n        \t\treturn a;\n        \t},\n        peg$c55 = function(a) {\n        \t\tvar b = a.toLowerCase();\n        \t\tif(b === \'true\' || b === \'false\')\n        \t\t\terror(i18n.t(\'db.messages.parser.error-sql-invalid-column-name\', {str: a}));\n        \t\treturn a;\n        \t},\n        peg$c56 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'relation\',\n        \t\t\tname: a,\n        \t\t\trelAlias: null,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c57 = "date",\n        peg$c58 = { type: "literal", value: "date", description: "\\"date\\"" },\n        peg$c59 = "(\'",\n        peg$c60 = { type: "literal", value: "(\'", description: "\\"(\'\\"" },\n        peg$c61 = "\')",\n        peg$c62 = { type: "literal", value: "\')", description: "\\"\')\\"" },\n        peg$c63 = function(d) {\n        \t\treturn d;\n        \t},\n        peg$c64 = { type: "other", description: "date in ISO format (YYYY-MM-DD)" },\n        peg$c65 = function(year, month, day) {\n        \t\tyear = parseInt(year, 10);\n        \t\tmonth = parseInt(month, 10)-1;\n        \t\tday = parseInt(day, 10);\n        \t\tvar date = new Date(year, month, day);\n        \t\t\n        \t\tif(date.getFullYear() != year || date.getMonth() != month ||  date.getDate() != day){\n        \t\t\terror(i18n.t(\'db.messages.parser.error-invalid-date-format\', {str: text()}));\n        \t\t}\n        \t\treturn date;\n        \t},\n        peg$c66 = function(relAlias, name) {\n        \t\treturn {\n        \t\t\ttype: \'column\',\n        \t\t\tname: name,\n        \t\t\trelAlias: relAlias ? relAlias[0] : null\n        \t\t};\n        \t},\n        peg$c67 = "*",\n        peg$c68 = { type: "literal", value: "*", description: "\\"*\\"" },\n        peg$c69 = function(relAlias) {\n        \t\treturn {\n        \t\t\ttype: \'column\',\n        \t\t\tname: \'*\',\n        \t\t\trelAlias: relAlias ? relAlias[0] : null\n        \t\t};\n        \t},\n        peg$c70 = function(index) {\n        \t\treturn {\n        \t\t\ttype: \'column\',\n        \t\t\tname: parseInt(index, 10),\n        \t\t\trelAlias: null\n        \t\t};\n        \t},\n        peg$c71 = "sum",\n        peg$c72 = { type: "literal", value: "sum", description: "\\"sum\\"" },\n        peg$c73 = "count",\n        peg$c74 = { type: "literal", value: "count", description: "\\"count\\"" },\n        peg$c75 = "avg",\n        peg$c76 = { type: "literal", value: "avg", description: "\\"avg\\"" },\n        peg$c77 = "min",\n        peg$c78 = { type: "literal", value: "min", description: "\\"min\\"" },\n        peg$c79 = "max",\n        peg$c80 = { type: "literal", value: "max", description: "\\"max\\"" },\n        peg$c81 = "(",\n        peg$c82 = { type: "literal", value: "(", description: "\\"(\\"" },\n        peg$c83 = "all",\n        peg$c84 = { type: "literal", value: "ALL", description: "\\"ALL\\"" },\n        peg$c85 = ")",\n        peg$c86 = { type: "literal", value: ")", description: "\\")\\"" },\n        peg$c87 = function(func, col) {\n        \t\treturn {\n        \t\t\ttype: \'aggFunction\',\n        \t\t\taggFunction: func.toUpperCase(),\n        \t\t\tcol: col\n        \t\t};\n        \t},\n        peg$c88 = "count(*)",\n        peg$c89 = { type: "literal", value: "count(*)", description: "\\"count(*)\\"" },\n        peg$c90 = function() {\n        \t\treturn {\n        \t\t\ttype: \'aggFunction\',\n        \t\t\taggFunction: \'COUNT_ALL\',\n        \t\t\tcol: null\n        \t\t};\n        \t},\n        peg$c91 = "as",\n        peg$c92 = { type: "literal", value: "as", description: "\\"as\\"" },\n        peg$c93 = function(f, as) {\n        \t\tf.name = as;\n        \t\treturn f;\n        \t},\n        peg$c94 = function(f) {\n        \t\terror(\'aggregation columns must be named\');\n        \t},\n        peg$c95 = function(col) {\n        \t\tcol.alias = null;\n        \t\treturn col;\n        \t},\n        peg$c96 = function(col, dst) {\n        \t\tcol.alias = dst;\n        \t\treturn col;\n        \t},\n        peg$c97 = function(a, dst) {\n        \t\treturn {\n        \t\t\ttype: \'namedColumnExpr\',\n        \t\t\tname: dst,\n        \t\t\trelAlias: null,\n        \t\t\tchild: a,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c98 = ",",\n        peg$c99 = { type: "literal", value: ",", description: "\\",\\"" },\n        peg$c100 = function(a, b) {\n        \t\tvar t = [a];\n        \t\t\n        \t\tif(b != null){\n        \t\t\tfor(var i = 0; i < b.length; i++){\n        \t\t\t\tvar col = b[i][3];\n        \t\t\t\tt.push(col);\n        \t\t\t}\n        \t\t}\n        \t\treturn t;\n        \t},\n        peg$c101 = function(a, b) {\n        \t\tvar t = [a];\n        \t\tif(b != null){\n        \t\t\tfor(var i in b){\n        \t\t\t\tt.push(b[i][3]);\n        \t\t\t}\n        \t\t}\n        \t\treturn t;\n        \t},\n        peg$c102 = "asc",\n        peg$c103 = { type: "literal", value: "asc", description: "\\"asc\\"" },\n        peg$c104 = function() { \n        \t\treturn true;\n        \t},\n        peg$c105 = "desc",\n        peg$c106 = { type: "literal", value: "desc", description: "\\"desc\\"" },\n        peg$c107 = function() {\n        \t\treturn false;\n        \t},\n        peg$c108 = function(a, asc) {\n        \t\tif(asc == null)\n        \t\t\tasc = true;\n        \t\telse\n        \t\t\tasc = asc[1];\n        \t\t\n        \t\treturn {\n        \t\t\tcol: a,\n        \t\t\tasc: asc\n        \t\t};\n        \t},\n        peg$c109 = function(a, b) {\n        \tvar t = [a];\n        \tif(b != null){\n        \t\tfor(var i in b){\n        \t\t\tt.push(b[i][3]);\n        \t\t}\n        \t}\n        \t\n        \treturn {\n        \t\tvalue: t,\n        \t\t\n        \t\tcodeInfo: getCodeInfo()\n        \t};\n        },\n        peg$c110 = function(a, b) {\n        \tvar t = [a];\n        \tif(b != null){\n        \t\tfor(var i in b){\n        \t\t\tt.push(b[i][3]);\n        \t\t}\n        \t}\n        \t\n        \treturn t;\n        },\n        peg$c111 = function(name, sub) {\n        \t\tsub.wrappedInBrackets = true;\n        \t\treturn {\n        \t\t\ttype: \'assignment\',\n        \t\t\tname: name,\n        \t\t\tchild: {\n        \t\t\t\ttype: \'relationFromSubstatement\',\n        \t\t\t\tstatement: sub,\n        \t\t\t\trelAlias: name,\n\n        \t\t\t\tcodeInfo: getCodeInfo()\n        \t\t\t},\n\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c112 = ";",\n        peg$c113 = { type: "literal", value: ";", description: "\\";\\"" },\n        peg$c114 = function(a, e) {\n        \t\tvar assignments = [];\n        \t\tif(a !== null){\n        \t\t\tassignments = a;\n        \t\t\tcheckAssignments(assignments);\n        \t\t}\n\n        \t\treturn {\n        \t\t\ttype: \'root\',\n        \t\t\tassignments: assignments,\n        \t\t\tchild: e,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c115 = "with",\n        peg$c116 = { type: "literal", value: "with", description: "\\"with\\"" },\n        peg$c117 = function(first, rest) {\n        \t\tvar assignments = [first];\n        \t\tfor(var i = 0; i < rest.length; i++){\n        \t\t\tassignments.push(rest[i][3]);\n        \t\t}\n        \t\treturn assignments;\n        \t},\n        peg$c118 = "select",\n        peg$c119 = { type: "literal", value: "select", description: "\\"select\\"" },\n        peg$c120 = "distinct",\n        peg$c121 = { type: "literal", value: "distinct", description: "\\"distinct\\"" },\n        peg$c122 = function(d, cols) {\n        \t\treturn {\n        \t\t\ttype: \'select\',\n        \t\t\tdistinct: (d !== null),\n        \t\t\targ: cols,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c123 = "order",\n        peg$c124 = { type: "literal", value: "order", description: "\\"order\\"" },\n        peg$c125 = "by",\n        peg$c126 = { type: "literal", value: "by", description: "\\"by\\"" },\n        peg$c127 = function(arg) {\n        \t\treturn {\n        \t\t\ttype: \'orderBy\',\n        \t\t\tchild: null,\n        \t\t\targ: arg,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c128 = function(s, o, l) {\n        \t\tvar n = s;\n        \t\tif(o !== null){\n        \t\t\to[1].child = n;\n        \t\t\tn = o[1];\n        \t\t}\n        \t\tif(l !== null){\n        \t\t\tl[1].child = n;\n        \t\t\tn = l[1];\n        \t\t}\n        \t\treturn n;\n        \t},\n        peg$c129 = function(first, rest) { return buildBinary(first, rest); },\n        peg$c130 = "from",\n        peg$c131 = { type: "literal", value: "from", description: "\\"from\\"" },\n        peg$c132 = "group",\n        peg$c133 = { type: "literal", value: "group", description: "\\"group\\"" },\n        peg$c134 = function(s, f, w, g, h) {\n        \t\t// check if group clause is missing: if a agg column in combination with a non agg column appears group by must be set\n        \t\tvar col;\n        \t\tvar numAggregationColumns = 0;\n        \t\tfor(var i = 0; i < s.arg.length; i++){\n        \t\t\tif(s.arg[i].type === \'aggFunction\')\n        \t\t\t\tnumAggregationColumns++;\n        \t\t}\n        \t\t\n        \t\tif(numAggregationColumns > 0 && numAggregationColumns != s.arg.length && g === null){\n        \t\t\terror(i18n.t(\'db.messages.parser.error-sql-group-by-missing\'));\n        \t\t}\n        \t\t\n        \t\tif(h && !g && numAggregationColumns === 0){\n        \t\t\terror(i18n.t(\'db.messages.parser.error-sql-having-without-group-by\'));\n        \t\t}\n        \t\t\n        \t\t\n        \t\treturn {\n        \t\t\ttype: \'statement\',\n        \t\t\tselect: s,\n        \t\t\tfrom: f,\n        \t\t\twhere: w ? w[1] : null,\n        \t\t\tgroupBy: g ? g[5] : null,\n        \t\t\thaving: h ? h[1] : null,\n        \t\t\t\n        \t\t\tnumAggregationColumns: numAggregationColumns,\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c135 = function(e) {\n        \t\te.wrappedInBrackets = true;\n        \t\treturn e;\n        \t},\n        peg$c136 = "union",\n        peg$c137 = { type: "literal", value: "union", description: "\\"union\\"" },\n        peg$c138 = { type: "literal", value: "all", description: "\\"all\\"" },\n        peg$c139 = function(all, c) { return {type: \'union\', child2: c, all: all}; },\n        peg$c140 = "except",\n        peg$c141 = { type: "literal", value: "except", description: "\\"except\\"" },\n        peg$c142 = function(all, c) { return {type: \'except\', child2: c, all: all}; },\n        peg$c143 = "intersect",\n        peg$c144 = { type: "literal", value: "intersect", description: "\\"intersect\\"" },\n        peg$c145 = function(all, c) { return {type: \'intersect\', child2: c, all: all}; },\n        peg$c146 = function(name, alias) {\n        \t\tvar relation = {\n        \t\t\ttype: \'relation\',\n        \t\t\tname: name,\n        \t\t\trelAlias: null,\n\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n\n        \t\tif(alias !== null){\n        \t\t\treturn {\n        \t\t\t\ttype: \'renameRelation\',\n        \t\t\t\tchild: relation,\n        \t\t\t\tnewRelAlias: alias[3],\n        \t\t\t\tcodeInfo: getCodeInfo()\n        \t\t\t};\n        \t\t}\n        \t\telse{\n        \t\t\treturn relation;\n        \t\t}\n        \t},\n        peg$c147 = function(sub, alias) {\n        \t\tsub.wrappedInBrackets = true;\n        \t\treturn {\n        \t\t\ttype: \'relationFromSubstatement\',\n        \t\t\tstatement: sub,\n        \t\t\trelAlias: alias,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c148 = "cross",\n        peg$c149 = { type: "literal", value: "cross", description: "\\"cross\\"" },\n        peg$c150 = "join",\n        peg$c151 = { type: "literal", value: "join", description: "\\"join\\"" },\n        peg$c152 = function(c) { return {type: \'crossJoin\', child2: c, cond: null}; },\n        peg$c153 = "natural",\n        peg$c154 = { type: "literal", value: "natural", description: "\\"natural\\"" },\n        peg$c155 = function(c) { return {type: \'naturalJoin\', child2: c, cond: null}; },\n        peg$c156 = "inner",\n        peg$c157 = { type: "literal", value: "inner", description: "\\"inner\\"" },\n        peg$c158 = function() { return \'innerJoin\'; },\n        peg$c159 = "left",\n        peg$c160 = { type: "literal", value: "left", description: "\\"left\\"" },\n        peg$c161 = "outer",\n        peg$c162 = { type: "literal", value: "outer", description: "\\"outer\\"" },\n        peg$c163 = function() { return \'leftOuterJoin\'; },\n        peg$c164 = "right",\n        peg$c165 = { type: "literal", value: "right", description: "\\"right\\"" },\n        peg$c166 = function() { return \'rightOuterJoin\'; },\n        peg$c167 = "full",\n        peg$c168 = { type: "literal", value: "full", description: "\\"full\\"" },\n        peg$c169 = function() { return \'fullOuterJoin\'; },\n        peg$c170 = "on",\n        peg$c171 = { type: "literal", value: "on", description: "\\"on\\"" },\n        peg$c172 = function(type, c, condition) { return condition; },\n        peg$c173 = "using",\n        peg$c174 = { type: "literal", value: "using", description: "\\"using\\"" },\n        peg$c175 = function(type, c, first, rest) {\n        \t\t\tvar restrictToColumns = [first];\n        \t\t\tfor(var i = 0; i < rest.length; i++){\n        \t\t\t\trestrictToColumns.push(rest[i][3]);\n        \t\t\t}\n        \t\t\treturn restrictToColumns;\n        \t\t},\n        peg$c176 = function(type, c) { return null; },\n        peg$c177 = function(type, c, condition) {\n        \t\treturn {\n        \t\t\ttype: type,\n        \t\t\tchild2: c,\n        \t\t\tcond: condition\n        \t\t};\n        \t},\n        peg$c178 = "where",\n        peg$c179 = { type: "literal", value: "where", description: "\\"where\\"" },\n        peg$c180 = function(cond) {\n        \t\treturn {\n        \t\t\ttype: \'where\',\n        \t\t\targ: cond,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c181 = "having",\n        peg$c182 = { type: "literal", value: "having", description: "\\"having\\"" },\n        peg$c183 = function(cond) {\n        \t\treturn {\n        \t\t\ttype: \'having\',\n        \t\t\targ: cond,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c184 = function() { return -1; },\n        peg$c185 = function(a) { \n        \t\tif(a < 0)\n        \t\t\terror(i18n.t(\'db.messages.parser.error-sql-negative-limit\'));\n        \t\treturn a;\n        \t},\n        peg$c186 = "limit",\n        peg$c187 = { type: "literal", value: "limit", description: "\\"limit\\"" },\n        peg$c188 = function(o, l) {\n        \t\treturn {\n        \t\t\ttype: \'limit\',\n        \t\t\tlimit: l,\n        \t\t\toffset: 0,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c189 = "offset",\n        peg$c190 = { type: "literal", value: "offset", description: "\\"offset\\"" },\n        peg$c191 = function(l, o) {\n        \t\treturn {\n        \t\t\ttype: \'limit\',\n        \t\t\tlimit: l,\n        \t\t\toffset: o,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c192 = function(l) {\n        \t\treturn {\n        \t\t\ttype: \'limit\',\n        \t\t\tlimit: l,\n        \t\t\toffset: 0,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c193 = "rows",\n        peg$c194 = { type: "literal", value: "rows", description: "\\"rows\\"" },\n        peg$c195 = "row",\n        peg$c196 = { type: "literal", value: "row", description: "\\"row\\"" },\n        peg$c197 = function(o) {\n        \t\treturn o;\n        \t},\n        peg$c198 = "fetch",\n        peg$c199 = { type: "literal", value: "fetch", description: "\\"fetch\\"" },\n        peg$c200 = "first",\n        peg$c201 = { type: "literal", value: "first", description: "\\"first\\"" },\n        peg$c202 = "next",\n        peg$c203 = { type: "literal", value: "next", description: "\\"next\\"" },\n        peg$c204 = "only",\n        peg$c205 = { type: "literal", value: "only", description: "\\"only\\"" },\n        peg$c206 = function(l) {\n        \t\tif(l < 0)\n        \t\t\terror(i18n.t(\'db.messages.parser.error-sql-negative-limit\'));\n        \t\treturn l;\n        \t},\n        peg$c207 = function(o, l) { return [o, l]; },\n        peg$c208 = function(o) { return [o, -1]; },\n        peg$c209 = function(l) { return [0, l]; },\n        peg$c210 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'limit\',\n        \t\t\tchild: null,\n        \t\t\tlimit: a[1],\n        \t\t\toffset: a[0],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c211 = "is",\n        peg$c212 = { type: "literal", value: "is", description: "\\"is\\"" },\n        peg$c213 = "not",\n        peg$c214 = { type: "literal", value: "not", description: "\\"not\\"" },\n        peg$c215 = function() { return \'!=\'; },\n        peg$c216 = function() { return \'=\'; },\n        peg$c217 = "=",\n        peg$c218 = { type: "literal", value: "=", description: "\\"=\\"" },\n        peg$c219 = "<>",\n        peg$c220 = { type: "literal", value: "<>", description: "\\"<>\\"" },\n        peg$c221 = "!=",\n        peg$c222 = { type: "literal", value: "!=", description: "\\"!=\\"" },\n        peg$c223 = ">=",\n        peg$c224 = { type: "literal", value: ">=", description: "\\">=\\"" },\n        peg$c225 = function() { return \'>=\'; },\n        peg$c226 = ">",\n        peg$c227 = { type: "literal", value: ">", description: "\\">\\"" },\n        peg$c228 = "<=",\n        peg$c229 = { type: "literal", value: "<=", description: "\\"<=\\"" },\n        peg$c230 = function() { return \'<=\'; },\n        peg$c231 = "<",\n        peg$c232 = { type: "literal", value: "<", description: "\\"<\\"" },\n        peg$c233 = { type: "other", description: "logical AND" },\n        peg$c234 = "and",\n        peg$c235 = { type: "literal", value: "and", description: "\\"and\\"" },\n        peg$c236 = function() { return \'AND\'; },\n        peg$c237 = { type: "other", description: "logical XOR" },\n        peg$c238 = "xor",\n        peg$c239 = { type: "literal", value: "xor", description: "\\"xor\\"" },\n        peg$c240 = { type: "other", description: "logical OR" },\n        peg$c241 = "or",\n        peg$c242 = { type: "literal", value: "or", description: "\\"or\\"" },\n        peg$c243 = function() { return \'OR\'; },\n        peg$c244 = { type: "other", description: "logical NOT" },\n        peg$c245 = "!",\n        peg$c246 = { type: "literal", value: "!", description: "\\"!\\"" },\n        peg$c247 = function() { return \'NOT\'; },\n        peg$c248 = "exists",\n        peg$c249 = { type: "literal", value: "exists", description: "\\"exists\\"" },\n        peg$c250 = function(negation, sub) {\n        \t\treturn {\n        \t\t\ttype: \'existsSubstatement\',\n        \t\t\tstatement: sub,\n        \t\t\tnegation: (negation != null),\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c251 = function() { return { type: \'comment\' }; },\n        peg$c252 = "#",\n        peg$c253 = { type: "literal", value: "#", description: "\\"#\\"" },\n        peg$c254 = /^[^\\n]/,\n        peg$c255 = { type: "class", value: "[^\\\\n]", description: "[^\\\\n]" },\n        peg$c256 = "`",\n        peg$c257 = { type: "literal", value: "`", description: "\\"`\\"" },\n        peg$c258 = "drop",\n        peg$c259 = { type: "literal", value: "drop", description: "\\"drop\\"" },\n        peg$c260 = "table",\n        peg$c261 = { type: "literal", value: "table", description: "\\"table\\"" },\n        peg$c262 = "if",\n        peg$c263 = { type: "literal", value: "if", description: "\\"if\\"" },\n        peg$c264 = function() { return { type: \'dropTable\' }; },\n        peg$c265 = "lock",\n        peg$c266 = { type: "literal", value: "lock", description: "\\"lock\\"" },\n        peg$c267 = "tables",\n        peg$c268 = { type: "literal", value: "tables", description: "\\"tables\\"" },\n        peg$c269 = function() { return { type: \'lockTable\' }; },\n        peg$c270 = "unlock",\n        peg$c271 = { type: "literal", value: "unlock", description: "\\"unlock\\"" },\n        peg$c272 = function() { return { type: \'unlockTable\' }; },\n        peg$c273 = "SET ",\n        peg$c274 = { type: "literal", value: "SET ", description: "\\"SET \\"" },\n        peg$c275 = function(a) {\n        \t\tvar tables = {};\n        \t\tvar column_indices = {};\n        \t\tvar e, i, j, k, row, type;\n        \t\t\n        \t\tfor(i = 0; i < a.length; i++){\n        \t\t\te = a[i][0];\n        \t\t\tif(!e.type || e.type !== \'table\' && e.type !== \'insert\')\n        \t\t\t\tcontinue;\n        \t\t\t\n        \t\t\tif(e.type == \'table\'){ // create\n        \t\t\t\tif(tables[e.name])\n        \t\t\t\t\terror(\'table \'+e.name+\' already created\');\n        \t\t\t\t\n        \t\t\t\ttables[e.name] = e;\n        \t\t\t\t\n        \t\t\t\tcolumn_indices[e.name] = {};\n        \t\t\t\tfor(j = 0; j < e.columns.length; j++){\n        \t\t\t\t\tcolumn_indices[e.name][e.columns[j].name] = j;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\telse if(e.type === \'insert\'){ // insert\n        \t\t\t\tif(!tables[e.name])\n        \t\t\t\t\terror(\'table \'+e.name+\' not created\');\n        \t\t\t\t\n        \t\t\t\tfor(j = 0; j < e.values.length; j++){\n        \t\t\t\t\tif(e.columns.length === 0){\n        \t\t\t\t\t\trow = e.values[j];\n        \t\t\t\t\t}\n        \t\t\t\t\telse{\n        \t\t\t\t\t\trow = new Array(tables[e.name].columns.length);\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tfor(k = 0; k < e.values[j].length; k++){\n        \t\t\t\t\t\t\trow[ column_indices[e.name][e.columns[k]] ] = e.values[j][k];\n        \t\t\t\t\t\t}\n        \t\t\t\t\t}\n        \t\t\t\t\t\n        \t\t\t\t\t// type check\n        \t\t\t\t\tif(row.length !== tables[e.name].columns.length)\n        \t\t\t\t\t\terror(i18n.t(\'db.messages.parser.error-sqldump-invalid-column-number\', {line: e.codeInfo.line}));\n        \t\t\t\t\t\n        \t\t\t\t\tfor(k = 0; k < row.length; k++){\n        \t\t\t\t\t\ttype = tables[e.name].columns[k].type;\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tif(row[k] === null)\n        \t\t\t\t\t\t\tcontinue;\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tswitch(type){\n        \t\t\t\t\t\t\tcase \'number\':\n        \t\t\t\t\t\t\t\tif(typeof row[k] !== \'number\')\n        \t\t\t\t\t\t\t\t\terror(i18n.t(\'db.messages.parser.error-sqldump-invalid-type\', {line: e.codeInfo.line}));\n        \t\t\t\t\t\t\t\tbreak;\n        \t\t\t\t\t\t\t\t\n        \t\t\t\t\t\t\tcase \'string\':\n        \t\t\t\t\t\t\t\tif(typeof row[k] !== \'string\')\n        \t\t\t\t\t\t\t\t\terror(i18n.t(\'db.messages.parser.error-sqldump-invalid-type\', {line: e.codeInfo.line}));\n        \t\t\t\t\t\t\t\tbreak;\n        \t\t\t\t\t\t\t\n        \t\t\t\t\t\t\tcase \'date\':\n        \t\t\t\t\t\t\t\tif(row[k] instanceof Date === false)\n        \t\t\t\t\t\t\t\t\terror(i18n.t(\'db.messages.parser.error-sqldump-invalid-type\', {line: e.codeInfo.line}));\n        \t\t\t\t\t\t\t\tbreak;\n        \t\t\t\t\t\t}\n        \t\t\t\t\t}\n        \t\t\t\t\t\n        \t\t\t\t\ttables[e.name].rows.push(row);\n        \t\t\t\t}\n        \t\t\t\t\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tvar assignments = [];\n        \t\tfor(var name in tables){\n        \t\t\tassignments.push({\n        \t\t\t\ttype: \'assignment\',\n        \t\t\t\tname: name,\n        \t\t\t\tchild: tables[name],\n        \t\t\t\t\n        \t\t\t\tcodeInfo: getCodeInfo()\n        \t\t\t});\n        \t\t}\n        \t\t\n        \t\tvar root = {\n        \t\t\ttype: \'groupRoot\',\n        \t\t\tgroups: [\n        \t\t\t\t{\n        \t\t\t\t\ttype: \'tableGroup\',\n        \t\t\t\t\theaders: {\n        \t\t\t\t\t\tgroup: \'\' // name of the group\n        \t\t\t\t\t},\n        \t\t\t\t\tassignments: assignments,\n        \t\t\t\t\t\n        \t\t\t\t\tcodeInfo: getCodeInfo()\n        \t\t\t\t}\n        \t\t\t],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t\treturn root;\n        \t\t\n        \t},\n        peg$c276 = "decimal",\n        peg$c277 = { type: "literal", value: "decimal", description: "\\"decimal\\"" },\n        peg$c278 = function() { return \'number\'; },\n        peg$c279 = "tinyint",\n        peg$c280 = { type: "literal", value: "tinyint", description: "\\"tinyint\\"" },\n        peg$c281 = "smallint",\n        peg$c282 = { type: "literal", value: "smallint", description: "\\"smallint\\"" },\n        peg$c283 = "mediumint",\n        peg$c284 = { type: "literal", value: "mediumint", description: "\\"mediumint\\"" },\n        peg$c285 = "bigint",\n        peg$c286 = { type: "literal", value: "bigint", description: "\\"bigint\\"" },\n        peg$c287 = "integer",\n        peg$c288 = { type: "literal", value: "integer", description: "\\"integer\\"" },\n        peg$c289 = "int",\n        peg$c290 = { type: "literal", value: "int", description: "\\"int\\"" },\n        peg$c291 = "float",\n        peg$c292 = { type: "literal", value: "float", description: "\\"float\\"" },\n        peg$c293 = "double",\n        peg$c294 = { type: "literal", value: "double", description: "\\"double\\"" },\n        peg$c295 = "varchar",\n        peg$c296 = { type: "literal", value: "varchar", description: "\\"varchar\\"" },\n        peg$c297 = "char",\n        peg$c298 = { type: "literal", value: "char", description: "\\"char\\"" },\n        peg$c299 = "text",\n        peg$c300 = { type: "literal", value: "text", description: "\\"text\\"" },\n        peg$c301 = function() { return \'string\'; },\n        peg$c302 = "datetime",\n        peg$c303 = { type: "literal", value: "datetime", description: "\\"datetime\\"" },\n        peg$c304 = function() { return \'date\'; },\n        peg$c305 = /^[a-zA-Z0-9_=]/,\n        peg$c306 = { type: "class", value: "[a-zA-Z0-9_=]", description: "[a-zA-Z0-9_=]" },\n        peg$c307 = function() { return null; },\n        peg$c308 = function(name, type) {\n        \t\treturn {\n        \t\t\tname: name,\n        \t\t\ttype: type,\n        \t\t\trelAlias: null\n        \t\t};\n        \t},\n        peg$c309 = function(first, rest) {\n        \t\tvar a = [];\n        \t\tif(first !== null && first.type)\n        \t\t\ta.push(first);\n        \t\t\n        \t\tfor(var i = 0; i < rest.length; i++){\n        \t\t\tif(rest[i][3] !== null && rest[i][3].type)\n        \t\t\t\ta.push(rest[i][3]);\n        \t\t}\n        \t\t\n        \t\treturn a;\n        \t},\n        peg$c310 = "create",\n        peg$c311 = { type: "literal", value: "create", description: "\\"create\\"" },\n        peg$c312 = function(name, columns) {\n        \t\tvar table = {\n        \t\t\ttype: \'table\',\n        \t\t\tname: name,\n        \t\t\tcolumns: columns, //{name: \'\', relAlias: null, type: \'\'}\n        \t\t\trows: [], \n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t\t\n        \t\t\n        \t\t\n        \t\treturn table;\n        \t},\n        peg$c313 = "null",\n        peg$c314 = { type: "literal", value: "null", description: "\\"null\\"" },\n        peg$c315 = function(first, rest) {\n        \t\tvar a = [first];\n        \t\tfor(var i = 0; i < rest.length; i++){\n        \t\t\ta.push(rest[i][3]);\n        \t\t}\n        \t\treturn a;\n        \t},\n        peg$c316 = "insert",\n        peg$c317 = { type: "literal", value: "insert", description: "\\"insert\\"" },\n        peg$c318 = "into",\n        peg$c319 = { type: "literal", value: "into", description: "\\"into\\"" },\n        peg$c320 = "values",\n        peg$c321 = { type: "literal", value: "values", description: "\\"values\\"" },\n        peg$c322 = function(name, cols, value_first, value_rest) {\n        \t\tvar i;\n        \t\tvar insert = {\n        \t\t\ttype: \'insert\',\n        \t\t\tname: name,\n        \t\t\tcolumns: [],\n        \t\t\tvalues: [value_first],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t\t\n        \t\tif(value_rest){\n        \t\t\tfor(i = 0; i < value_rest.length; i++){\n        \t\t\t\tinsert.values.push(value_rest[i][3]);\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tif(cols){\n        \t\t\t// first\n        \t\t\tinsert.columns.push(cols[3]);\n        \t\t\t\n        \t\t\t// rest\n        \t\t\tfor(var i = 0; i < cols[4].length; i++){\n        \t\t\t\tinsert.columns.push(cols[4][i][3]);\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\t\n        \t\t// check number of columns\n        \t\tvar numCols = insert.values[0].length;\n        \t\t\n        \t\tfor(i = 1; i < insert.values.length; i++){\n        \t\t\tif(insert.values[i].length !== numCols)\n        \t\t\t\terror(i18n.t(\'db.messages.parser.error-sqldump-insert-wrong-number-columns\'));\n        \t\t}\n        \t\t\n        \t\tif(cols && insert.columns.length !== numCols)\n        \t\t\terror(i18n.t(\'db.messages.parser.error-sqldump-insert-wrong-number-columns\'));\n        \t\t\n        \t\t\n        \t\treturn insert;\n        \t},\n        peg$c323 = { type: "other", description: "boolean expression" },\n        peg$c324 = function(right) { \n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: \'or\',\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c325 = "||",\n        peg$c326 = { type: "literal", value: "||", description: "\\"||\\"" },\n        peg$c327 = function(right) { \n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'string\',\n        \t\t\tfunc: \'concat\',\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c328 = function(right) { \n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: \'xor\',\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c329 = function(right) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: \'and\',\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c330 = function(o, right) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: o,\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c331 = "like",\n        peg$c332 = { type: "literal", value: "like", description: "\\"like\\"" },\n        peg$c333 = "ilike",\n        peg$c334 = { type: "literal", value: "ilike", description: "\\"ilike\\"" },\n        peg$c335 = function(o, right) {\n        \t\tif(right.datatype !== \'string\'){\n        \t\t\terror(i18n.t(\'db.messages.parser.error-valueexpr-like-operand-no-string\'));\n        \t\t}\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: o.toLowerCase(),\n        \t\t\targs: [undefined, right],\n\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c336 = "+",\n        peg$c337 = { type: "literal", value: "+", description: "\\"+\\"" },\n        peg$c338 = function(o, right) {\n        \t\to = {\n        \t\t\t\'+\': \'add\', \n        \t\t\t\'-\': \'sub\'\n        \t\t}[o];\n        \t\t\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'number\',\n        \t\t\tfunc: o,\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c339 = "/",\n        peg$c340 = { type: "literal", value: "/", description: "\\"/\\"" },\n        peg$c341 = "%",\n        peg$c342 = { type: "literal", value: "%", description: "\\"%\\"" },\n        peg$c343 = function(o, right) {\n        \t\to = {\n        \t\t\t\'*\': \'mul\', \n        \t\t\t\'/\': \'div\',\n        \t\t\t\'%\': \'mod\'\n        \t\t}[o];\n        \t\t\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'number\',\n        \t\t\tfunc: o,\n        \t\t\targs: [undefined, right],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c344 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'number\',\n        \t\t\tfunc: \'minus\',\n        \t\t\targs: [a],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c345 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'boolean\',\n        \t\t\tfunc: \'not\',\n        \t\t\targs: [a],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c346 = "coalesce",\n        peg$c347 = { type: "literal", value: "coalesce", description: "\\"coalesce\\"" },\n        peg$c348 = function() { return [\'coalesce\', \'null\']; },\n        peg$c349 = "concat",\n        peg$c350 = { type: "literal", value: "concat", description: "\\"concat\\"" },\n        peg$c351 = function() { return [\'concat\', \'string\']; },\n        peg$c352 = function(func, arg0, argn) {\n        \t\tvar args = [arg0];\n        \t\tfor(var i = 0; i < argn.length; i++){\n        \t\t\targs.push(argn[i][2]);\n        \t\t}\n        \t\t\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: func[1],\n        \t\t\tfunc: func[0],\n        \t\t\targs: args,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c353 = "adddate",\n        peg$c354 = { type: "literal", value: "adddate", description: "\\"adddate\\"" },\n        peg$c355 = function() { return [\'adddate\', \'date\']; },\n        peg$c356 = "subdate",\n        peg$c357 = { type: "literal", value: "subdate", description: "\\"subdate\\"" },\n        peg$c358 = function() { return [\'subdate\', \'date\']; },\n        peg$c359 = "mod",\n        peg$c360 = { type: "literal", value: "mod", description: "\\"mod\\"" },\n        peg$c361 = function() { return [\'mod\', \'number\']; },\n        peg$c362 = "add",\n        peg$c363 = { type: "literal", value: "add", description: "\\"add\\"" },\n        peg$c364 = function() { return [\'add\', \'number\']; },\n        peg$c365 = "sub",\n        peg$c366 = { type: "literal", value: "sub", description: "\\"sub\\"" },\n        peg$c367 = function() { return [\'sub\', \'number\']; },\n        peg$c368 = "mul",\n        peg$c369 = { type: "literal", value: "mul", description: "\\"mul\\"" },\n        peg$c370 = function() { return [\'mul\', \'number\']; },\n        peg$c371 = "div",\n        peg$c372 = { type: "literal", value: "div", description: "\\"div\\"" },\n        peg$c373 = function() { return [\'div\', \'number\']; },\n        peg$c374 = function(func, arg0, arg1) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: func[1],\n        \t\t\tfunc: func[0],\n        \t\t\targs: [arg0, arg1],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c375 = "upper",\n        peg$c376 = { type: "literal", value: "upper", description: "\\"upper\\"" },\n        peg$c377 = function() { return [\'upper\', \'string\']; },\n        peg$c378 = "ucase",\n        peg$c379 = { type: "literal", value: "ucase", description: "\\"ucase\\"" },\n        peg$c380 = "lower",\n        peg$c381 = { type: "literal", value: "lower", description: "\\"lower\\"" },\n        peg$c382 = function() { return [\'lower\', \'string\']; },\n        peg$c383 = "lcase",\n        peg$c384 = { type: "literal", value: "lcase", description: "\\"lcase\\"" },\n        peg$c385 = "length",\n        peg$c386 = { type: "literal", value: "length", description: "\\"length\\"" },\n        peg$c387 = function() { return [\'strlen\', \'number\']; },\n        peg$c388 = "abs",\n        peg$c389 = { type: "literal", value: "abs", description: "\\"abs\\"" },\n        peg$c390 = function() { return [\'abs\', \'number\']; },\n        peg$c391 = "floor",\n        peg$c392 = { type: "literal", value: "floor", description: "\\"floor\\"" },\n        peg$c393 = function() { return [\'floor\', \'number\']; },\n        peg$c394 = "ceil",\n        peg$c395 = { type: "literal", value: "ceil", description: "\\"ceil\\"" },\n        peg$c396 = function() { return [\'ceil\', \'number\']; },\n        peg$c397 = "round",\n        peg$c398 = { type: "literal", value: "round", description: "\\"round\\"" },\n        peg$c399 = function() { return [\'round\', \'number\']; },\n        peg$c400 = function() { return [\'date\', \'date\']; },\n        peg$c401 = "year",\n        peg$c402 = { type: "literal", value: "year", description: "\\"year\\"" },\n        peg$c403 = function() { return [\'year\', \'number\']; },\n        peg$c404 = "month",\n        peg$c405 = { type: "literal", value: "month", description: "\\"month\\"" },\n        peg$c406 = function() { return [\'month\', \'number\']; },\n        peg$c407 = "day",\n        peg$c408 = { type: "literal", value: "day", description: "\\"day\\"" },\n        peg$c409 = function() { return [\'dayofmonth\', \'number\']; },\n        peg$c410 = "hour",\n        peg$c411 = { type: "literal", value: "hour", description: "\\"hour\\"" },\n        peg$c412 = function() { return [\'hour\', \'number\']; },\n        peg$c413 = "minute",\n        peg$c414 = { type: "literal", value: "minute", description: "\\"minute\\"" },\n        peg$c415 = function() { return [\'minute\', \'number\']; },\n        peg$c416 = "second",\n        peg$c417 = { type: "literal", value: "second", description: "\\"second\\"" },\n        peg$c418 = function() { return [\'second\', \'number\']; },\n        peg$c419 = "dayofmonth",\n        peg$c420 = { type: "literal", value: "dayofmonth", description: "\\"dayofmonth\\"" },\n        peg$c421 = function(func, arg0) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: func[1],\n        \t\t\tfunc: func[0],\n        \t\t\targs: [arg0],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c422 = "rand",\n        peg$c423 = { type: "literal", value: "rand", description: "\\"rand\\"" },\n        peg$c424 = function() { return [\'rand\', \'number\']; },\n        peg$c425 = "rownum",\n        peg$c426 = { type: "literal", value: "rownum", description: "\\"rownum\\"" },\n        peg$c427 = function() { return [\'rownum\', \'number\']; },\n        peg$c428 = "now",\n        peg$c429 = { type: "literal", value: "now", description: "\\"now\\"" },\n        peg$c430 = function() { return [\'now\', \'date\']; },\n        peg$c431 = "current_timestamp",\n        peg$c432 = { type: "literal", value: "current_timestamp", description: "\\"current_timestamp\\"" },\n        peg$c433 = "transaction_timestamp",\n        peg$c434 = { type: "literal", value: "transaction_timestamp", description: "\\"transaction_timestamp\\"" },\n        peg$c435 = function() { return [\'transaction_timestamp\', \'date\']; },\n        peg$c436 = "statement_timestamp",\n        peg$c437 = { type: "literal", value: "statement_timestamp", description: "\\"statement_timestamp\\"" },\n        peg$c438 = function() { return [\'statement_timestamp\', \'date\']; },\n        peg$c439 = "clock_timestamp",\n        peg$c440 = { type: "literal", value: "clock_timestamp", description: "\\"clock_timestamp\\"" },\n        peg$c441 = function() { return [\'clock_timestamp\', \'date\']; },\n        peg$c442 = "sysdate",\n        peg$c443 = { type: "literal", value: "sysdate", description: "\\"sysdate\\"" },\n        peg$c444 = function(func) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: func[1],\n        \t\t\tfunc: func[0],\n        \t\t\targs: [],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c445 = function(v) { return [v, \'number\']; },\n        peg$c446 = function(v) { return [v, \'boolean\']; },\n        peg$c447 = function(v) { return [v, \'string\']; },\n        peg$c448 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: a[1],\n        \t\t\tfunc: \'constant\',\n        \t\t\targs: [a[0]],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c449 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'null\',\n        \t\t\tfunc: \'constant\',\n        \t\t\targs: [null],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c450 = function(a) {\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'null\',\n        \t\t\tfunc: \'columnValue\',\n        \t\t\targs: [a.name, a.relAlias],\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c451 = "case",\n        peg$c452 = { type: "literal", value: "case", description: "\\"case\\"" },\n        peg$c453 = "when",\n        peg$c454 = { type: "literal", value: "when", description: "\\"when\\"" },\n        peg$c455 = "then",\n        peg$c456 = { type: "literal", value: "then", description: "\\"then\\"" },\n        peg$c457 = function(c, r) { return {w: c, t:r} },\n        peg$c458 = "else",\n        peg$c459 = { type: "literal", value: "else", description: "\\"else\\"" },\n        peg$c460 = function(wt, r) { return r },\n        peg$c461 = "end",\n        peg$c462 = { type: "literal", value: "end", description: "\\"end\\"" },\n        peg$c463 = function(wt, e) {\n        \t\tvar args = [], i;\n        \t\tfor(i = 0; i < wt.length; i++){\n        \t\t\t// when on i%2 === 0\n        \t\t\targs.push(wt[i].w);\n        \t\t\t\n        \t\t\t// then on i%2 === 1\n        \t\t\targs.push(wt[i].t);\n        \t\t}\n        \t\t\n        \t\t// else part\n        \t\tif(e !== null){\n        \t\t\t// when on i%2 === 0\n        \t\t\t// constant true is used to give all args a unified interface\n        \t\t\targs.push({\n        \t\t\t\ttype: \'valueExpr\',\n        \t\t\t\tdatatype: \'boolean\',\n        \t\t\t\tfunc: \'constant\',\n        \t\t\t\targs: [true],\n\n        \t\t\t\tcodeInfo: getCodeInfo()\n        \t\t\t});\n        \t\t\t\n        \t\t\t// then on i%2 === 1\n        \t\t\targs.push(e);\n        \t\t}\n        \t\t\n        \t\treturn {\n        \t\t\ttype: \'valueExpr\',\n        \t\t\tdatatype: \'null\',\n        \t\t\tfunc: e === null ? \'caseWhen\' : \'caseWhenElse\',\n        \t\t\targs: args,\n        \t\t\t\n        \t\t\tcodeInfo: getCodeInfo()\n        \t\t};\n        \t},\n        peg$c464 = function(first, rest) { return buildBinaryValueExpr(first, rest); },\n        peg$c465 = "pi",\n        peg$c466 = { type: "literal", value: "pi", description: "\\"pi\\"" },\n        peg$c467 = "sigma",\n        peg$c468 = { type: "literal", value: "sigma", description: "\\"sigma\\"" },\n        peg$c469 = "rho",\n        peg$c470 = { type: "literal", value: "rho", description: "\\"rho\\"" },\n        peg$c471 = "tau",\n        peg$c472 = { type: "literal", value: "tau", description: "\\"tau\\"" },\n        peg$c473 = "gamma",\n        peg$c474 = { type: "literal", value: "gamma", description: "\\"gamma\\"" },\n        peg$c475 = "natual",\n        peg$c476 = { type: "literal", value: "natual", description: "\\"natual\\"" },\n        peg$c477 = "semi",\n        peg$c478 = { type: "literal", value: "semi", description: "\\"semi\\"" },\n        peg$c479 = "anti",\n        peg$c480 = { type: "literal", value: "anti", description: "\\"anti\\"" },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$resultsCache = {},\n\n        peg$result;\n\n    if ("startRule" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error("Can\'t start parsing from rule \\"" + options.startRule + "\\".");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: "other", description: description }],\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(\n        message,\n        null,\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n          p, ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n          if (ch === "\\n") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   \'\\\\\\\\\')\n            .replace(/"/g,    \'\\\\"\')\n            .replace(/\\x08/g, \'\\\\b\')\n            .replace(/\\t/g,   \'\\\\t\')\n            .replace(/\\n/g,   \'\\\\n\')\n            .replace(/\\f/g,   \'\\\\f\')\n            .replace(/\\r/g,   \'\\\\r\')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return \'\\\\x0\' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return \'\\\\x\'  + hex(ch); })\n            .replace(/[\\u0100-\\u0FFF]/g,         function(ch) { return \'\\\\u0\' + hex(ch); })\n            .replace(/[\\u1000-\\uFFFF]/g,         function(ch) { return \'\\\\u\'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(", ")\n              + " or "\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? "\\"" + stringEscape(found) + "\\"" : "end of input";\n\n        return "Expected " + expectedDesc + " but " + foundDesc + " found.";\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 113 + 0,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseroot();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseroot();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse__();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s1);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse__();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseroot();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c0(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedbDumpStart() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 1,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsedbDumpRoot();\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseEOF() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 2,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c1); }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseendOfLine() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 3,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.substr(peg$currPos, 2) === peg$c2) {\n        s0 = peg$c2;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 10) {\n          s0 = peg$c4;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c5); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomment() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 4,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsesingleLineComment();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsemultiLineComment();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesingleLineComment() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 5,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c7) {\n        s1 = peg$c7;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (peg$c9.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseendOfLine();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parseEOF();\n          }\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = void 0;\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c7) {\n          s1 = peg$c7;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          peg$silentFails++;\n          s3 = peg$parseendOfLine();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parseEOF();\n          }\n          peg$silentFails--;\n          if (s3 !== peg$FAILED) {\n            peg$currPos = s2;\n            s2 = void 0;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c7) {\n            s1 = peg$c7;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c8); }\n          }\n          if (s1 !== peg$FAILED) {\n            if (peg$c9.test(input.charAt(peg$currPos))) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c10); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$currPos;\n              s4 = [];\n              s5 = peg$currPos;\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parseendOfLine();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = void 0;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s7 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c1); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                s5 = peg$currPos;\n                s6 = peg$currPos;\n                peg$silentFails++;\n                s7 = peg$parseendOfLine();\n                peg$silentFails--;\n                if (s7 === peg$FAILED) {\n                  s6 = void 0;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s7 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c1); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s6 = [s6, s7];\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                s3 = input.substring(s3, peg$currPos);\n              } else {\n                s3 = s4;\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$currPos;\n                peg$silentFails++;\n                s5 = peg$parseendOfLine();\n                if (s5 === peg$FAILED) {\n                  s5 = peg$parseEOF();\n                }\n                peg$silentFails--;\n                if (s5 !== peg$FAILED) {\n                  peg$currPos = s4;\n                  s4 = void 0;\n                } else {\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  s1 = [s1, s2, s3, s4];\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsemultiLineComment() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 113 + 6,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c11) {\n        s1 = peg$c11;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c12); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c13) {\n          s5 = peg$c13;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c14); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c1); }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 2) === peg$c13) {\n            s5 = peg$c13;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c1); }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c13) {\n            s3 = peg$c13;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse__() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 113 + 7,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsecomment();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsecomment();\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$c16.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c17); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c16.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          s6 = peg$parsecomment();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parsecomment();\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = [];\n          s4 = peg$parsecomment();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsecomment();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            if (peg$c16.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\n            }\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                if (peg$c16.test(input.charAt(peg$currPos))) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c17); }\n                }\n              }\n            } else {\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parsecomment();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parsecomment();\n              }\n              if (s5 !== peg$FAILED) {\n                s3 = [s3, s4, s5];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c18();\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c15); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 8,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = [];\n      s1 = peg$parsecomment();\n      if (s1 === peg$FAILED) {\n        if (peg$c16.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c17); }\n        }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsecomment();\n        if (s1 === peg$FAILED) {\n          if (peg$c16.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c17); }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse__nc() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 9,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = [];\n      if (peg$c21.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c21.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c22); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c20); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_nc() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 10,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = [];\n      if (peg$c21.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c21.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c22); }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 113 + 11,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c25;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c27.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c27.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c25;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c26); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c29();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s1 = peg$c30;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c31); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          s3 = [];\n          if (peg$c32.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c33); }\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c32.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c33); }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = input.substring(s2, peg$currPos);\n          } else {\n            s2 = s3;\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s3 = peg$c30;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c31); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c34(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinteger() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 113 + 12,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s3 = peg$c35;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$c37.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c37.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c38); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c39(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefloat() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 13,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s3 = peg$c35;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$c37.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c37.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c38); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s5 = peg$c40;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c41); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = [];\n            if (peg$c37.test(input.charAt(peg$currPos))) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c38); }\n            }\n            if (s7 !== peg$FAILED) {\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                if (peg$c37.test(input.charAt(peg$currPos))) {\n                  s7 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                }\n              }\n            } else {\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              s3 = [s3, s4, s5, s6];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c42(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 14,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsefloat();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseinteger();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseboolean() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 15,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c43) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c45();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c46) {\n          s1 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c47); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c48();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserelationName() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 16,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$currPos;\n      s3 = peg$parseRESERVED_KEYWORD_RELALG();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = [];\n        if (peg$c50.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s6 !== peg$FAILED) {\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c51); }\n            }\n          }\n        } else {\n          s5 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = void 0;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        s4 = [];\n        if (peg$c52.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c53); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c52.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          s6 = [];\n          if (peg$c50.test(input.charAt(peg$currPos))) {\n            s7 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c51); }\n          }\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c51); }\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = input.substring(s5, peg$currPos);\n          } else {\n            s5 = s6;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = input.substring(s2, peg$currPos);\n        } else {\n          s2 = s3;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c54(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c49); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunqualifiedColumnName() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 17,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      s2 = peg$currPos;\n      s3 = peg$parseRESERVED_KEYWORD_RELALG();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = [];\n        if (peg$c50.test(input.charAt(peg$currPos))) {\n          s6 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s6 !== peg$FAILED) {\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c51); }\n            }\n          }\n        } else {\n          s5 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = void 0;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        s4 = [];\n        if (peg$c52.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c53); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c52.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          s6 = [];\n          if (peg$c50.test(input.charAt(peg$currPos))) {\n            s7 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c51); }\n          }\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c51); }\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = input.substring(s5, peg$currPos);\n          } else {\n            s5 = s6;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = input.substring(s2, peg$currPos);\n        } else {\n          s2 = s3;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c55(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parserelation() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 18,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parserelationName();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c56(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedateStr() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 113 + 19,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c57) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c58); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c59) {\n          s2 = peg$c59;\n          peg$currPos += 2;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c60); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsedate();\n          if (s3 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c61) {\n              s4 = peg$c61;\n              peg$currPos += 2;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c62); }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c63(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedate() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 113 + 20,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (peg$c37.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n      }\n      if (s3 !== peg$FAILED) {\n        if (peg$c37.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s4 !== peg$FAILED) {\n          if (peg$c37.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c38); }\n          }\n          if (s5 !== peg$FAILED) {\n            if (peg$c37.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c38); }\n            }\n            if (s6 !== peg$FAILED) {\n              s3 = [s3, s4, s5, s6];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c35;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c36); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          if (peg$c37.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c38); }\n          }\n          if (s5 !== peg$FAILED) {\n            if (peg$c37.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c38); }\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = input.substring(s3, peg$currPos);\n          } else {\n            s3 = s4;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s4 = peg$c35;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c36); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              s6 = peg$currPos;\n              if (peg$c37.test(input.charAt(peg$currPos))) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c38); }\n              }\n              if (s7 !== peg$FAILED) {\n                if (peg$c37.test(input.charAt(peg$currPos))) {\n                  s8 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s7 = [s7, s8];\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                s5 = input.substring(s5, peg$currPos);\n              } else {\n                s5 = s6;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c65(s1, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c64); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecolumnName() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 21,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parserelationName();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c40;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseunqualifiedColumnName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c66(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecolumnAsterisk() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 22,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parserelationName();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c40;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s2 = peg$c67;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c68); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c69(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecolumnIndex() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 23,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c37.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c37.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c38); }\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c70(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseaggFunction() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 24,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c71) {\n        s2 = input.substr(peg$currPos, 3);\n        peg$currPos += 3;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c72); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c73) {\n          s2 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c74); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c75) {\n            s2 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c76); }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c77) {\n              s2 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c78); }\n            }\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c79) {\n                s2 = input.substr(peg$currPos, 3);\n                peg$currPos += 3;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c80); }\n              }\n            }\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c81;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {\n              s5 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c84); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse__();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecolumnName();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s7 = peg$c85;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c87(s1, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c88) {\n          s1 = input.substr(peg$currPos, 8);\n          peg$currPos += 8;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c89); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c90();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecolumnForSelect() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 113 + 25,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseaggFunction();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {\n            s3 = input.substr(peg$currPos, 2);\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c92); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseunqualifiedColumnName();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c93(s1, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseaggFunction();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c94(s1);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsecolumnAsterisk();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c95(s1);\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsecolumnName();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse__();\n              if (s2 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {\n                  s3 = input.substr(peg$currPos, 2);\n                  peg$currPos += 2;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c92); }\n                }\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse__();\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parseunqualifiedColumnName();\n                    if (s5 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c96(s1, s5);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseexpr_precedence9();\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parse__();\n                if (s2 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {\n                    s3 = input.substr(peg$currPos, 2);\n                    peg$currPos += 2;\n                  } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c92); }\n                  }\n                  if (s3 !== peg$FAILED) {\n                    s4 = peg$parse__();\n                    if (s4 !== peg$FAILED) {\n                      s5 = peg$parseunqualifiedColumnName();\n                      if (s5 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c97(s1, s5);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsecolumnName();\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c95(s1);\n                }\n                s0 = s1;\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselectArg() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 26,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecolumnForSelect();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c98;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c99); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsecolumnForSelect();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c98;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c99); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsecolumnForSelect();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c100(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselistOfColumnNames() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 27,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecolumnName();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c98;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c99); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsecolumnName();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c98;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c99); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsecolumnName();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c101(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseorderDirection() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 28,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c102) {\n        s1 = input.substr(peg$currPos, 3);\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c103); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c104();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c105) {\n          s1 = input.substr(peg$currPos, 4);\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c106); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c107();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseorderByArg() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 113 + 29,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecolumnName();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsecolumnIndex();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseorderDirection();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c108(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselistOfOrderByArgs() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 30,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseorderByArg();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c98;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c99); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseorderByArg();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c98;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c99); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseorderByArg();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c109(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselistOfGroupByArgs() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 31,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecolumnName();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c98;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c99); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsecolumnName();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c98;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c99); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsecolumnName();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c110(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsewithClauseArgument() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 32,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parserelationName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {\n            s3 = input.substr(peg$currPos, 2);\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c92); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s5 = peg$c81;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c82); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsecompound_operator_precedence_3();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s7 = peg$c85;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c111(s1, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 113 + 33,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsewithClause();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsecompound_operator_precedence_3();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 59) {\n                s5 = peg$c112;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c113); }\n              }\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c114(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsewithClause() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      var key    = peg$currPos * 113 + 34,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c115) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c116); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsewithClauseArgument();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$currPos;\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s7 = peg$c98;\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c99); }\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parse_();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parsewithClauseArgument();\n                  if (s9 !== peg$FAILED) {\n                    s6 = [s6, s7, s8, s9];\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s7 = peg$c98;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsewithClauseArgument();\n                    if (s9 !== peg$FAILED) {\n                      s6 = [s6, s7, s8, s9];\n                      s5 = s6;\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c117(s3, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselect() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 113 + 35,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c118) {\n        s1 = input.substr(peg$currPos, 6);\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c119); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.substr(peg$currPos, 8).toLowerCase() === peg$c120) {\n            s4 = input.substr(peg$currPos, 8);\n            peg$currPos += 8;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c121); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse__();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseselectArg();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c122(s3, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseorderBy() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 113 + 36,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c123) {\n        s1 = input.substr(peg$currPos, 5);\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c124); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2).toLowerCase() === peg$c125) {\n            s3 = input.substr(peg$currPos, 2);\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c126); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parselistOfOrderByArgs();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c127(s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_operator_precedence_3() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 113 + 37,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecompound_operator_precedence_2();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseorderBy();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parselimit();\n            if (s5 === peg$FAILED) {\n              s5 = peg$parsefetchFirst();\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c128(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsecompound_operator_precedence_2();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_operator_precedence_2() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 38,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecompound_operator_precedence_1();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseunion();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseexcept();\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseunion();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parseexcept();\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c129(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsecompound_operator_precedence_1();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_operator_precedence_1() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 39,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecompound_operator_precedence_0();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseintersect();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseintersect();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c129(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsecompound_operator_precedence_0();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_operator_precedence_0() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n      var key    = peg$currPos * 113 + 40,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseselect();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c130) {\n            s3 = input.substr(peg$currPos, 4);\n            peg$currPos += 4;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c131); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsefrom_item_precedence_1();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parse__();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsewhere();\n                  if (s8 !== peg$FAILED) {\n                    s7 = [s7, s8];\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$currPos;\n                  s8 = peg$parse__();\n                  if (s8 !== peg$FAILED) {\n                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c132) {\n                      s9 = input.substr(peg$currPos, 5);\n                      peg$currPos += 5;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c133); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse__();\n                      if (s10 !== peg$FAILED) {\n                        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c125) {\n                          s11 = input.substr(peg$currPos, 2);\n                          peg$currPos += 2;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c126); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parse__();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parselistOfGroupByArgs();\n                            if (s13 !== peg$FAILED) {\n                              s8 = [s8, s9, s10, s11, s12, s13];\n                              s7 = s8;\n                            } else {\n                              peg$currPos = s7;\n                              s7 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s7;\n                            s7 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s7;\n                          s7 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s7;\n                        s7 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                  if (s7 === peg$FAILED) {\n                    s7 = null;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$currPos;\n                    s9 = peg$parse__();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsehaving();\n                      if (s10 !== peg$FAILED) {\n                        s9 = [s9, s10];\n                        s8 = s9;\n                      } else {\n                        peg$currPos = s8;\n                        s8 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                    if (s8 === peg$FAILED) {\n                      s8 = null;\n                    }\n                    if (s8 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c134(s1, s5, s6, s7, s8);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c81;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsecompound_operator_precedence_3();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s5 = peg$c85;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c135(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunion() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 113 + 41,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c136) {\n          s2 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c137); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {\n              s5 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c138); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse__();\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s4;\n                s5 = peg$c45();\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = peg$currPos;\n              if (input.substr(peg$currPos, 8).toLowerCase() === peg$c120) {\n                s5 = input.substr(peg$currPos, 8);\n                peg$currPos += 8;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c121); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse__();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s4;\n                  s5 = peg$c48();\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecompound_operator_precedence_1();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c139(s4, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexcept() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 113 + 42,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c140) {\n          s2 = input.substr(peg$currPos, 6);\n          peg$currPos += 6;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c141); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {\n              s5 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c138); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse__();\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s4;\n                s5 = peg$c45();\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = peg$currPos;\n              if (input.substr(peg$currPos, 8).toLowerCase() === peg$c120) {\n                s5 = input.substr(peg$currPos, 8);\n                peg$currPos += 8;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c121); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse__();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s4;\n                  s5 = peg$c48();\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecompound_operator_precedence_1();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c142(s4, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseintersect() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 113 + 43,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c143) {\n          s2 = input.substr(peg$currPos, 9);\n          peg$currPos += 9;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c144); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {\n              s5 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c138); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse__();\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s4;\n                s5 = peg$c45();\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = peg$currPos;\n              if (input.substr(peg$currPos, 8).toLowerCase() === peg$c120) {\n                s5 = input.substr(peg$currPos, 8);\n                peg$currPos += 8;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c121); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse__();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s4;\n                  s5 = peg$c48();\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecompound_operator_precedence_1();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c145(s4, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefrom_item_precedence_1() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 44,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsefrom_item_precedence_0();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsecrossJoin();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsenaturalJoin();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parseinnerAndOuterJoins();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsecrossJoin();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsenaturalJoin();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parseinnerAndOuterJoins();\n              }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c129(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsefrom_item_precedence_0();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefrom_item_precedence_0() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      var key    = peg$currPos * 113 + 45,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parserelationName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {\n            s4 = input.substr(peg$currPos, 2);\n            peg$currPos += 2;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c92); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse__();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parserelationName();\n              if (s6 !== peg$FAILED) {\n                s3 = [s3, s4, s5, s6];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c146(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c81;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsecompound_operator_precedence_3();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s5 = peg$c85;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse__();\n                  if (s6 !== peg$FAILED) {\n                    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c91) {\n                      s7 = input.substr(peg$currPos, 2);\n                      peg$currPos += 2;\n                    } else {\n                      s7 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c92); }\n                    }\n                    if (s7 !== peg$FAILED) {\n                      s8 = peg$parse__();\n                      if (s8 !== peg$FAILED) {\n                        s9 = peg$parserelationName();\n                        if (s9 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c147(s3, s9);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s1 = peg$c81;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c82); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsefrom_item_precedence_1();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c85;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c135(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecrossJoin() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 113 + 46,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parse__();\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c148) {\n          s3 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c149); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {\n              s5 = input.substr(peg$currPos, 4);\n              peg$currPos += 4;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c151); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse__();\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c98;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c99); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s2 = [s2, s3, s4];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsefrom_item_precedence_0();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c152(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenaturalJoin() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 113 + 47,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c153) {\n          s2 = input.substr(peg$currPos, 7);\n          peg$currPos += 7;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c154); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {\n              s4 = input.substr(peg$currPos, 4);\n              peg$currPos += 4;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c151); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsefrom_item_precedence_0();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c155(s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinnerAndOuterJoins() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;\n\n      var key    = peg$currPos * 113 + 48,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c156) {\n          s4 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c157); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse__();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {\n            s4 = input.substr(peg$currPos, 4);\n            peg$currPos += 4;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c151); }\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s2;\n            s3 = peg$c158();\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = peg$currPos;\n          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c159) {\n            s3 = input.substr(peg$currPos, 4);\n            peg$currPos += 4;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c160); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parse__();\n            if (s5 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 5) === peg$c161) {\n                s6 = peg$c161;\n                peg$currPos += 5;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c162); }\n              }\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {\n                  s6 = input.substr(peg$currPos, 4);\n                  peg$currPos += 4;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c151); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s2;\n                  s3 = peg$c163();\n                  s2 = s3;\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n          if (s2 === peg$FAILED) {\n            s2 = peg$currPos;\n            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c164) {\n              s3 = input.substr(peg$currPos, 5);\n              peg$currPos += 5;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c165); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$currPos;\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {\n                  s6 = input.substr(peg$currPos, 5);\n                  peg$currPos += 5;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c162); }\n                }\n                if (s6 !== peg$FAILED) {\n                  s5 = [s5, s6];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 === peg$FAILED) {\n                s4 = null;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parse__();\n                if (s5 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {\n                    s6 = input.substr(peg$currPos, 4);\n                    peg$currPos += 4;\n                  } else {\n                    s6 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c151); }\n                  }\n                  if (s6 !== peg$FAILED) {\n                    peg$savedPos = s2;\n                    s3 = peg$c166();\n                    s2 = s3;\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$currPos;\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c167) {\n                s3 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c168); }\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$currPos;\n                s5 = peg$parse__();\n                if (s5 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {\n                    s6 = input.substr(peg$currPos, 5);\n                    peg$currPos += 5;\n                  } else {\n                    s6 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c162); }\n                  }\n                  if (s6 !== peg$FAILED) {\n                    s5 = [s5, s6];\n                    s4 = s5;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n                if (s4 === peg$FAILED) {\n                  s4 = null;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse__();\n                  if (s5 !== peg$FAILED) {\n                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {\n                      s6 = input.substr(peg$currPos, 4);\n                      peg$currPos += 4;\n                    } else {\n                      s6 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c151); }\n                    }\n                    if (s6 !== peg$FAILED) {\n                      peg$savedPos = s2;\n                      s3 = peg$c169();\n                      s2 = s3;\n                    } else {\n                      peg$currPos = s2;\n                      s2 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsefrom_item_precedence_0();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                if (input.substr(peg$currPos, 2).toLowerCase() === peg$c170) {\n                  s7 = input.substr(peg$currPos, 2);\n                  peg$currPos += 2;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c171); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse__();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsebooleanExpr();\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s6;\n                      s7 = peg$c172(s2, s4, s9);\n                      s6 = s7;\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = peg$currPos;\n                  if (input.substr(peg$currPos, 5).toLowerCase() === peg$c173) {\n                    s7 = input.substr(peg$currPos, 5);\n                    peg$currPos += 5;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c174); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse_();\n                    if (s8 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 40) {\n                        s9 = peg$c81;\n                        peg$currPos++;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c82); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        s10 = peg$parse_();\n                        if (s10 !== peg$FAILED) {\n                          s11 = peg$parseunqualifiedColumnName();\n                          if (s11 !== peg$FAILED) {\n                            s12 = [];\n                            s13 = peg$currPos;\n                            s14 = peg$parse_();\n                            if (s14 !== peg$FAILED) {\n                              if (input.charCodeAt(peg$currPos) === 44) {\n                                s15 = peg$c98;\n                                peg$currPos++;\n                              } else {\n                                s15 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                              }\n                              if (s15 !== peg$FAILED) {\n                                s16 = peg$parse_();\n                                if (s16 !== peg$FAILED) {\n                                  s17 = peg$parseunqualifiedColumnName();\n                                  if (s17 !== peg$FAILED) {\n                                    s14 = [s14, s15, s16, s17];\n                                    s13 = s14;\n                                  } else {\n                                    peg$currPos = s13;\n                                    s13 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s13;\n                                  s13 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s13;\n                                s13 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s13;\n                              s13 = peg$FAILED;\n                            }\n                            while (s13 !== peg$FAILED) {\n                              s12.push(s13);\n                              s13 = peg$currPos;\n                              s14 = peg$parse_();\n                              if (s14 !== peg$FAILED) {\n                                if (input.charCodeAt(peg$currPos) === 44) {\n                                  s15 = peg$c98;\n                                  peg$currPos++;\n                                } else {\n                                  s15 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                                }\n                                if (s15 !== peg$FAILED) {\n                                  s16 = peg$parse_();\n                                  if (s16 !== peg$FAILED) {\n                                    s17 = peg$parseunqualifiedColumnName();\n                                    if (s17 !== peg$FAILED) {\n                                      s14 = [s14, s15, s16, s17];\n                                      s13 = s14;\n                                    } else {\n                                      peg$currPos = s13;\n                                      s13 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s13;\n                                    s13 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s13;\n                                  s13 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s13;\n                                s13 = peg$FAILED;\n                              }\n                            }\n                            if (s12 !== peg$FAILED) {\n                              s13 = peg$parse_();\n                              if (s13 !== peg$FAILED) {\n                                if (input.charCodeAt(peg$currPos) === 41) {\n                                  s14 = peg$c85;\n                                  peg$currPos++;\n                                } else {\n                                  s14 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                                }\n                                if (s14 !== peg$FAILED) {\n                                  peg$savedPos = s6;\n                                  s7 = peg$c175(s2, s4, s11, s12);\n                                  s6 = s7;\n                                } else {\n                                  peg$currPos = s6;\n                                  s6 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s6;\n                                s6 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s6;\n                              s6 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s6;\n                            s6 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s6;\n                          s6 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                  if (s6 === peg$FAILED) {\n                    s6 = peg$currPos;\n                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c153) {\n                      s7 = input.substr(peg$currPos, 7);\n                      peg$currPos += 7;\n                    } else {\n                      s7 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c154); }\n                    }\n                    if (s7 !== peg$FAILED) {\n                      peg$savedPos = s6;\n                      s7 = peg$c176(s2, s4);\n                    }\n                    s6 = s7;\n                  }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c177(s2, s4, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsewhere() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 49,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c178) {\n        s1 = input.substr(peg$currPos, 5);\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c179); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsebooleanExpr();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c180(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehaving() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 50,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c181) {\n        s1 = input.substr(peg$currPos, 6);\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c182); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsebooleanExpr();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c183(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselimitArg() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 51,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c83) {\n        s1 = input.substr(peg$currPos, 3);\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c138); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c184();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseinteger();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c185(s1);\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselimit() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 52,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c186) {\n        s1 = input.substr(peg$currPos, 5);\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c187); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseinteger();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c98;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c99); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parselimitArg();\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c188(s3, s7);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c186) {\n          s1 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c187); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse__();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parselimitArg();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse__();\n              if (s4 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 6).toLowerCase() === peg$c189) {\n                  s5 = input.substr(peg$currPos, 6);\n                  peg$currPos += 6;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c190); }\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse__();\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parseinteger();\n                    if (s7 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c191(s3, s7);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c186) {\n            s1 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c187); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse__();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parselimitArg();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c192(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefetchFirstOffset() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 113 + 53,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c189) {\n        s1 = input.substr(peg$currPos, 6);\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c190); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseinteger();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parse__();\n            if (s5 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c193) {\n                s6 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c194); }\n              }\n              if (s6 === peg$FAILED) {\n                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c195) {\n                  s6 = input.substr(peg$currPos, 3);\n                  peg$currPos += 3;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c196); }\n                }\n              }\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c197(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefetchFirstLimit() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      var key    = peg$currPos * 113 + 54,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c198) {\n        s1 = input.substr(peg$currPos, 5);\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c199); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c200) {\n            s3 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c201); }\n          }\n          if (s3 === peg$FAILED) {\n            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c202) {\n              s3 = input.substr(peg$currPos, 4);\n              peg$currPos += 4;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c203); }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseinteger();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse__();\n                if (s6 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c193) {\n                    s7 = input.substr(peg$currPos, 4);\n                    peg$currPos += 4;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c194); }\n                  }\n                  if (s7 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c195) {\n                      s7 = input.substr(peg$currPos, 3);\n                      peg$currPos += 3;\n                    } else {\n                      s7 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c196); }\n                    }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse__();\n                    if (s8 !== peg$FAILED) {\n                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c204) {\n                        s9 = input.substr(peg$currPos, 4);\n                        peg$currPos += 4;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c205); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c206(s5);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefetchFirst() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 113 + 55,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsefetchFirstOffset();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsefetchFirstLimit();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c207(s2, s4);\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsefetchFirstOffset();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c208(s2);\n        }\n        s1 = s2;\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parsefetchFirstLimit();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c209(s2);\n          }\n          s1 = s2;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c210(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperators() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 56,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsecomparisonOperatorEquals();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsecomparisonOperatorNotEquals();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsecomparisonOperatorGreaterEquals();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsecomparisonOperatorLesserEquals();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsecomparisonOperatorGreater();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsecomparisonOperatorLesser();\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorsIsOrIsNot() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 57,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c211) {\n        s1 = input.substr(peg$currPos, 2);\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c212); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c213) {\n            s3 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c214); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c215();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c211) {\n          s1 = input.substr(peg$currPos, 2);\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c212); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c216();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorEquals() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 58,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s0 = peg$c217;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c218); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorNotEquals() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 59,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c219) {\n        s1 = peg$c219;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c220); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c221) {\n          s1 = peg$c221;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c222); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c215();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorGreaterEquals() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 60,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c223) {\n        s1 = peg$c223;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c224); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c225();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorGreater() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 61,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.charCodeAt(peg$currPos) === 62) {\n        s0 = peg$c226;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c227); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorLesserEquals() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 62,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c228) {\n        s1 = peg$c228;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c229); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c230();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecomparisonOperatorLesser() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 63,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.charCodeAt(peg$currPos) === 60) {\n        s0 = peg$c231;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c232); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseand() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 64,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c234) {\n          s2 = input.substr(peg$currPos, 3);\n          peg$currPos += 3;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c235); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c236();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c233); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsexor() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 65,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c238) {\n          s2 = input.substr(peg$currPos, 3);\n          peg$currPos += 3;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c239); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c237); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseor() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 66,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse__();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c241) {\n          s2 = input.substr(peg$currPos, 2);\n          peg$currPos += 2;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c242); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse__();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c243();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c240); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenot() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 67,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s2 = peg$c245;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c246); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c247();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c244); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesubquery_expression() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 113 + 68,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 3) === peg$c213) {\n        s2 = peg$c213;\n        peg$currPos += 3;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c214); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse__();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c248) {\n          s2 = input.substr(peg$currPos, 6);\n          peg$currPos += 6;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c249); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s4 = peg$c81;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c82); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsecompound_operator_precedence_3();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 41) {\n                      s8 = peg$c85;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c250(s1, s6);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedumpComment() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 113 + 69,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_nc();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsecomment();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_nc();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 59) {\n              s4 = peg$c112;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c113); }\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c251();\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 35) {\n          s1 = peg$c252;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c253); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_nc();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            if (peg$c254.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c255); }\n            }\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c254.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c255); }\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 10) {\n                s4 = peg$c4;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c5); }\n              }\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c251();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedumpTableName() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 70,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 96) {\n        s1 = peg$c256;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c257); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parserelationName();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 96) {\n            s3 = peg$c256;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c257); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c34(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parserelationName();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c34(s1);\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedropTable() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      var key    = peg$currPos * 113 + 71,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c258) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c259); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__nc();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c260) {\n            s3 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c261); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__nc();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              if (input.substr(peg$currPos, 2).toLowerCase() === peg$c262) {\n                s6 = input.substr(peg$currPos, 2);\n                peg$currPos += 2;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c263); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse__nc();\n                if (s7 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 6).toLowerCase() === peg$c248) {\n                    s8 = input.substr(peg$currPos, 6);\n                    peg$currPos += 6;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c249); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parse__nc();\n                    if (s9 !== peg$FAILED) {\n                      s6 = [s6, s7, s8, s9];\n                      s5 = s6;\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsedumpTableName();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_nc();\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 59) {\n                      s8 = peg$c112;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c113); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c264();\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselockTables() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      var key    = peg$currPos * 113 + 72,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c265) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c266); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__nc();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 6).toLowerCase() === peg$c267) {\n            s3 = input.substr(peg$currPos, 6);\n            peg$currPos += 6;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c268); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__nc();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsedumpTableName();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse__nc();\n                if (s6 !== peg$FAILED) {\n                  s7 = [];\n                  if (peg$c52.test(input.charAt(peg$currPos))) {\n                    s8 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c53); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    while (s8 !== peg$FAILED) {\n                      s7.push(s8);\n                      if (peg$c52.test(input.charAt(peg$currPos))) {\n                        s8 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                      } else {\n                        s8 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n                      }\n                    }\n                  } else {\n                    s7 = peg$FAILED;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse_nc();\n                    if (s8 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 59) {\n                        s9 = peg$c112;\n                        peg$currPos++;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c113); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c269();\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunlockTables() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 113 + 73,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c270) {\n        s1 = input.substr(peg$currPos, 6);\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c271); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__nc();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 6).toLowerCase() === peg$c267) {\n            s3 = input.substr(peg$currPos, 6);\n            peg$currPos += 6;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c268); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_nc();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 59) {\n                s5 = peg$c112;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c113); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c272();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedumpSetVar() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 74,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c273) {\n        s1 = peg$c273;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c274); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c254.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c255); }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c254.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c255); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseendOfLine();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedbDumpRoot() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 113 + 75,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_nc();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parselockTables();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseunlockTables();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsedumpComment();\n            if (s4 === peg$FAILED) {\n              s4 = peg$parsedropTable();\n              if (s4 === peg$FAILED) {\n                s4 = peg$parsecreateTableStmt();\n                if (s4 === peg$FAILED) {\n                  s4 = peg$parseinsertStmt();\n                  if (s4 === peg$FAILED) {\n                    s4 = peg$parsedumpSetVar();\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_nc();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$parselockTables();\n            if (s4 === peg$FAILED) {\n              s4 = peg$parseunlockTables();\n              if (s4 === peg$FAILED) {\n                s4 = peg$parsedumpComment();\n                if (s4 === peg$FAILED) {\n                  s4 = peg$parsedropTable();\n                  if (s4 === peg$FAILED) {\n                    s4 = peg$parsecreateTableStmt();\n                    if (s4 === peg$FAILED) {\n                      s4 = peg$parseinsertStmt();\n                      if (s4 === peg$FAILED) {\n                        s4 = peg$parsedumpSetVar();\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_nc();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_nc();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c275(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecreateTableStmt_columnType() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      var key    = peg$currPos * 113 + 76,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c276) {\n        s1 = input.substr(peg$currPos, 7);\n        peg$currPos += 7;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c277); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s3 = peg$c81;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_nc();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            if (peg$c37.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c38); }\n            }\n            if (s6 !== peg$FAILED) {\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                if (peg$c37.test(input.charAt(peg$currPos))) {\n                  s6 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                }\n              }\n            } else {\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_nc();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s7 = peg$c98;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_nc();\n                  if (s8 !== peg$FAILED) {\n                    s9 = [];\n                    if (peg$c37.test(input.charAt(peg$currPos))) {\n                      s10 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s10 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                    }\n                    if (s10 !== peg$FAILED) {\n                      while (s10 !== peg$FAILED) {\n                        s9.push(s10);\n                        if (peg$c37.test(input.charAt(peg$currPos))) {\n                          s10 = input.charAt(peg$currPos);\n                          peg$currPos++;\n                        } else {\n                          s10 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                        }\n                      }\n                    } else {\n                      s9 = peg$FAILED;\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse_nc();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 41) {\n                          s11 = peg$c85;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s3 = [s3, s4, s5, s6, s7, s8, s9, s10, s11];\n                          s2 = s3;\n                        } else {\n                          peg$currPos = s2;\n                          s2 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s2;\n                        s2 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s2;\n                      s2 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c278();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c279) {\n          s1 = input.substr(peg$currPos, 7);\n          peg$currPos += 7;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c280); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8).toLowerCase() === peg$c281) {\n            s1 = input.substr(peg$currPos, 8);\n            peg$currPos += 8;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c282); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c283) {\n              s1 = input.substr(peg$currPos, 9);\n              peg$currPos += 9;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c284); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.substr(peg$currPos, 6).toLowerCase() === peg$c285) {\n                s1 = input.substr(peg$currPos, 6);\n                peg$currPos += 6;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c286); }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7).toLowerCase() === peg$c287) {\n                  s1 = input.substr(peg$currPos, 7);\n                  peg$currPos += 7;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c288); }\n                }\n                if (s1 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 3).toLowerCase() === peg$c289) {\n                    s1 = input.substr(peg$currPos, 3);\n                    peg$currPos += 3;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c290); }\n                  }\n                  if (s1 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c276) {\n                      s1 = input.substr(peg$currPos, 7);\n                      peg$currPos += 7;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c277); }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s3 = peg$c81;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c82); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_nc();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              if (peg$c37.test(input.charAt(peg$currPos))) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c38); }\n              }\n              if (s6 !== peg$FAILED) {\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  if (peg$c37.test(input.charAt(peg$currPos))) {\n                    s6 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s6 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                  }\n                }\n              } else {\n                s5 = peg$FAILED;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_nc();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s7 = peg$c85;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s3 = [s3, s4, s5, s6, s7];\n                    s2 = s3;\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n          if (s2 === peg$FAILED) {\n            s2 = null;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c278();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c291) {\n            s1 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c292); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c293) {\n              s1 = input.substr(peg$currPos, 6);\n              peg$currPos += 6;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c294); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7).toLowerCase() === peg$c276) {\n                s1 = input.substr(peg$currPos, 7);\n                peg$currPos += 7;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c277); }\n              }\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s3 = peg$c81;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c82); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = [];\n              if (peg$c37.test(input.charAt(peg$currPos))) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c38); }\n              }\n              if (s5 !== peg$FAILED) {\n                while (s5 !== peg$FAILED) {\n                  s4.push(s5);\n                  if (peg$c37.test(input.charAt(peg$currPos))) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                  }\n                }\n              } else {\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parse_();\n                if (s5 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s6 = peg$c98;\n                    peg$currPos++;\n                  } else {\n                    s6 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                  }\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parse_();\n                    if (s7 !== peg$FAILED) {\n                      s8 = [];\n                      if (peg$c37.test(input.charAt(peg$currPos))) {\n                        s9 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        while (s9 !== peg$FAILED) {\n                          s8.push(s9);\n                          if (peg$c37.test(input.charAt(peg$currPos))) {\n                            s9 = input.charAt(peg$currPos);\n                            peg$currPos++;\n                          } else {\n                            s9 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                          }\n                        }\n                      } else {\n                        s8 = peg$FAILED;\n                      }\n                      if (s8 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 41) {\n                          s9 = peg$c85;\n                          peg$currPos++;\n                        } else {\n                          s9 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                        }\n                        if (s9 !== peg$FAILED) {\n                          s3 = [s3, s4, s5, s6, s7, s8, s9];\n                          s2 = s3;\n                        } else {\n                          peg$currPos = s2;\n                          s2 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s2;\n                        s2 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s2;\n                      s2 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = null;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c278();\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c295) {\n              s1 = input.substr(peg$currPos, 7);\n              peg$currPos += 7;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c296); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c297) {\n                s1 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c298); }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c299) {\n                  s1 = input.substr(peg$currPos, 4);\n                  peg$currPos += 4;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c300); }\n                }\n              }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s3 = peg$c81;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c82); }\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = [];\n                if (peg$c37.test(input.charAt(peg$currPos))) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                }\n                if (s5 !== peg$FAILED) {\n                  while (s5 !== peg$FAILED) {\n                    s4.push(s5);\n                    if (peg$c37.test(input.charAt(peg$currPos))) {\n                      s5 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                    }\n                  }\n                } else {\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c85;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s3 = [s3, s4, s5];\n                    s2 = s3;\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n              if (s2 === peg$FAILED) {\n                s2 = null;\n              }\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c301();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 8).toLowerCase() === peg$c302) {\n                s0 = input.substr(peg$currPos, 8);\n                peg$currPos += 8;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c303); }\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c57) {\n                  s1 = input.substr(peg$currPos, 4);\n                  peg$currPos += 4;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c304();\n                }\n                s0 = s1;\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecreateTableStmt_ignore() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      var key    = peg$currPos * 113 + 77,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c305.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c306); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c305.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c306); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c307();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c81;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_nc();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsedumpTableName();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_nc();\n              if (s4 !== peg$FAILED) {\n                s5 = [];\n                s6 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s7 = peg$c98;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_nc();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsedumpTableName();\n                    if (s9 !== peg$FAILED) {\n                      s7 = [s7, s8, s9];\n                      s6 = s7;\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s7 = peg$c98;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse_nc();\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parsedumpTableName();\n                      if (s9 !== peg$FAILED) {\n                        s7 = [s7, s8, s9];\n                        s6 = s7;\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse_nc();\n                  if (s6 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 41) {\n                      s7 = peg$c85;\n                      peg$currPos++;\n                    } else {\n                      s7 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                    }\n                    if (s7 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c307();\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsedumpTableName();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c307();\n          }\n          s0 = s1;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecreateTableStmt_column() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 113 + 78,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsedumpTableName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__nc();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsecreateTableStmt_columnType();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$currPos;\n            s6 = peg$parse__nc();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsecreateTableStmt_ignore();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parse__nc();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsecreateTableStmt_ignore();\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c308(s1, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecreateTableStmt_list() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n\n      var key    = peg$currPos * 113 + 79,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c81;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c82); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_nc();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsecreateTableStmt_column();\n          if (s3 === peg$FAILED) {\n            s3 = [];\n            s4 = peg$currPos;\n            s5 = peg$parse_nc();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecreateTableStmt_ignore();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$currPos;\n                s5 = peg$parse_nc();\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parsecreateTableStmt_ignore();\n                  if (s6 !== peg$FAILED) {\n                    s5 = [s5, s6];\n                    s4 = s5;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              }\n            } else {\n              s3 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$currPos;\n            s6 = peg$parse_nc();\n            if (s6 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s7 = peg$c98;\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c99); }\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parse_nc();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parsecreateTableStmt_column();\n                  if (s9 === peg$FAILED) {\n                    s9 = [];\n                    s10 = peg$currPos;\n                    s11 = peg$parse_nc();\n                    if (s11 !== peg$FAILED) {\n                      s12 = peg$parsecreateTableStmt_ignore();\n                      if (s12 !== peg$FAILED) {\n                        s11 = [s11, s12];\n                        s10 = s11;\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s10;\n                      s10 = peg$FAILED;\n                    }\n                    if (s10 !== peg$FAILED) {\n                      while (s10 !== peg$FAILED) {\n                        s9.push(s10);\n                        s10 = peg$currPos;\n                        s11 = peg$parse_nc();\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsecreateTableStmt_ignore();\n                          if (s12 !== peg$FAILED) {\n                            s11 = [s11, s12];\n                            s10 = s11;\n                          } else {\n                            peg$currPos = s10;\n                            s10 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s10;\n                          s10 = peg$FAILED;\n                        }\n                      }\n                    } else {\n                      s9 = peg$FAILED;\n                    }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s6 = [s6, s7, s8, s9];\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parse_nc();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s7 = peg$c98;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_nc();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsecreateTableStmt_column();\n                    if (s9 === peg$FAILED) {\n                      s9 = [];\n                      s10 = peg$currPos;\n                      s11 = peg$parse_nc();\n                      if (s11 !== peg$FAILED) {\n                        s12 = peg$parsecreateTableStmt_ignore();\n                        if (s12 !== peg$FAILED) {\n                          s11 = [s11, s12];\n                          s10 = s11;\n                        } else {\n                          peg$currPos = s10;\n                          s10 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s10;\n                        s10 = peg$FAILED;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        while (s10 !== peg$FAILED) {\n                          s9.push(s10);\n                          s10 = peg$currPos;\n                          s11 = peg$parse_nc();\n                          if (s11 !== peg$FAILED) {\n                            s12 = peg$parsecreateTableStmt_ignore();\n                            if (s12 !== peg$FAILED) {\n                              s11 = [s11, s12];\n                              s10 = s11;\n                            } else {\n                              peg$currPos = s10;\n                              s10 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s10;\n                            s10 = peg$FAILED;\n                          }\n                        }\n                      } else {\n                        s9 = peg$FAILED;\n                      }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s6 = [s6, s7, s8, s9];\n                      s5 = s6;\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_nc();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s6 = peg$c85;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c309(s3, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecreateTableStmt() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n      var key    = peg$currPos * 113 + 80,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c310) {\n        s1 = input.substr(peg$currPos, 6);\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c311); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c260) {\n            s3 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c261); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              if (input.substr(peg$currPos, 2).toLowerCase() === peg$c262) {\n                s6 = input.substr(peg$currPos, 2);\n                peg$currPos += 2;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c263); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse__();\n                if (s7 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 3).toLowerCase() === peg$c213) {\n                    s8 = input.substr(peg$currPos, 3);\n                    peg$currPos += 3;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c214); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parse__();\n                    if (s9 !== peg$FAILED) {\n                      if (input.substr(peg$currPos, 6) === peg$c248) {\n                        s10 = peg$c248;\n                        peg$currPos += 6;\n                      } else {\n                        s10 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c249); }\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parse__();\n                        if (s11 !== peg$FAILED) {\n                          s6 = [s6, s7, s8, s9, s10, s11];\n                          s5 = s6;\n                        } else {\n                          peg$currPos = s5;\n                          s5 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s5;\n                        s5 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsedumpTableName();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_nc();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parsecreateTableStmt_list();\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parse_nc();\n                      if (s9 !== peg$FAILED) {\n                        s10 = [];\n                        s11 = peg$currPos;\n                        s12 = peg$parse_nc();\n                        if (s12 !== peg$FAILED) {\n                          s13 = peg$parsecreateTableStmt_ignore();\n                          if (s13 !== peg$FAILED) {\n                            s12 = [s12, s13];\n                            s11 = s12;\n                          } else {\n                            peg$currPos = s11;\n                            s11 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s11;\n                          s11 = peg$FAILED;\n                        }\n                        while (s11 !== peg$FAILED) {\n                          s10.push(s11);\n                          s11 = peg$currPos;\n                          s12 = peg$parse_nc();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parsecreateTableStmt_ignore();\n                            if (s13 !== peg$FAILED) {\n                              s12 = [s12, s13];\n                              s11 = s12;\n                            } else {\n                              peg$currPos = s11;\n                              s11 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s11;\n                            s11 = peg$FAILED;\n                          }\n                        }\n                        if (s10 !== peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 59) {\n                            s11 = peg$c112;\n                            peg$currPos++;\n                          } else {\n                            s11 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c113); }\n                          }\n                          if (s11 !== peg$FAILED) {\n                            peg$savedPos = s0;\n                            s1 = peg$c312(s6, s8);\n                            s0 = s1;\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinsertStmt_value_null() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 81,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c313) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c314); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c307();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinsertStmt_values() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      var key    = peg$currPos * 113 + 82,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c81;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c82); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsenumber();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsestring();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsedateStr();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parseinsertStmt_value_null();\n              }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$currPos;\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s7 = peg$c98;\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c99); }\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parse_();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parsenumber();\n                  if (s9 === peg$FAILED) {\n                    s9 = peg$parsestring();\n                    if (s9 === peg$FAILED) {\n                      s9 = peg$parsedateStr();\n                      if (s9 === peg$FAILED) {\n                        s9 = peg$parseinsertStmt_value_null();\n                      }\n                    }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s6 = [s6, s7, s8, s9];\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s7 = peg$c98;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsenumber();\n                    if (s9 === peg$FAILED) {\n                      s9 = peg$parsestring();\n                      if (s9 === peg$FAILED) {\n                        s9 = peg$parsedateStr();\n                        if (s9 === peg$FAILED) {\n                          s9 = peg$parseinsertStmt_value_null();\n                        }\n                      }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s6 = [s6, s7, s8, s9];\n                      s5 = s6;\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s6 = peg$c85;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c315(s3, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinsertStmt() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;\n\n      var key    = peg$currPos * 113 + 83,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c316) {\n        s1 = input.substr(peg$currPos, 6);\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c317); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c318) {\n            s3 = input.substr(peg$currPos, 4);\n            peg$currPos += 4;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c319); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsedumpTableName();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse__();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$currPos;\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 40) {\n                      s9 = peg$c81;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c82); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse_();\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parsedumpTableName();\n                        if (s11 !== peg$FAILED) {\n                          s12 = [];\n                          s13 = peg$currPos;\n                          s14 = peg$parse_();\n                          if (s14 !== peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 44) {\n                              s15 = peg$c98;\n                              peg$currPos++;\n                            } else {\n                              s15 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                            }\n                            if (s15 !== peg$FAILED) {\n                              s16 = peg$parse_();\n                              if (s16 !== peg$FAILED) {\n                                s17 = peg$parsedumpTableName();\n                                if (s17 !== peg$FAILED) {\n                                  s14 = [s14, s15, s16, s17];\n                                  s13 = s14;\n                                } else {\n                                  peg$currPos = s13;\n                                  s13 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s13;\n                                s13 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s13;\n                              s13 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s13;\n                            s13 = peg$FAILED;\n                          }\n                          if (s13 !== peg$FAILED) {\n                            while (s13 !== peg$FAILED) {\n                              s12.push(s13);\n                              s13 = peg$currPos;\n                              s14 = peg$parse_();\n                              if (s14 !== peg$FAILED) {\n                                if (input.charCodeAt(peg$currPos) === 44) {\n                                  s15 = peg$c98;\n                                  peg$currPos++;\n                                } else {\n                                  s15 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                                }\n                                if (s15 !== peg$FAILED) {\n                                  s16 = peg$parse_();\n                                  if (s16 !== peg$FAILED) {\n                                    s17 = peg$parsedumpTableName();\n                                    if (s17 !== peg$FAILED) {\n                                      s14 = [s14, s15, s16, s17];\n                                      s13 = s14;\n                                    } else {\n                                      peg$currPos = s13;\n                                      s13 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s13;\n                                    s13 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s13;\n                                  s13 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s13;\n                                s13 = peg$FAILED;\n                              }\n                            }\n                          } else {\n                            s12 = peg$FAILED;\n                          }\n                          if (s12 !== peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 41) {\n                              s13 = peg$c85;\n                              peg$currPos++;\n                            } else {\n                              s13 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                            }\n                            if (s13 !== peg$FAILED) {\n                              s14 = peg$parse__();\n                              if (s14 !== peg$FAILED) {\n                                s8 = [s8, s9, s10, s11, s12, s13, s14];\n                                s7 = s8;\n                              } else {\n                                peg$currPos = s7;\n                                s7 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s7;\n                              s7 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s7;\n                            s7 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s7;\n                          s7 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s7;\n                        s7 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                  if (s7 === peg$FAILED) {\n                    s7 = null;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c320) {\n                      s8 = input.substr(peg$currPos, 6);\n                      peg$currPos += 6;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c321); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parse_();\n                      if (s9 !== peg$FAILED) {\n                        s10 = peg$parseinsertStmt_values();\n                        if (s10 !== peg$FAILED) {\n                          s11 = [];\n                          s12 = peg$currPos;\n                          s13 = peg$parse_();\n                          if (s13 !== peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 44) {\n                              s14 = peg$c98;\n                              peg$currPos++;\n                            } else {\n                              s14 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                            }\n                            if (s14 !== peg$FAILED) {\n                              s15 = peg$parse_();\n                              if (s15 !== peg$FAILED) {\n                                s16 = peg$parseinsertStmt_values();\n                                if (s16 !== peg$FAILED) {\n                                  s13 = [s13, s14, s15, s16];\n                                  s12 = s13;\n                                } else {\n                                  peg$currPos = s12;\n                                  s12 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s12;\n                                s12 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s12;\n                              s12 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s12;\n                            s12 = peg$FAILED;\n                          }\n                          while (s12 !== peg$FAILED) {\n                            s11.push(s12);\n                            s12 = peg$currPos;\n                            s13 = peg$parse_();\n                            if (s13 !== peg$FAILED) {\n                              if (input.charCodeAt(peg$currPos) === 44) {\n                                s14 = peg$c98;\n                                peg$currPos++;\n                              } else {\n                                s14 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                              }\n                              if (s14 !== peg$FAILED) {\n                                s15 = peg$parse_();\n                                if (s15 !== peg$FAILED) {\n                                  s16 = peg$parseinsertStmt_values();\n                                  if (s16 !== peg$FAILED) {\n                                    s13 = [s13, s14, s15, s16];\n                                    s12 = s13;\n                                  } else {\n                                    peg$currPos = s12;\n                                    s12 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s12;\n                                  s12 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s12;\n                                s12 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s12;\n                              s12 = peg$FAILED;\n                            }\n                          }\n                          if (s11 !== peg$FAILED) {\n                            s12 = peg$parse_();\n                            if (s12 !== peg$FAILED) {\n                              if (input.charCodeAt(peg$currPos) === 59) {\n                                s13 = peg$c112;\n                                peg$currPos++;\n                              } else {\n                                s13 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c113); }\n                              }\n                              if (s13 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$c322(s5, s7, s10, s11);\n                                s0 = s1;\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsebooleanExpr() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 84,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      peg$silentFails++;\n      s0 = peg$parseexpr_precedence9();\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c323); }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_boolean_disj() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 113 + 85,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseor();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr_precedence8();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c324(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_string_concat() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 113 + 86,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c325) {\n          s2 = peg$c325;\n          peg$currPos += 2;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c326); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence8();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c327(s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_boolean_xdisj() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 113 + 87,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsexor();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr_precedence7();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c328(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_boolean_conj() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 113 + 88,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseand();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr_precedence6();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c329(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_boolean_comparison() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 113 + 89,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsecomparisonOperatorsIsOrIsNot();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsevalueExprConstantNull();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c330(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsecomparisonOperators();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseexpr_precedence4();\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c330(s2, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c331) {\n              s2 = input.substr(peg$currPos, 4);\n              peg$currPos += 4;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c332); }\n            }\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c333) {\n                s2 = input.substr(peg$currPos, 5);\n                peg$currPos += 5;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c334); }\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parsevalueExprConstants();\n                if (s4 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c335(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_number_add() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 113 + 90,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c35;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c36); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 43) {\n            s2 = peg$c336;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c337); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence3();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c338(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_rest_number_mul() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 113 + 91,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s2 = peg$c67;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c68); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s2 = peg$c339;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c340); }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 37) {\n              s2 = peg$c341;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c342); }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence2();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c343(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_number_minus() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 92,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c35;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c36); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseexpr_precedence1();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c344(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_boolean_negation() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 113 + 93,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenot();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr_precedence0();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c345(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprFunctionsNary() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      var key    = peg$currPos * 113 + 94,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c346) {\n        s2 = input.substr(peg$currPos, 8);\n        peg$currPos += 8;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c347); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c348();\n      }\n      s1 = s2;\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c349) {\n          s2 = input.substr(peg$currPos, 6);\n          peg$currPos += 6;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c350); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c351();\n        }\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c81;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence9();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = [];\n                s7 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s8 = peg$c98;\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parse_();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parseexpr_precedence9();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parse_();\n                      if (s11 !== peg$FAILED) {\n                        s8 = [s8, s9, s10, s11];\n                        s7 = s8;\n                      } else {\n                        peg$currPos = s7;\n                        s7 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                while (s7 !== peg$FAILED) {\n                  s6.push(s7);\n                  s7 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s8 = peg$c98;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parse_();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parseexpr_precedence9();\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parse_();\n                        if (s11 !== peg$FAILED) {\n                          s8 = [s8, s9, s10, s11];\n                          s7 = s8;\n                        } else {\n                          peg$currPos = s7;\n                          s7 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s7;\n                        s7 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s7 = peg$c85;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c352(s1, s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprFunctionsBinary() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n      var key    = peg$currPos * 113 + 95,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c353) {\n        s2 = input.substr(peg$currPos, 7);\n        peg$currPos += 7;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c354); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c355();\n      }\n      s1 = s2;\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c356) {\n          s2 = input.substr(peg$currPos, 7);\n          peg$currPos += 7;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c357); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c358();\n        }\n        s1 = s2;\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c359) {\n            s2 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c360); }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c361();\n          }\n          s1 = s2;\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c362) {\n              s2 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c363); }\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s2 = peg$c364();\n            }\n            s1 = s2;\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c365) {\n                s2 = input.substr(peg$currPos, 3);\n                peg$currPos += 3;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c366); }\n              }\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s2 = peg$c367();\n              }\n              s1 = s2;\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c368) {\n                  s2 = input.substr(peg$currPos, 3);\n                  peg$currPos += 3;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c369); }\n                }\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s1;\n                  s2 = peg$c370();\n                }\n                s1 = s2;\n                if (s1 === peg$FAILED) {\n                  s1 = peg$currPos;\n                  if (input.substr(peg$currPos, 3).toLowerCase() === peg$c371) {\n                    s2 = input.substr(peg$currPos, 3);\n                    peg$currPos += 3;\n                  } else {\n                    s2 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c372); }\n                  }\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s1;\n                    s2 = peg$c373();\n                  }\n                  s1 = s2;\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c81;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence9();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s6 = peg$c98;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c99); }\n                }\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parseexpr_precedence9();\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parse_();\n                      if (s9 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 41) {\n                          s10 = peg$c85;\n                          peg$currPos++;\n                        } else {\n                          s10 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                        }\n                        if (s10 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c374(s1, s4, s8);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprFunctionsUnary() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 113 + 96,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c375) {\n        s2 = input.substr(peg$currPos, 5);\n        peg$currPos += 5;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c376); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c377();\n      }\n      s1 = s2;\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c378) {\n          s2 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c379); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c377();\n        }\n        s1 = s2;\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c380) {\n            s2 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c381); }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c382();\n          }\n          s1 = s2;\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c383) {\n              s2 = input.substr(peg$currPos, 5);\n              peg$currPos += 5;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c384); }\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s2 = peg$c382();\n            }\n            s1 = s2;\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              if (input.substr(peg$currPos, 6).toLowerCase() === peg$c385) {\n                s2 = input.substr(peg$currPos, 6);\n                peg$currPos += 6;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c386); }\n              }\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s2 = peg$c387();\n              }\n              s1 = s2;\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c388) {\n                  s2 = input.substr(peg$currPos, 3);\n                  peg$currPos += 3;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c389); }\n                }\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s1;\n                  s2 = peg$c390();\n                }\n                s1 = s2;\n                if (s1 === peg$FAILED) {\n                  s1 = peg$currPos;\n                  if (input.substr(peg$currPos, 5).toLowerCase() === peg$c391) {\n                    s2 = input.substr(peg$currPos, 5);\n                    peg$currPos += 5;\n                  } else {\n                    s2 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c392); }\n                  }\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s1;\n                    s2 = peg$c393();\n                  }\n                  s1 = s2;\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$currPos;\n                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c394) {\n                      s2 = input.substr(peg$currPos, 4);\n                      peg$currPos += 4;\n                    } else {\n                      s2 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c395); }\n                    }\n                    if (s2 !== peg$FAILED) {\n                      peg$savedPos = s1;\n                      s2 = peg$c396();\n                    }\n                    s1 = s2;\n                    if (s1 === peg$FAILED) {\n                      s1 = peg$currPos;\n                      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c397) {\n                        s2 = input.substr(peg$currPos, 5);\n                        peg$currPos += 5;\n                      } else {\n                        s2 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c398); }\n                      }\n                      if (s2 !== peg$FAILED) {\n                        peg$savedPos = s1;\n                        s2 = peg$c399();\n                      }\n                      s1 = s2;\n                      if (s1 === peg$FAILED) {\n                        s1 = peg$currPos;\n                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c57) {\n                          s2 = input.substr(peg$currPos, 4);\n                          peg$currPos += 4;\n                        } else {\n                          s2 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                        }\n                        if (s2 !== peg$FAILED) {\n                          peg$savedPos = s1;\n                          s2 = peg$c400();\n                        }\n                        s1 = s2;\n                        if (s1 === peg$FAILED) {\n                          s1 = peg$currPos;\n                          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c401) {\n                            s2 = input.substr(peg$currPos, 4);\n                            peg$currPos += 4;\n                          } else {\n                            s2 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c402); }\n                          }\n                          if (s2 !== peg$FAILED) {\n                            peg$savedPos = s1;\n                            s2 = peg$c403();\n                          }\n                          s1 = s2;\n                          if (s1 === peg$FAILED) {\n                            s1 = peg$currPos;\n                            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c404) {\n                              s2 = input.substr(peg$currPos, 5);\n                              peg$currPos += 5;\n                            } else {\n                              s2 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c405); }\n                            }\n                            if (s2 !== peg$FAILED) {\n                              peg$savedPos = s1;\n                              s2 = peg$c406();\n                            }\n                            s1 = s2;\n                            if (s1 === peg$FAILED) {\n                              s1 = peg$currPos;\n                              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c407) {\n                                s2 = input.substr(peg$currPos, 3);\n                                peg$currPos += 3;\n                              } else {\n                                s2 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c408); }\n                              }\n                              if (s2 !== peg$FAILED) {\n                                peg$savedPos = s1;\n                                s2 = peg$c409();\n                              }\n                              s1 = s2;\n                              if (s1 === peg$FAILED) {\n                                s1 = peg$currPos;\n                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c410) {\n                                  s2 = input.substr(peg$currPos, 4);\n                                  peg$currPos += 4;\n                                } else {\n                                  s2 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c411); }\n                                }\n                                if (s2 !== peg$FAILED) {\n                                  peg$savedPos = s1;\n                                  s2 = peg$c412();\n                                }\n                                s1 = s2;\n                                if (s1 === peg$FAILED) {\n                                  s1 = peg$currPos;\n                                  if (input.substr(peg$currPos, 6).toLowerCase() === peg$c413) {\n                                    s2 = input.substr(peg$currPos, 6);\n                                    peg$currPos += 6;\n                                  } else {\n                                    s2 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c414); }\n                                  }\n                                  if (s2 !== peg$FAILED) {\n                                    peg$savedPos = s1;\n                                    s2 = peg$c415();\n                                  }\n                                  s1 = s2;\n                                  if (s1 === peg$FAILED) {\n                                    s1 = peg$currPos;\n                                    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c416) {\n                                      s2 = input.substr(peg$currPos, 6);\n                                      peg$currPos += 6;\n                                    } else {\n                                      s2 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c417); }\n                                    }\n                                    if (s2 !== peg$FAILED) {\n                                      peg$savedPos = s1;\n                                      s2 = peg$c418();\n                                    }\n                                    s1 = s2;\n                                    if (s1 === peg$FAILED) {\n                                      s1 = peg$currPos;\n                                      if (input.substr(peg$currPos, 10).toLowerCase() === peg$c419) {\n                                        s2 = input.substr(peg$currPos, 10);\n                                        peg$currPos += 10;\n                                      } else {\n                                        s2 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$c420); }\n                                      }\n                                      if (s2 !== peg$FAILED) {\n                                        peg$savedPos = s1;\n                                        s2 = peg$c409();\n                                      }\n                                      s1 = s2;\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c81;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseexpr_precedence9();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s6 = peg$c85;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c421(s1, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprFunctionsNullary() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 113 + 97,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c422) {\n        s2 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c423); }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c424();\n      }\n      s1 = s2;\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c425) {\n          s2 = input.substr(peg$currPos, 6);\n          peg$currPos += 6;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c426); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c427();\n        }\n        s1 = s2;\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c428) {\n            s2 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c429); }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c430();\n          }\n          s1 = s2;\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            if (input.substr(peg$currPos, 17).toLowerCase() === peg$c431) {\n              s2 = input.substr(peg$currPos, 17);\n              peg$currPos += 17;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c432); }\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s1;\n              s2 = peg$c430();\n            }\n            s1 = s2;\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              if (input.substr(peg$currPos, 21).toLowerCase() === peg$c433) {\n                s2 = input.substr(peg$currPos, 21);\n                peg$currPos += 21;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c434); }\n              }\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s1;\n                s2 = peg$c435();\n              }\n              s1 = s2;\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                if (input.substr(peg$currPos, 19).toLowerCase() === peg$c436) {\n                  s2 = input.substr(peg$currPos, 19);\n                  peg$currPos += 19;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c437); }\n                }\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s1;\n                  s2 = peg$c438();\n                }\n                s1 = s2;\n                if (s1 === peg$FAILED) {\n                  s1 = peg$currPos;\n                  if (input.substr(peg$currPos, 15).toLowerCase() === peg$c439) {\n                    s2 = input.substr(peg$currPos, 15);\n                    peg$currPos += 15;\n                  } else {\n                    s2 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c440); }\n                  }\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s1;\n                    s2 = peg$c441();\n                  }\n                  s1 = s2;\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$currPos;\n                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c442) {\n                      s2 = input.substr(peg$currPos, 7);\n                      peg$currPos += 7;\n                    } else {\n                      s2 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c443); }\n                    }\n                    if (s2 !== peg$FAILED) {\n                      peg$savedPos = s1;\n                      s2 = peg$c441();\n                    }\n                    s1 = s2;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c81;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s4 = peg$c85;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c86); }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c444(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprConstants() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 113 + 98,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s1;\n        s2 = peg$c445(s2);\n      }\n      s1 = s2;\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parseboolean();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c446(s2);\n        }\n        s1 = s2;\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parsestring();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c447(s2);\n          }\n          s1 = s2;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c448(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsevalueExprConstantNull();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprConstantNull() {\n      var s0, s1;\n\n      var key    = peg$currPos * 113 + 99,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c313) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c314); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c449(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprColumn() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 100,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsecolumnName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s3 = peg$c81;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n        }\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = void 0;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c450(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevalueExprCaseWhen() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      var key    = peg$currPos * 113 + 101,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c451) {\n        s1 = input.substr(peg$currPos, 4);\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c452); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c453) {\n            s5 = input.substr(peg$currPos, 4);\n            peg$currPos += 4;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c454); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse__();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseexpr_precedence5();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parse__();\n                if (s8 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c455) {\n                    s9 = input.substr(peg$currPos, 4);\n                    peg$currPos += 4;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c456); }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parse__();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parseexpr_precedence5();\n                      if (s11 !== peg$FAILED) {\n                        peg$savedPos = s3;\n                        s4 = peg$c457(s7, s11);\n                        s3 = s4;\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c453) {\n                s5 = input.substr(peg$currPos, 4);\n                peg$currPos += 4;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c454); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse__();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseexpr_precedence5();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse__();\n                    if (s8 !== peg$FAILED) {\n                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c455) {\n                        s9 = input.substr(peg$currPos, 4);\n                        peg$currPos += 4;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c456); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        s10 = peg$parse__();\n                        if (s10 !== peg$FAILED) {\n                          s11 = peg$parseexpr_precedence5();\n                          if (s11 !== peg$FAILED) {\n                            peg$savedPos = s3;\n                            s4 = peg$c457(s7, s11);\n                            s3 = s4;\n                          } else {\n                            peg$currPos = s3;\n                            s3 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s3;\n                          s3 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c458) {\n              s5 = input.substr(peg$currPos, 4);\n              peg$currPos += 4;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c459); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse__();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseexpr_precedence5();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c460(s2, s7);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse__();\n            if (s4 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 3).toLowerCase() === peg$c461) {\n                s5 = input.substr(peg$currPos, 3);\n                peg$currPos += 3;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c462); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c463(s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence9() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 102,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence8();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_boolean_disj();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseexpr_rest_string_concat();\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_boolean_disj();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parseexpr_rest_string_concat();\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c464(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence8();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence8() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 103,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence7();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_boolean_xdisj();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_boolean_xdisj();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c464(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence7();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence7() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 104,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence6();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_boolean_conj();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_boolean_conj();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c464(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence6();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence6() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 105,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsevalueExprCaseWhen();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence5();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence5() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 106,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence4();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_boolean_comparison();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_boolean_comparison();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c464(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence4();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence4() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 107,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence3();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_number_add();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_number_add();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c464(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence3();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence3() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 113 + 108,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseexpr_precedence2();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseexpr_rest_number_mul();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseexpr_rest_number_mul();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c464(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence2();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence2() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 109,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parseexpr_number_minus();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence1();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence1() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 110,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parseexpr_boolean_negation();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseexpr_precedence0();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexpr_precedence0() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 113 + 111,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsevalueExprConstants();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsevalueExprCaseWhen();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsevalueExprFunctionsNullary();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsevalueExprFunctionsUnary();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsevalueExprFunctionsBinary();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsevalueExprFunctionsNary();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsevalueExprColumn();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 40) {\n                      s1 = peg$c81;\n                      peg$currPos++;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c82); }\n                    }\n                    if (s1 !== peg$FAILED) {\n                      s2 = peg$parse_();\n                      if (s2 !== peg$FAILED) {\n                        s3 = peg$parseexpr_precedence9();\n                        if (s3 !== peg$FAILED) {\n                          s4 = peg$parse_();\n                          if (s4 !== peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 41) {\n                              s5 = peg$c85;\n                              peg$currPos++;\n                            } else {\n                              s5 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                            }\n                            if (s5 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s1 = peg$c135(s3);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseRESERVED_KEYWORD_RELALG() {\n      var s0;\n\n      var key    = peg$currPos * 113 + 112,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c465) {\n        s0 = input.substr(peg$currPos, 2);\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c466); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c467) {\n          s0 = input.substr(peg$currPos, 5);\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c468); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c469) {\n            s0 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c470); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c471) {\n              s0 = input.substr(peg$currPos, 3);\n              peg$currPos += 3;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c472); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c473) {\n                s0 = input.substr(peg$currPos, 5);\n                peg$currPos += 5;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c474); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c234) {\n                  s0 = input.substr(peg$currPos, 3);\n                  peg$currPos += 3;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c235); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2).toLowerCase() === peg$c241) {\n                    s0 = input.substr(peg$currPos, 2);\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c242); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c213) {\n                      s0 = input.substr(peg$currPos, 3);\n                      peg$currPos += 3;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c214); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c136) {\n                        s0 = input.substr(peg$currPos, 5);\n                        peg$currPos += 5;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c137); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c143) {\n                          s0 = input.substr(peg$currPos, 9);\n                          peg$currPos += 9;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c144); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 6).toLowerCase() === peg$c140) {\n                            s0 = input.substr(peg$currPos, 6);\n                            peg$currPos += 6;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c141); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {\n                              s0 = input.substr(peg$currPos, 4);\n                              peg$currPos += 4;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c151); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c148) {\n                                s0 = input.substr(peg$currPos, 5);\n                                peg$currPos += 5;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c149); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c150) {\n                                  s0 = input.substr(peg$currPos, 4);\n                                  peg$currPos += 4;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c151); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c159) {\n                                    s0 = input.substr(peg$currPos, 4);\n                                    peg$currPos += 4;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c160); }\n                                  }\n                                  if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c164) {\n                                      s0 = input.substr(peg$currPos, 5);\n                                      peg$currPos += 5;\n                                    } else {\n                                      s0 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c165); }\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c161) {\n                                        s0 = input.substr(peg$currPos, 5);\n                                        peg$currPos += 5;\n                                      } else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$c162); }\n                                      }\n                                      if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c167) {\n                                          s0 = input.substr(peg$currPos, 4);\n                                          peg$currPos += 4;\n                                        } else {\n                                          s0 = peg$FAILED;\n                                          if (peg$silentFails === 0) { peg$fail(peg$c168); }\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                          if (input.substr(peg$currPos, 6).toLowerCase() === peg$c475) {\n                                            s0 = input.substr(peg$currPos, 6);\n                                            peg$currPos += 6;\n                                          } else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) { peg$fail(peg$c476); }\n                                          }\n                                          if (s0 === peg$FAILED) {\n                                            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c477) {\n                                              s0 = input.substr(peg$currPos, 4);\n                                              peg$currPos += 4;\n                                            } else {\n                                              s0 = peg$FAILED;\n                                              if (peg$silentFails === 0) { peg$fail(peg$c478); }\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c479) {\n                                                s0 = input.substr(peg$currPos, 4);\n                                                peg$currPos += 4;\n                                              } else {\n                                                s0 = peg$FAILED;\n                                                if (peg$silentFails === 0) { peg$fail(peg$c480); }\n                                              }\n                                              if (s0 === peg$FAILED) {\n                                                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c105) {\n                                                  s0 = input.substr(peg$currPos, 4);\n                                                  peg$currPos += 4;\n                                                } else {\n                                                  s0 = peg$FAILED;\n                                                  if (peg$silentFails === 0) { peg$fail(peg$c106); }\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                  if (input.substr(peg$currPos, 3).toLowerCase() === peg$c102) {\n                                                    s0 = input.substr(peg$currPos, 3);\n                                                    peg$currPos += 3;\n                                                  } else {\n                                                    s0 = peg$FAILED;\n                                                    if (peg$silentFails === 0) { peg$fail(peg$c103); }\n                                                  }\n                                                  if (s0 === peg$FAILED) {\n                                                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c451) {\n                                                      s0 = input.substr(peg$currPos, 4);\n                                                      peg$currPos += 4;\n                                                    } else {\n                                                      s0 = peg$FAILED;\n                                                      if (peg$silentFails === 0) { peg$fail(peg$c452); }\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c453) {\n                                                        s0 = input.substr(peg$currPos, 4);\n                                                        peg$currPos += 4;\n                                                      } else {\n                                                        s0 = peg$FAILED;\n                                                        if (peg$silentFails === 0) { peg$fail(peg$c454); }\n                                                      }\n                                                      if (s0 === peg$FAILED) {\n                                                        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c455) {\n                                                          s0 = input.substr(peg$currPos, 4);\n                                                          peg$currPos += 4;\n                                                        } else {\n                                                          s0 = peg$FAILED;\n                                                          if (peg$silentFails === 0) { peg$fail(peg$c456); }\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c458) {\n                                                            s0 = input.substr(peg$currPos, 4);\n                                                            peg$currPos += 4;\n                                                          } else {\n                                                            s0 = peg$FAILED;\n                                                            if (peg$silentFails === 0) { peg$fail(peg$c459); }\n                                                          }\n                                                          if (s0 === peg$FAILED) {\n                                                            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c461) {\n                                                              s0 = input.substr(peg$currPos, 3);\n                                                              peg$currPos += 3;\n                                                            } else {\n                                                              s0 = peg$FAILED;\n                                                              if (peg$silentFails === 0) { peg$fail(peg$c462); }\n                                                            }\n                                                            if (s0 === peg$FAILED) {\n                                                              if (input.substr(peg$currPos, 4).toLowerCase() === peg$c43) {\n                                                                s0 = input.substr(peg$currPos, 4);\n                                                                peg$currPos += 4;\n                                                              } else {\n                                                                s0 = peg$FAILED;\n                                                                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n                                                              }\n                                                              if (s0 === peg$FAILED) {\n                                                                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c46) {\n                                                                  s0 = input.substr(peg$currPos, 5);\n                                                                  peg$currPos += 5;\n                                                                } else {\n                                                                  s0 = peg$FAILED;\n                                                                  if (peg$silentFails === 0) { peg$fail(peg$c47); }\n                                                                }\n                                                                if (s0 === peg$FAILED) {\n                                                                  if (input.substr(peg$currPos, 4).toLowerCase() === peg$c313) {\n                                                                    s0 = input.substr(peg$currPos, 4);\n                                                                    peg$currPos += 4;\n                                                                  } else {\n                                                                    s0 = peg$FAILED;\n                                                                    if (peg$silentFails === 0) { peg$fail(peg$c314); }\n                                                                  }\n                                                                }\n                                                              }\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n    \t// fallback for debugging when i18n is not defined\n    \t/*if(typeof(i18n) === \'undefined\'){\n    \t\tvar i18n = {\n    \t\t\tt: function(key, obj){\n    \t\t\t\tobj = obj || {};\n    \t\t\t\treturn key+\' \'+JSON.stringify(obj);\n    \t\t\t}\n    \t\t};\n    \t}*/\n\n    \tfunction getCodeInfo(){\n    \t\treturn {\n    \t\t\tlocation: location(),\n    \t\t\ttext: text()\n    \t\t};\n    \t}\n\n    \tfunction checkAssignments(assignments){\n    \t\t// check if the defined variable names are unique\n    \t\tvar tmp = {}, name;\n\n    \t\tfor(var i = 0; i < assignments.length; i++){\n    \t\t\tname = assignments[i].name;\n    \t\t\tif(tmp[name])\n    \t\t\t\terror(i18n.t(\'db.messages.parser.error-duplicate-variable\', {name: name}));\n\n    \t\t\ttmp[name] = true;\n    \t\t}\n    \t};\n    \t\n    \t// builds a binary valueExpression (fills the args array)\n    \tfunction buildBinaryValueExpr(first, rest){\n    \t\t// all members of rest have a member args in the form [undefined, child2]\n    \t\t\n    \t\tvar root = rest[0];\n    \t\troot.args[0] = first;\n    \t\troot.codeInfo = getCodeInfo();\n    \t\t\n    \t\tvar n;\n    \t\tfor(var i = 1; i < rest.length; i++){\n    \t\t\tn = rest[i];\n    \t\t\t\n    \t\t\tn.args[0] = root;\n    \t\t\tn.codeInfo = getCodeInfo();\n    \t\t\t\n    \t\t\troot = n;\n    \t\t}\n    \t\t\n    \t\treturn root;\n    \t}\n    \t\n    \tfunction buildBinary(first, rest){\n    \t\t// all members of rest have a child2\n    \t\t\n    \t\tvar root = rest[0];\n    \t\troot.child = first;\n    \t\troot.codeInfo = getCodeInfo();\n    \t\t\n    \t\tvar n;\n    \t\tfor(var i = 1; i < rest.length; i++){\n    \t\t\tn = rest[i];\n    \t\t\t\n    \t\t\tn.child = root;\n    \t\t\tn.codeInfo = getCodeInfo();\n    \t\t\t\n    \t\t\troot = n;\n    \t\t}\n    \t\t\n    \t\treturn root;\n    \t}\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: "end", description: "end of input" });\n      }\n\n      throw peg$buildException(\n        null,\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})();\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/parser/grammar_sql.pegjs\n// module id = 154\n// module chunks = 0 1\n//# sourceURL=webpack:///./src/db/parser/grammar_sql.pegjs?');
},,,,,,,function(module,exports,__webpack_require__){eval("'use strict';\n\n__webpack_require__(162);\n__webpack_require__(163);\n__webpack_require__(164);\n__webpack_require__(165);\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/tests.entry.js\n// module id = 161\n// module chunks = 1\n//# sourceURL=webpack:///./src/db/tests.entry.js?")},function(module,exports){eval("'use strict';\n\nvar resources = {\n\t'en': {\n\t\ttranslation: {\n\t\t\t'key': 'key',\n\t\t\t'key_plural': 'keys',\n\t\t\t'house': 'house',\n\t\t\t'house_plural': 'houses',\n\t\t\t'fallback': 'fallback',\n\t\t\t'myHouse': 'my house',\n\t\t\t'myHouse_plural': 'my __count__ houses'\n\t\t}\n\t},\n\t'de': {\n\t\ttranslation: {\n\t\t\t'key': 'key',\n\t\t\t'key_plural': 'keys',\n\t\t\t'house': 'Haus',\n\t\t\t'house_plural': 'Häuser',\n\t\t\t'namespace1': {\n\t\t\t\t'mouse': 'Maus'\n\t\t\t},\n\t\t\t'hello x': 'hello __x__!',\n\t\t\t'myHouse': 'Mein $t(house)',\n\t\t\t'myHouse_plural': 'Meine __count__ $t(house_plural)'\n\t\t}\n\t}\n};\n\ni18n.init({\n\tresStore: resources,\n\tfallbackLng: 'en',\n\tlng: 'de',\n\tdebug: false\n}, function (t, err) {\n\tQUnit.module('i18n');\n\n\ttest('simple translation', function () {\n\t\tequal(i18n.t('house'), 'Haus');\n\t});\n\n\ttest('plural', function () {\n\t\tequal(i18n.t('house', { count: 2 }), 'Häuser');\n\t});\n\n\ttest('fallback', function () {\n\t\tequal(i18n.t('fallback'), 'fallback');\n\t});\n\n\ttest('namespace', function () {\n\t\tequal(i18n.t('namespace1.mouse'), 'Maus');\n\t});\n\n\ttest('variables', function () {\n\t\tequal(i18n.t('hello x', { x: 'world' }), 'hello world!');\n\t});\n\n\ttest('nesting 1', function () {\n\t\tequal(i18n.t('myHouse'), 'Mein Haus');\n\t});\n\n\ttest('nesting 2 (plural)', function () {\n\t\tequal(i18n.t('myHouse', { count: 2 }), 'Meine 2 Häuser');\n\t});\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/tests/lang.js\n// module id = 162\n// module chunks = 1\n//# sourceURL=webpack:///./src/db/tests/lang.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _relalg = __webpack_require__(43);\n\nvar relalgjs = _interopRequireWildcard(_relalg);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nQUnit.module('translate relational algebra ast to relational algebra'); /* global QUnit, test, ok, equal, deepEqual, exec_ra, module */\n\nvar relations = {};\nvar srcTableR, srcTableS, srcTableT;\n\nfunction exec_ra(query, alternative_relations) {\n\treturn relalgjs.executeRelalg(query, alternative_relations || relations);\n}\n\nQUnit.testStart(function () {\n\t// create the three source tables\n\tsrcTableR = relalgjs.executeRelalg('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t1,   a,   d\\n\\t\\t3,   c,   c\\n\\t\\t4,   d,   f\\n\\t\\t5,   d,   b\\n\\t\\t6,   e,   f\\n\\t}', {});\n\n\tsrcTableS = relalgjs.executeRelalg('{\\n\\t\\tS.b, S.d\\n\\n\\t\\ta,   100\\n\\t\\tb,   300\\n\\t\\tc,   400\\n\\t\\td,   200\\n\\t\\te,   150\\n\\t}', {});\n\n\tsrcTableT = relalgjs.executeRelalg('{\\n\\t\\tT.b, T.d\\n\\n\\t\\ta,   100\\n\\t\\td,   200\\n\\t\\tf,   400\\n\\t\\tg,   120\\n\\t}', {});\n\n\trelations.R = srcTableR;\n\trelations.S = srcTableS;\n\trelations.T = srcTableT;\n});\n\ntest('test relation', function () {\n\tvar query = 'R';\n\tvar root = exec_ra(query);\n\troot.check();\n\n\tdeepEqual(root.getResult(), srcTableR.getResult());\n});\n\ntest('test inline-relation', function () {\n\tvar root = exec_ra('{\\n\\t\\tR.a:number, R.b:string, R.c:string\\n\\t\\t1,          a,          d\\n\\t\\t3,          \\'c\\',        \\'c\\'\\n\\t\\t4,          d,          f\\n\\t\\t5,          d,          b\\n\\t\\t6,          \\'e\\',        \\'f\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), srcTableR.getResult());\n});\n\ntest('test inline-relation 2', function () {\n\tvar root = exec_ra('{\\n\\t\\ta, b, c\\n\\t\\t-1, a, null\\n\\t\\t3.3, null, 2014-01-01\\n\\t\\t-3.3, null, 2014-01-01\\n\\t\\t\\'-3.3\\', null, null\\n\\t}');\n\tvar result = root.getResult();\n\n\tvar reference_rows = [[-1, 'a', null], [3.3, null, new Date(2014, 0, 1)], [-3.3, null, new Date(2014, 0, 1)], [-3.3, null, null]];\n\n\t// compare data\n\tdeepEqual(result.getRows(), reference_rows);\n\n\t// compare schema\n\tvar schema = result.getSchema();\n\tequal(schema.getType(0), 'number');\n\tequal(schema.getType(1), 'string');\n\tequal(schema.getType(2), 'date');\n\n\tequal(schema.getFullName(0), 'a');\n\tequal(schema.getFullName(1), 'b');\n\tequal(schema.getFullName(2), 'c');\n});\n\ntest('test inline-relation 3: booleans', function () {\n\tvar root = exec_ra('{\\n\\t\\ta, b, c:string\\n\\t\\ttrue, null, true\\n\\t\\tfalse, false, false\\n\\t}');\n\tvar result = root.getResult();\n\n\tvar reference_rows = [[true, null, 'true'], [false, false, 'false']];\n\n\t// compare data\n\tdeepEqual(result.getRows(), reference_rows);\n\n\t// compare schema\n\tvar schema = result.getSchema();\n\tequal(schema.getType(0), 'boolean');\n\tequal(schema.getType(1), 'boolean');\n\tequal(schema.getType(2), 'string');\n\n\tequal(schema.getFullName(0), 'a');\n\tequal(schema.getFullName(1), 'b');\n\tequal(schema.getFullName(2), 'c');\n});\n\ntest('test not existant relation', function () {\n\ttry {\n\t\tvar query = 'X';\n\t\texec_ra(query);\n\n\t\tok(false, 'table does not exist');\n\t} catch (e) {\n\t\tok(true, 'table not found');\n\t}\n});\n\ntest('test selection[true](R)', function () {\n\tvar query = 'sigma true (R)';\n\tvar root = exec_ra(query);\n\n\tdeepEqual(root.getResult(), srcTableR.getResult());\n});\n\ntest('test selection[a>=3](R)', function () {\n\tvar query = 'sigma a >= 3 (R)';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t3, \\'c\\', \\'c\\'\\n\\t\\t4, \\'d\\', \\'f\\'\\n\\t\\t5, \\'d\\', \\'b\\'\\n\\t\\t6, \\'e\\', \\'f\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test selection[not b=c](R)', function () {\n\tvar query = 'sigma ! (b=c) R';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t1, \\'a\\', \\'d\\'\\n\\t\\t4, \\'d\\', \\'f\\'\\n\\t\\t5, \\'d\\', \\'b\\'\\n\\t\\t6, \\'e\\', \\'f\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test selection[a = true]({})', function () {\n\tvar query = 'sigma a = true ({a, b\\ntrue, 1\\nfalse, 2})';\n\tvar root = exec_ra(query);\n\n\tvar reference = exec_ra('{\\n\\t\\ta:boolean, b:number\\n\\n\\t\\ttrue, 1\\n\\t}');\n\n\tdeepEqual(root.getResult(), reference.getResult());\n});\n\ntest('test selection[a>3 and a>-1](R)', function () {\n\tvar query = 'sigma a > 3 and a>-1 (R)';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t4, \\'d\\', \\'f\\'\\n\\t\\t5, \\'d\\', \\'b\\'\\n\\t\\t6, \\'e\\', \\'f\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test selection[a = 3 or b = \\'e\\'](R)', function () {\n\tvar query = \"sigma a = 3 or b = 'e' (R)\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t3, \\'c\\', \\'c\\'\\n\\t\\t6, \\'e\\', \\'f\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test selection with xor', function () {\n\tvar query = \"sigma b = \\'d\\' xor a = 4 (R)\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t5, \\'d\\', \\'b\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test projection[a, b](R)', function () {\n\tvar query = 'pi a, b (R)';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a, R.b\\n\\n\\t\\t1, \\'a\\'\\n\\t\\t3, \\'c\\'\\n\\t\\t4, \\'d\\'\\n\\t\\t5, \\'d\\'\\n\\t\\t6, \\'e\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test projection[b, a](R)', function () {\n\tvar query = 'pi b, a (R)';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.b, R.a\\n\\n\\t\\t\\'a\\', 1\\n\\t\\t\\'c\\', 3\\n\\t\\t\\'d\\', 4\\n\\t\\t\\'d\\', 5\\n\\t\\t\\'e\\', 6\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test projection[b, a, a, b](R)', function () {\n\tvar query = 'pi b, a, a, b (R)';\n\n\ttry {\n\t\texec_ra(query);\n\t\tok(false);\n\t} catch (e) {\n\t\tok(true);\n\t}\n});\n\ntest('test (R) inner join [R.b = S.b] join (S)', function () {\n\tvar root = exec_ra('(R) inner join R.b = S.b (S)');\n\tvar ref = exec_ra('{\\n\\t\\tR.a:number, R.b:string, R.c:string, S.b:string, S.d:number\\n\\n\\t\\t1,          \\'a\\',        \\'d\\',        \\'a\\',        100\\n\\t\\t3,          \\'c\\',        \\'c\\',        \\'c\\',        400\\n\\t\\t4,          \\'d\\',        \\'f\\',        \\'d\\',        200\\n\\t\\t5,          \\'d\\',        \\'b\\',        \\'d\\',        200\\n\\t\\t6,          \\'e\\',        \\'f\\',        \\'e\\',        150\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test rename relation', function () {\n\tvar root = exec_ra('pi t.a, b (rho t (R))');\n\n\tvar ref = exec_ra('{\\n\\t\\tt.a:number, t.b:string\\n\\n\\t\\t1, \\'a\\'\\n\\t\\t3, \\'c\\'\\n\\t\\t4, \\'d\\'\\n\\t\\t5, \\'d\\'\\n\\t\\t6, \\'e\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test rename column', function () {\n\tvar root = exec_ra('rho x<-a (pi t.a, t.b (rho t (R)))');\n\n\tvar ref = exec_ra('{\\n\\t\\tt.x:number, t.b:string\\n\\n\\t\\t1, \\'a\\'\\n\\t\\t3, \\'c\\'\\n\\t\\t4, \\'d\\'\\n\\t\\t5, \\'d\\'\\n\\t\\t6, \\'e\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test rename column 2', function () {\n\tvar query = \"rho b<-a, a<-b {a, b\\n1, 2\\n3, 4}\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tb:number, a:number\\n\\n\\t\\t1, 2\\n\\t\\t3, 4\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test rename column (non existant)', function () {\n\ttry {\n\t\tvar query = \"rho fail->x {a, b\\n1, 2\\n3, 4}\";\n\t\texec_ra(query);\n\n\t\tok(false);\n\t} catch (e) {\n\t\tok(true); // should fail\n\t}\n});\n\ntest('test union 0', function () {\n\tvar query = '(S) union (T)';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tS.b:string, S.d:number\\n\\n\\t\\t\\'a\\',        100\\n\\t\\t\\'b\\',        300\\n\\t\\t\\'c\\',        400\\n\\t\\t\\'d\\',        200\\n\\t\\t\\'e\\',        150\\n\\t\\t\\'f\\',        400\\n\\t\\t\\'g\\',        120\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test union 1', function () {\n\tvar query = '((R) union (R)) union (R)';\n\tvar root = exec_ra(query);\n\n\tvar ref = srcTableR.getResult();\n\n\tvar result = root.getResult();\n\tdeepEqual(result, ref);\n});\n\ntest('test intersect 0', function () {\n\tvar query = '(S) intersect (T)';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tS.b:string, S.d:number\\n\\n\\t\\t\\'a\\',        100\\n\\t\\t\\'d\\',        200\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test intersect 1', function () {\n\tvar query = '(S) intersect (S)';\n\tvar root = exec_ra(query);\n\n\tvar ref = srcTableS.getResult();\n\n\tvar result = root.getResult();\n\tdeepEqual(result, ref);\n});\n\ntest('test division 0', function () {\n\tvar srcTableB = exec_ra('{\\n\\t\\tB.b:string\\n\\n\\t\\tb1\\n\\t\\tb2\\n\\t\\tb3\\n\\t}');\n\tvar srcTableA = exec_ra('{\\n\\t\\tB.a:string, B.b:string\\n\\n\\t\\t\\'a1\\', \\'b1\\'\\n\\t\\t\\'a1\\', \\'b2\\'\\n\\t\\t\\'a1\\', \\'b3\\'\\n\\t\\t\\'a1\\', \\'b4\\'\\n\\n\\t\\t\\'a2\\', \\'b1\\'\\n\\t\\t\\'a2\\', \\'b3\\'\\n\\n\\t\\t\\'a3\\', \\'b2\\'\\n\\t\\t\\'a3\\', \\'b3\\'\\n\\t\\t\\'a3\\', \\'b4\\'\\n\\n\\t\\t\\'a4\\', \\'b1\\'\\n\\t\\t\\'a4\\', \\'b2\\'\\n\\t\\t\\'a4\\', \\'b3\\'\\n\\t}');\n\n\tvar relations = {\n\t\tA: srcTableA,\n\t\tB: srcTableB\n\t};\n\n\tvar query = '(A) ÷ (B)';\n\tvar root = exec_ra(query, relations);\n\n\tvar ref = exec_ra('{\\n\\t\\tB.a\\n\\n\\t\\ta1\\n\\t\\ta4\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test difference 0', function () {\n\tvar query = '(S) - (T)';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tS.b, S.d\\n\\n\\t\\tb, 300\\n\\t\\tc, 400\\n\\t\\te, 150\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test difference 1', function () {\n\tvar query = '(T) - (S)';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b, T.d\\n\\n\\t\\tf,   400\\n\\t\\tg,   120\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test difference 2', function () {\n\tvar query = '(T) - (T)';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b:string, T.d:number\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test renameColumns 0', function () {\n\tvar query = 'sigma false (rho x<-b, y<-d (S))';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tS.x:string, S.y:number\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test renameRelation 0', function () {\n\tvar query = 'sigma t.d = 100 (rho t (S))';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tt.b:string, t.d:number\\n\\t\\ta, 100\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test renameRelation 1', function () {\n\tvar query = 'sigma d = 100 (rho t (S))';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tt.b:string, t.d:number\\n\\t\\ta, 100\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test thetaJoin 0', function () {\n\tvar root = exec_ra('(S) join S.d = T.d (T)');\n\tvar ref = exec_ra('{\\n\\t\\tS.b, S.d, T.b, T.d\\n\\n        \\'a\\', 100, \\'a\\', 100\\n\\t\\t\\'c\\', 400, \\'f\\', 400\\n\\t\\t\\'d\\', 200, \\'d\\', 200\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test thetaJoin 1', function () {\n\tvar query = '(S) join S.d = T.d and T.b != S.b (T)';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tS.b, S.d, T.b, T.d\\n\\n\\t\\t\\'c\\', 400, \\'f\\', 400\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test crossJoin 0', function () {\n\tvar query = \"(sigma b<='b' (S)) cross join (sigma b<='d' (T))\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tS.b:string, S.d:number, T.b:string, T.d:number\\n\\n\\t\\t\\'a\\',        100,        \\'a\\',        100\\n\\t\\t\\'a\\',        100,        \\'d\\',        200\\n\\t\\t\\'b\\',        300,        \\'a\\',        100\\n\\t\\t\\'b\\',        300,        \\'d\\',        200\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test crossJoin 1', function () {\n\tvar query = \"(S) cross join (T)\";\n\tvar root = exec_ra(query);\n\n\tvar query2 = \"(S) join true (T)\";\n\tvar root2 = exec_ra(query2);\n\n\tdeepEqual(root.getResult(), root2.getResult());\n});\n\ntest('test naturalJoin 0', function () {\n\tvar query = \"(S) natural join (T)\";\n\tvar root = exec_ra(query);\n\n\tvar query2 = \"pi S.b, S.d ((S) join S.b=T.b and S.d=T.d (T))\";\n\tvar root2 = exec_ra(query2);\n\n\tdeepEqual(root.getResult(), root2.getResult());\n});\n\ntest('test naturalJoin 1', function () {\n\tvar query = \"(R) natural join (S)\";\n\tvar root = exec_ra(query);\n\n\tvar query2 = \"pi a, R.b, c, d ((R) join R.b=S.b (S))\";\n\tvar root2 = exec_ra(query2);\n\n\tdeepEqual(root.getResult(), root2.getResult());\n});\n\ntest('test leftSemiJoin 0', function () {\n\tvar query = \"((R) left semi join (T))\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a:number, R.b:string, R.c:string\\n\\n\\t\\t1, \\'a\\', \\'d\\'\\n\\t\\t4, \\'d\\', \\'f\\'\\n\\t\\t5, \\'d\\', \\'b\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test rightSemiJoin 0', function () {\n\tvar query = \"((R) right semi join (T))\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b:string, T.d:number\\n\\n\\t\\ta, 100\\n\\t\\td, 200\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test leftOuterJoin 0', function () {\n\tvar query = \"(T) left outer join T.b=S.b (S)\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b, T.d, S.b, S.d\\n\\n\\t\\t\\'a\\', 100, \\'a\\',  100\\n\\t\\t\\'d\\', 200, \\'d\\',  200\\n\\t\\t\\'f\\', 400, null, null\\n\\t\\t\\'g\\', 120, null, null\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test rightOuterJoin 0', function () {\n\tvar query = \"(T) right outer join T.b=S.b (S)\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b, T.d, S.b, S.d\\n\\n\\t\\t\\'a\\',  100,  \\'a\\', 100\\n\\t\\tnull, null, \\'b\\', 300\\n\\t\\tnull, null, \\'c\\', 400\\n\\t\\t\\'d\\',  200,  \\'d\\', 200\\n\\t\\tnull, null, \\'e\\', 150\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test fullOuterJoin 0', function () {\n\tvar query = \"(T) full outer join T.b=S.b (S)\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b, T.d, S.b, S.d\\n\\n\\t\\t\\'a\\',  100,  \\'a\\',  100\\n\\t\\t\\'d\\',  200,  \\'d\\',  200\\n\\t\\t\\'f\\',  400,  null, null\\n\\t\\t\\'g\\',  120,  null, null\\n\\t\\tnull, null, \\'b\\',  300\\n\\t\\tnull, null, \\'c\\',  400\\n\\t\\tnull, null, \\'e\\',  150\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test fullOuterJoin (natural)', function () {\n\tvar query = \"(T) full outer join (S)\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b, T.d, S.b, S.d\\n\\n\\t\\t\\'a\\',  100,  \\'a\\',  100\\n\\t\\t\\'d\\',  200,  \\'d\\',  200\\n\\t\\t\\'f\\',  400,  null, null\\n\\t\\t\\'g\\',  120,  null, null\\n\\t\\tnull, null, \\'b\\',  300\\n\\t\\tnull, null, \\'c\\',  400\\n\\t\\tnull, null, \\'e\\',  150\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test is null 0', function () {\n\tvar query = \"sigma S.b = null ((T) left outer join T.b=S.b (S))\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b:string, T.d:number, S.b:string, S.d:number\\n\\n\\t\\t\\'f\\',  400,  null, null\\n\\t\\t\\'g\\',  120,  null, null\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test is not null 1', function () {\n\tvar query = \"sigma S.b != null ((T) left outer join T.b=S.b (S))\";\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b:string, T.d:number, S.b:string, S.d:number\\n\\n\\t\\t\\'a\\',  100,  \\'a\\',  100\\n\\t\\t\\'d\\',  200,  \\'d\\',  200\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test orderBy 0', function () {\n\tvar query = 'tau [1] (sigma a >= 3 (R))';\n\tvar root = exec_ra(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t3,   c,   c\\n\\t\\t4,   d,   f\\n\\t\\t5,   d,   b\\n\\t\\t6,   e,   f\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test natural join with columns of same name 0', function () {\n\tvar query = 'R natural join (pi b S natural join pi b T)';\n\tvar root = exec_ra(query);\n\n\tvar schema = root.getResult().getSchema();\n\n\tdeepEqual(schema, relations.R.getSchema());\n});\n\ntest('test natural join with columns of same name 1', function () {\n\tvar query = '(R natural join pi b S) natural join pi b T';\n\tvar root = exec_ra(query);\n\n\tvar schema = root.getResult().getSchema();\n\n\tdeepEqual(schema, relations.R.getSchema());\n});\n\ntest('groupby 0', function () {\n\tvar result = exec_ra(\"gamma a; sum(b)->c ({a, b\\n\" + \"a, 1\\n\" + \"a, 2\\n\" + \"b, 1\\n\" + \"})\").getResult();\n\n\tvar reference = exec_ra(\"{a, c\\n\" + \"a, 3\\n\" + \"b, 1\\n\" + \"}\").getResult();\n\n\tvar equals = result.equals(reference);\n\tok(equals);\n});\n\ntest('groupby 1', function () {\n\tvar result = exec_ra(\"gamma a; count(*)->c ({a, b\\n\" + \"a, 1\\n\" + \"a, 2\\n\" + \"b, 1\\n\" + \"})\").getResult();\n\n\tvar reference = exec_ra(\"{a, c\\n\" + \"a, 2\\n\" + \"b, 1\\n\" + \"}\").getResult();\n\n\tvar equals = result.equals(reference);\n\tok(equals);\n});\n\ntest('groupby 2 - no groups', function () {\n\tvar result = exec_ra(\"gamma count(*)->c, sum(b)->d ({a, b\\n\" + \"a, 1\\n\" + \"a, 2\\n\" + \"b, 1\\n\" + \"})\").getResult();\n\n\tvar reference = exec_ra(\"{c, d\\n\" + \"3, 4\\n\" + \"}\").getResult();\n\n\tvar equals = result.equals(reference);\n\tok(equals);\n});\n\ntest('test space between plaintext and and operands', function () {\n\ttry {\n\t\texec_ra('sigma trueandfalse R');\n\n\t\tok(false, 'should not be accepted; no space between and');\n\t} catch (e) {\n\t\texec_ra('sigma true and false R');\n\t\tok(true, 'ok');\n\t}\n});\n\ntest('antijoin 1', function () {\n\tvar result = exec_ra(\"S anti join T\").getResult();\n\n\tvar reference = exec_ra(\"{S.b, S.d\\n\" + \"b, 300\\n\" + \"c, 400\\n\" + \"e, 150\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('rownum 1', function () {\n\tvar result = exec_ra(\"pi a, b, ROWNUM()->ROWNUM ({a, b\\n\" + \"a, 1\\n\" + \"a, 2\\n\" + \"b, 1\\n\" + \"})\").getResult();\n\n\tvar reference = exec_ra(\"{a, b, ROWNUM\\n\" + \"a, 1, 1\\n\" + \"a, 2, 2\\n\" + \"b, 1, 3\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('rownum 2', function () {\n\texec_ra(\"pi a, ROWNUM ({a, ROWNUM\\n\" + \"a, 1\\n\" + \"a, 2\\n\" + \"b, 1\\n\" + \"})\").getResult();\n\n\t// rownum is a function now => name ROWNUM is a normal column name => allowed in schema\n\tok(true);\n});\n\ntest('natural left outer join 1', function () {\n\tvar result = exec_ra(\"{R.a, R.b\\n\" + \"1, a\\n\" + \"2, a\\n\" + \"3, d\\n}\" + \" left outer join \" + \"{S.b, S.c\\n\" + \"a, 5\\n\" + \"b, 6}\").getResult();\n\n\tvar reference = exec_ra(\"{R.a, R.b, S.c\\n\" + \"1, a, 5\\n\" + \"2, a, 5\\n\" + \"3, d, null\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('natural left outer join 2', function () {\n\tvar result = exec_ra(\"R left outer join R\").getResult();\n\n\tvar reference = exec_ra(\"R\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('natural right outer join 1', function () {\n\tvar result = exec_ra(\"{R.a, R.b\\n\" + \"1, a\\n\" + \"2, a\\n\" + \"}\" + \" right outer join \" + \"{S.a, S.c\\n\" + \"1, a\\n\" + \"2, b\\n\" + \"3, b\\n\" + \"}\").getResult();\n\n\tvar reference = exec_ra(\"{R.b, S.a, S.c\\n\" + \"a, 1, a\\n\" + \"a, 2, b\\n\" + \"null, 3, b\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('natural right outer join 2', function () {\n\tvar result = exec_ra(\"R right outer join R\").getResult();\n\n\tvar reference = exec_ra(\"R\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('ra to text 1', function () {\n\tvar ast = relalgjs.parseRelalg('R', []);\n\trelalgjs.replaceVariables(ast);\n\tvar text = relalgjs.textFromRelalgAstRoot(ast);\n\tequal(text, 'R');\n});\n\ntest('ra to text 2', function () {\n\tvar ast = relalgjs.parseRelalg('{\\n\\t\\ta, b, c\\n\\t\\ta, 1, 2001-01-01\\n\\t\\tnull, null, null\\n\\t}', []);\n\trelalgjs.replaceVariables(ast);\n\tvar text = relalgjs.textFromRelalgAstRoot(ast);\n\n\tequal(text, \"{\\n\\ta:string, b:number, c:date    \\n\t'a'     , 1       , 2001-01-01\\n\tnull    , null    , null      \\n}\");\n});\n\ntest('ra to text 3', function () {\n\tvar query = 'pi [1], [2], [3] (rho a R x rho b R)';\n\tvar ast = relalgjs.parseRelalg(query);\n\trelalgjs.replaceVariables(ast);\n\tvar text = relalgjs.textFromRelalgAstRoot(ast);\n\tvar result = exec_ra(text).getResult();\n\n\tvar reference = exec_ra(query).getResult();\n\tdeepEqual(result, reference);\n});\n\nQUnit.module('relational algebra with eval');\n\ntest('pi with eval aritmetic', function () {\n\tvar result = exec_ra(\" pi a, a->b, a-a->a0, a1<-a+a, 2*a->a2, a/2->a3, a%2->a4 \" + \" {a\\n1\\n2}\").getResult();\n\n\tvar reference = exec_ra(\"{a b a0 a1 a2 a3 a4 \\n\" + \"1 1 0 2 2 0.5 1\\n\" + \"2 2 0 4 4 1   0\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('pi with eval: constants', function () {\n\tvar result = exec_ra(\" pi a, 'test'->b, 1->c, date('1970-01-01')->d, true->e, false->f {a\\n1\\n2} \").getResult();\n\n\tvar reference = exec_ra(\"{a, b, c, d, e, f\\n\" + \"1, test, 1, 1970-01-01, true, false\\n\" + \"2, test, 1, 1970-01-01, true, false\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('pi with eval: date', function () {\n\tvar result = exec_ra(\"pi a, adddate(a, 1)->b, year(a)->c, month(a)->d, day(a)->e, adddate(subdate(a, 1), 1)=a->f {a\\n1970-01-01\\n1970-01-02} \").getResult();\n\n\tvar reference = exec_ra(\"{a, b, c, d, e, f\\n\" + \"1970-01-01 1970-01-02, 1970 1 1 true\\n\" + \"1970-01-02 1970-01-03, 1970 1 2 true\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('pi with eval: upper()', function () {\n\tvar result = exec_ra(\" sigma x < 'D' pi upper(S.b)->x S \").getResult();\n\tresult.eliminateDuplicateRows();\n\n\tvar reference = exec_ra(\"{x\\n\" + \"A\\n\" + \"B\\n\" + \"C\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('pi with eval: add()', function () {\n\tvar result = exec_ra(\" pi a, add(a, a) ->x R \").getResult();\n\tresult.eliminateDuplicateRows();\n\n\tvar reference = exec_ra(\"{R.a, x\\n\" + \"1, 2\\n\" + \"3, 6\\n\" + \"4, 8\\n\" + \"5, 10\\n\" + \"6, 12\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('coalesce - working - constant', function () {\n\tvar result = exec_ra(\"pi coalesce(null, 1)->x {a:number\\n2}\").getResult();\n\tvar reference = exec_ra(\"{x:number\\n1}\").getResult();\n\tdeepEqual(result, reference);\n});\n\ntest('coalesce - working - column', function () {\n\tvar result = exec_ra(\"pi coalesce(null, a, 1)->x {a:number\\nnull\\n2}\").getResult();\n\tvar reference = exec_ra(\"{x:number\\n1\\n2}\").getResult();\n\tdeepEqual(result, reference);\n});\n\ntest('coalesce - error all null', function () {\n\ttry {\n\t\texec_ra(\"pi coalesce(null, null)->x {a:number\\n2}\").getResult();\n\t} catch (e) {\n\t\tok(true);\n\t}\n});\n\ntest('case when - working', function () {\n\tvar result = exec_ra(\"pi (case when a = 1 then a*10 else a end)+1->x {a:number\\n1\\n2}\").getResult();\n\tvar reference = exec_ra(\"{x:number\\n11\\n3}\").getResult();\n\tdeepEqual(result, reference);\n});\n\ntest('n-ary concat', function () {\n\tvar result = exec_ra(\"pi concat(b,'x',b,c)->x R \").getResult();\n\tresult.eliminateDuplicateRows();\n\n\tvar reference = exec_ra(\"{x\\n\" + \"axad\\n\" + \"cxcc\\n\" + \"dxdf\\n\" + \"dxdb\\n\" + \"exef\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('pipe-concat-operator', function () {\n\tvar result = exec_ra(\"pi b||'x'||b||c->x R \").getResult();\n\tresult.eliminateDuplicateRows();\n\n\tvar reference = exec_ra(\"{x\\n\" + \"axad\\n\" + \"cxcc\\n\" + \"dxdf\\n\" + \"dxdb\\n\" + \"exef\\n\" + \"}\").getResult();\n\n\tdeepEqual(result, reference);\n});\n\ntest('bug: keywords were detected as column names', function () {\n\t// this statement would not work if \"sigma\" was interpreted as a column name\n\tvar result = exec_ra(\"R join sigma b=b S\").getResult();\n\tvar reference = exec_ra(\"R natural join S\").getResult();\n\tdeepEqual(result, reference);\n});\n\ntest('relation-name not interpreted as column name', function () {\n\tvar result = exec_ra('S2 = T join R    S2').getResult();\n\t// was failing because S2 was interpreted as relation and R as column\n\n\tvar reference = exec_ra('S2 = T natural join R   S2').getResult();\n\tdeepEqual(result, reference);\n});\n\ntest('relation-name not interpreted as column name 2', function () {\n\t/* boolean-column with same name as Relation should be possible\n  by either () it or with full qualified name */\n\tvar result = exec_ra(\"S1 = pi (a>0)->R R \\n\" + \"S2 = S join (R) S1 \\n\" + \"sigma d=100 S2\").getResult();\n\tvar reference = exec_ra(\"{S.b, S.d, R\\n a, 100, true\\n}\").getResult();\n\tdeepEqual(result, reference);\n});\n\ntest('test like operator', function () {\n\tvar result = exec_ra('pi x, x like \\'a%\\'->a, x like \\'%b\\'->b, x like \\'%a%\\'->c, x like \\'a_a\\'->d {\\n\\tx\\n\\n\\tabb\\n\\tbba\\n\\tbab\\n\\taba\\n\\t}').getResult();\n\n\tvar reference = exec_ra('{\\n\\tx,   a,     b,     c,     d\\n\\n\\tabb, true,  true,  true, false\\n\\tbba, false, false, true, false\\n\\tbab, false, true,  true, false\\n\\taba, true,  false, true, true\\n\\t}').getResult();\n\tdeepEqual(result, reference);\n});\n\ntest('groupby textgen', function () {\n\tvar ast = relalgjs.parseRelalg('gamma a; sum(b)->c ({a, b\\n\\t\\ta, 1\\n\\t\\t})');\n\tvar text = relalgjs.textFromRelalgAstRoot(ast);\n\n\tstrictEqual(text, \"γ a ; c ← SUM(b) ( {\\n\" + \"\\ta:string, b:number\\n\" + \"\\t'a'     , 1       \\n\" + \"} ) \");\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/tests/translate_tests_ra.js\n// module id = 163\n// module chunks = 1\n//# sourceURL=webpack:///./src/db/tests/translate_tests_ra.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _relalg = __webpack_require__(43);\n\nvar relalgjs = _interopRequireWildcard(_relalg);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nQUnit.module('translate sql ast to relational algebra'); /* global peg_parser_sql, module, QUnit, test, ok, deepEqual, equal, exec_sql, exec_ra, RA, peg_parser_ra, groupRoot_to_text */\n\nvar relations = {};\nvar srcTableR, srcTableS, srcTableT;\n\nfunction exec_sql(query, alternative_relations) {\n\tvar ast = relalgjs.parseSQLSelect(query);\n\trelalgjs.replaceVariables(ast, alternative_relations || relations);\n\tvar root = relalgjs.relalgFromSQLAstRoot(ast, alternative_relations || relations);\n\troot.check();\n\treturn root;\n}\n\nfunction exec_ra(query, alternative_relations) {\n\treturn relalgjs.executeRelalg(query, alternative_relations || relations);\n}\n\nQUnit.testStart(function () {\n\t// create the three source tables\n\tsrcTableR = relalgjs.executeRelalg('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t1,   a,   d\\n\\t\\t3,   c,   c\\n\\t\\t4,   d,   f\\n\\t\\t5,   d,   b\\n\\t\\t6,   e,   f\\n\\t}', {});\n\n\tsrcTableS = relalgjs.executeRelalg('{\\n\\t\\tS.b, S.d\\n\\n\\t\\ta,   100\\n\\t\\tb,   300\\n\\t\\tc,   400\\n\\t\\td,   200\\n\\t\\te,   150\\n\\t}', {});\n\n\tsrcTableT = relalgjs.executeRelalg('{\\n\\t\\tT.b, T.d\\n\\n\\t\\ta,   100\\n\\t\\td,   200\\n\\t\\tf,   400\\n\\t\\tg,   120\\n\\t}', {});\n\n\trelations.R = srcTableR;\n\trelations.S = srcTableS;\n\trelations.T = srcTableT;\n});\n\ntest('test relation', function () {\n\tvar query = 'select distinct * from R';\n\tvar root = exec_sql(query);\n\n\tdeepEqual(root.getResult(), srcTableR.getResult());\n});\n\ntest('test not existant relation', function () {\n\ttry {\n\t\tvar query = 'select distinct * from X';\n\t\texec_sql(query);\n\n\t\tok(false, 'table does not exist');\n\t} catch (e) {\n\t\tok(true, 'table not found');\n\t}\n});\n\ntest('test selection[true](R)', function () {\n\tvar query = 'select distinct * from R';\n\tvar root = exec_sql(query);\n\n\tdeepEqual(root.getResult(), srcTableR.getResult());\n});\n\ntest('test selection[a>=3](R)', function () {\n\tvar root = exec_sql('select distinct * from R where a >= 3');\n\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t3, \\'c\\', \\'c\\'\\n\\t\\t4, \\'d\\', \\'f\\'\\n\\t\\t5, \\'d\\', \\'b\\'\\n\\t\\t6, \\'e\\', \\'f\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test selection[not (b=c)](R)', function () {\n\tvar root = exec_sql('select distinct * from R where ! (b = c)');\n\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t1, \\'a\\', \\'d\\'\\n\\t\\t4, \\'d\\', \\'f\\'\\n\\t\\t5, \\'d\\', \\'b\\'\\n\\t\\t6, \\'e\\', \\'f\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test selection[a>3](R)', function () {\n\tvar query = 'select distinct * from R where a > 3';\n\tvar root = exec_sql(query);\n\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t4, \\'d\\', \\'f\\'\\n\\t\\t5, \\'d\\', \\'b\\'\\n\\t\\t6, \\'e\\', \\'f\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test selection[a = 3 or b = \\'e\\'](R)', function () {\n\tvar root = exec_sql(\"select distinct * from  R where a = 3 or b = 'e'\");\n\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t3, \\'c\\', \\'c\\'\\n\\t\\t6, \\'e\\', \\'f\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test projection[a, b](R)', function () {\n\tvar root = exec_sql('select distinct a, b from R');\n\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tR.a, R.b\\n\\n\\t\\t1, \\'a\\'\\n\\t\\t3, \\'c\\'\\n\\t\\t4, \\'d\\'\\n\\t\\t5, \\'d\\'\\n\\t\\t6, \\'e\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test projection[b, a](R)', function () {\n\tvar query = 'select distinct b, a from R';\n\tvar root = exec_sql(query);\n\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tR.b, R.a\\n\\n\\t\\t\\'a\\', 1\\n\\t\\t\\'c\\', 3\\n\\t\\t\\'d\\', 4\\n\\t\\t\\'d\\', 5\\n\\t\\t\\'e\\', 6\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test projection[b, a, a, b](R)', function () {\n\tvar query = 'select distinct b, a, a, b from R';\n\n\ttry {\n\t\texec_sql(query);\n\t\tok(false);\n\t} catch (e) {\n\t\tok(true);\n\t}\n});\n\ntest('test (R) inner join [R.b = S.b] join (S)', function () {\n\tvar root = exec_sql('\\n\\t\\tselect distinct *\\n\\t\\tfrom R\\n\\t\\t\\tinner join S on (R.b = S.b)\\n\\t');\n\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tR.a, R.b, R.c, S.b, S.d\\n\\n\\t\\t1, \\'a\\', \\'d\\', \\'a\\', 100\\n\\t\\t3, \\'c\\', \\'c\\', \\'c\\', 400\\n\\t\\t4, \\'d\\', \\'f\\', \\'d\\', 200\\n\\t\\t5, \\'d\\', \\'b\\', \\'d\\', 200\\n\\t\\t6, \\'e\\', \\'f\\', \\'e\\', 150\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test rename relation', function () {\n\tvar query = 'select distinct t.a, b from R as t';\n\tvar root = exec_sql(query);\n\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tt.a, t.b\\n\\n\\t\\t1, \\'a\\'\\n\\t\\t3, \\'c\\'\\n\\t\\t4, \\'d\\'\\n\\t\\t5, \\'d\\'\\n\\t\\t6, \\'e\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test rename column', function () {\n\tvar query = 'select distinct t.a as x, t.b from R as t';\n\tvar root = exec_sql(query);\n\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tt.x, t.b\\n\\n\\t\\t1, \\'a\\'\\n\\t\\t3, \\'c\\'\\n\\t\\t4, \\'d\\'\\n\\t\\t5, \\'d\\'\\n\\t\\t6, \\'e\\'\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test union 0', function () {\n\tvar query = 'select distinct * from S union select distinct * from T';\n\tvar root = exec_sql(query);\n\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tS.b, S.d\\n\\n\\t\\ta,   100\\n\\t\\tb,   300\\n\\t\\tc,   400\\n\\t\\td,   200\\n\\t\\te,   150\\n\\t\\tf,   400\\n\\t\\tg,   120\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test union 1', function () {\n\tvar root = exec_sql('\\n\\t\\tselect distinct * from R\\n\\t\\tunion\\n\\t\\tselect distinct * from R\\n\\t\\tunion\\n\\t\\tselect distinct * from R\\n\\t');\n\n\tvar result = root.getResult();\n\tdeepEqual(result, srcTableR.getResult());\n});\n\ntest('test intersect 0', function () {\n\tvar root = exec_sql('\\n\\t\\tselect distinct * from S\\n\\t\\tintersect\\n\\t\\tselect distinct * from T\\n\\t');\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tS.b, S.d\\n\\n\\t\\ta,   100\\n\\t\\td,   200\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test intersect 1', function () {\n\tvar root = exec_sql('\\n\\t\\tselect distinct * from S\\n\\t\\tintersect\\n\\t\\tselect distinct * from S\\n\\t');\n\tvar ref = srcTableS.getResult();\n\n\tvar result = root.getResult();\n\tdeepEqual(result, ref);\n});\n\ntest('test difference 0', function () {\n\tvar root = exec_sql('\\n\\t\\tselect distinct * from S\\n\\t\\texcept\\n\\t\\tselect distinct * from T\\n\\t');\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tS.b, S.d\\n\\n\\t\\t\\'b\\', 300\\n\\t\\t\\'c\\', 400\\n\\t\\t\\'e\\', 150\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test difference 1', function () {\n\tvar root = exec_sql('\\n\\t\\tselect distinct * from T\\n\\t\\texcept\\n\\t\\tselect distinct * from S\\n\\t');\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tT.b, T.d\\n\\n\\t\\tf, 400\\n\\t\\tg, 120\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test difference 2', function () {\n\tvar root = exec_sql('\\n\\t\\tselect distinct * from T\\n\\t\\texcept\\n\\t\\tselect distinct * from T\\n\\t');\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tT.b:string, T.d:number\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test renameColumns 0', function () {\n\tvar root = exec_sql('\\n\\t\\tselect distinct b as x, d as y\\n\\t\\tfrom S\\n\\t\\twhere false\\n\\t');\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tS.x:string, S.y:number\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test renameRelation 0', function () {\n\tvar query = 'select distinct * from S as t where t.d = 100';\n\tvar root = exec_sql(query);\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tt.b, t.d\\n\\t\\ta,   100\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test renameRelation 1', function () {\n\tvar query = 'select distinct * from S as t where d = 100';\n\tvar root = exec_sql(query);\n\tvar ref = relalgjs.executeRelalg('{\\n\\t\\tt.b, t.d\\n\\t\\ta,   100\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test thetaJoin 0', function () {\n\tvar query = 'select distinct * from S ' + 'inner join T on S.d = T.d';\n\tvar root = exec_sql(query);\n\tvar ref = exec_ra('{\\n\\t\\tS.b, S.d, T.b, T.d\\n\\n        \\'a\\', 100, \\'a\\', 100\\n\\t\\t\\'c\\', 400, \\'f\\', 400\\n\\t\\t\\'d\\', 200, \\'d\\', 200\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test thetaJoin 1', function () {\n\tvar query = 'select distinct * from S ' + 'inner join T on S.d = T.d and T.b != S.b';\n\tvar root = exec_sql(query);\n\tvar ref = exec_ra('{\\n\\t\\tS.b, S.d, T.b, T.d\\n\\n\\t\\t\\'c\\', 400, \\'f\\', 400\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test crossJoin 0', function () {\n\tvar query = 'select distinct * from S ' + \"\tcross join (select distinct * from T where b<='d') as T\" + \"\twhere S.b<='b'\";\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tS.b:string, S.d:number, T.b:string, T.d:number\\n\\n\\t\\t\\'a\\',        100,        \\'a\\',        100\\n\\t\\t\\'a\\',        100,        \\'d\\',        200\\n\\t\\t\\'b\\',        300,        \\'a\\',        100\\n\\t\\t\\'b\\',        300,        \\'d\\',        200\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test crossJoin 1', function () {\n\tvar query = \"select distinct * from S cross join T\";\n\tvar root = exec_sql(query);\n\n\tvar query2 = \"select distinct * from S inner join T on true\";\n\tvar root2 = exec_sql(query2);\n\n\tdeepEqual(root.getResult(), root2.getResult());\n});\n\ntest('test naturalJoin 0', function () {\n\tvar query = \"select distinct * from S natural join T\";\n\tvar root = exec_sql(query);\n\n\tvar query2 = \"select distinct S.* from S inner join T on S.b=T.b and S.d=T.d\";\n\tvar root2 = exec_sql(query2);\n\n\tdeepEqual(root.getResult(), root2.getResult());\n});\n\ntest('test naturalJoin 1', function () {\n\tvar query = \"select distinct * from R natural join S\";\n\tvar root = exec_sql(query);\n\n\tvar query2 = \"pi a, R.b, c, d (R join R.b=S.b S)\";\n\tvar root2 = exec_ra(query2);\n\n\tdeepEqual(root.getResult(), root2.getResult());\n});\n\ntest('test using clause 0', function () {\n\tvar query = \"select distinct * from R join S using(b)\";\n\tvar ref = \"pi a, R.b, c, d (R join R.b=S.b S)\";\n\n\tdeepEqual(exec_sql(query).getResult(), exec_ra(ref).getResult());\n});\n\ntest('test using clause 1', function () {\n\tvar query = \"select distinct * from R inner join (select distinct b, d as a from S) as S using(b)\";\n\tvar ref = \"pi R.a, R.b, R.c, S.a (R join R.b=S.b rho d->a S)\";\n\n\tdeepEqual(exec_sql(query).getResult(), exec_ra(ref).getResult());\n});\n\ntest('test leftOuterJoin 0', function () {\n\tvar query = \"select distinct * from T left outer join S on T.b=S.b \";\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b, T.d, S.b, S.d\\n\\n\\t\\t\\'a\\', 100, \\'a\\',  100\\n\\t\\t\\'d\\', 200, \\'d\\',  200\\n\\t\\t\\'f\\', 400, null, null\\n\\t\\t\\'g\\', 120, null, null\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test rightOuterJoin 0', function () {\n\tvar query = \"select distinct * from T right outer join S on T.b=S.b\";\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b, T.d, S.b, S.d\\n\\n\\t\\t\\'a\\',  100,  \\'a\\', 100\\n\\t\\tnull, null, \\'b\\', 300\\n\\t\\tnull, null, \\'c\\', 400\\n\\t\\t\\'d\\',  200,  \\'d\\', 200\\n\\t\\tnull, null, \\'e\\', 150\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test fullOuterJoin 0', function () {\n\tvar query = \"select distinct * from T full outer join S on T.b=S.b\";\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b, T.d, S.b, S.d\\n\\n\\t\\t\\'a\\',  100,  \\'a\\',  100\\n\\t\\t\\'d\\',  200,  \\'d\\',  200\\n\\t\\t\\'f\\',  400,  null, null\\n\\t\\t\\'g\\',  120,  null, null\\n\\t\\tnull, null, \\'b\\',  300\\n\\t\\tnull, null, \\'c\\',  400\\n\\t\\tnull, null, \\'e\\',  150\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test is null 0', function () {\n\tvar query = \"select distinct * from T \" + 'left outer join S on T.b=S.b ' + \"where S.b is null\";\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b:string, T.d:number, S.b:string, S.d:number\\n\\n\\t\\t\\'f\\',  400,  null, null\\n\\t\\t\\'g\\',  120,  null, null\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test is not null 1', function () {\n\tvar query = \"select distinct * from T \" + 'left outer join S on T.b=S.b ' + \"where S.b is not null\";\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tT.b:string, T.d:number, S.b:string, S.d:number\\n\\n\\t\\t\\'a\\',  100,  \\'a\\',  100\\n\\t\\t\\'d\\',  200,  \\'d\\',  200\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test orderBy 0', function () {\n\tvar query = 'select distinct * from R where a >= 3 and a >= 2.1 and a>=3.0 and a>=-1 order by 1';\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t3,   c,   c\\n\\t\\t4,   d,   f\\n\\t\\t5,   d,   b\\n\\t\\t6,   e,   f\\n\\t}');\n\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('test cross join', function () {\n\tvar query = 'select distinct * from R, S, T';\n\texec_sql(query);\n\n\tok('ok');\n});\n\ntest('group by 0', function () {\n\tvar query = 'select distinct b, count(*) as test from R group by b order by 2 desc, 1';\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.b, test\\n\\n\\t\\td, 2\\n\\t\\ta, 1\\n\\t\\tc, 1\\n\\t\\te, 1\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('having without group by (not allowed)', function () {\n\ttry {\n\t\tvar query = 'select distinct * from R having true';\n\t\texec_sql(query);\n\t\tok(false);\n\t} catch (e) {\n\t\tok(true);\n\t}\n});\n\ntest('having without group by (allowed)', function () {\n\tvar query = \"select distinct count(*) as x from R where true having true\";\n\tvar ref = \"{x:number\\n5}\";\n\n\tdeepEqual(exec_sql(query).getResult(), exec_ra(ref).getResult());\n});\n\ntest('group without aggregation', function () {\n\tvar query = \"select distinct * from R group by b having b > 'c' order by 1 asc\";\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.b\\n\\t\\td\\n\\t\\te\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('aggregation without group (working)', function () {\n\tvar query = \"select distinct count(*) as test from R\";\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\ttest:number\\n\\t\\t5\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('aggregation without group (not working)', function () {\n\ttry {\n\t\tvar query = 'select distinct b, count(*) as test from R';\n\t\texec_sql(query);\n\t\tok(false);\n\t} catch (e) {\n\t\tok(true);\n\t}\n});\n\ntest('group by having 0', function () {\n\tvar query = 'select distinct b, count(*) as test from R group by b having test >= 2 order by 2 desc, 1';\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.b:string, test:number\\n\\t\\td, 2\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n});\n\ntest('ROWNUM not supported', function () {\n\ttry {\n\t\tvar query = 'select distinct b from R where ROWNUM > 10';\n\t\texec_sql(query);\n\t\tok(false);\n\t} catch (e) {\n\t\tok(true);\n\t}\n});\n\ntest('limit 0', function () {\n\tvar query = 'select distinct b from R where true limit 0';\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.b:string\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n\n\t// test fetch first syntax\n\tvar root2 = exec_sql('select distinct b from R where true fetch first 0 rows only');\n\tdeepEqual(root2.getResult(), ref.getResult());\n});\n\ntest('limit 1', function () {\n\tvar query = 'select distinct * from R order by 1 limit 2 offset 2';\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t4, \\'d\\', \\'f\\'\\n\\t\\t5, \\'d\\', \\'b\\'\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n\n\t// test fetch first syntax\n\tvar root2 = exec_sql('select distinct * from R order by 1 offset 2 rows fetch first 2 rows only');\n\tdeepEqual(root2.getResult(), ref.getResult());\n});\n\ntest('limit 2', function () {\n\tvar root1 = exec_sql('select distinct * from R order by 1 limit 1');\n\tvar root2 = exec_sql('select distinct * from R order by 1 desc limit 1');\n\n\tok(root1.getResult().equals(root2.getResult()) === false);\n});\n\ntest('limit 3: non valid limit', function () {\n\ttry {\n\t\texec_sql('select distinct b from R limit -1');\n\t\tok(false);\n\t} catch (e) {\n\t\tok(true);\n\t}\n});\n\ntest('limit 3.2: non valid limit', function () {\n\ttry {\n\t\texec_sql('select distinct b from R fetch first -1 rows only');\n\t\tok(false);\n\t} catch (e) {\n\t\tok(true);\n\t}\n});\n\ntest('limit 4: limit all with offset', function () {\n\tvar query = 'select distinct * from R order by 1 limit ALL offset 2';\n\tvar root = exec_sql(query);\n\n\tvar ref = exec_ra('{\\n\\t\\tR.a, R.b, R.c\\n\\n\\t\\t4, \\'d\\', \\'f\\'\\n\\t\\t5, \\'d\\', \\'b\\'\\n\\t\\t6, \\'e\\', \\'f\\'\\n\\t}');\n\tdeepEqual(root.getResult(), ref.getResult());\n\n\t// test fetch first syntax\n\tvar root2 = exec_sql('select distinct * from R order by 1 offset 2 rows');\n\tdeepEqual(root2.getResult(), ref.getResult());\n});\n\ntest('limit 5: limit all', function () {\n\tvar query = 'select distinct * from R order by 1 limit ALL';\n\tvar root = exec_sql(query);\n\n\tdeepEqual(root.getResult(), srcTableR.getResult());\n});\n\nQUnit.module('translate sql dump to group definition');\n\ntest('dbdubmp 1', function () {\n\tvar query = '\\n\\t\\tcreate table test (a int, b varchar);\\n\\t\\tinsert into test values(1, \\'sadf\\');\\n\\t';\n\tvar ast = relalgjs.parseSQLDump(query);\n\tast.groups[0].headers.group = 'test';\n\n\tvar ref = '\\n\\t\\tgroup:test\\n\\t\\ttest = {\\n\\t\\t\\ta:number, b:string\\n\\t\\t\\t1       , \\'sadf\\'\\n\\t\\t}\\n\\t';\n\n\tvar ref_ast = relalgjs.parseRelalgGroup(ref);\n\n\tdeepEqual(relalgjs.textFromGroupAstRoot(ast), relalgjs.textFromGroupAstRoot(ref_ast));\n});\n\ntest('distinct warning 1', function () {\n\tvar ast, query;\n\n\t// test if distinct flag is set correctly\n\tquery = \"select distinct a from R\";\n\tast = relalgjs.parseSQLSelect(query);\n\tequal(ast.child.select.distinct, true);\n\n\tquery = \"select a from R\";\n\tast = relalgjs.parseSQLSelect(query);\n\tequal(ast.child.select.distinct, false);\n});\n\ntest('join_expression 1', function () {\n\tvar query = \"select distinct * from R, S natural join T\";\n\tvar query_ref = \"R x S join T\";\n\n\tdeepEqual(exec_sql(query).getResult(), exec_ra(query_ref).getResult());\n});\n\ntest('join_expression 2', function () {\n\tvar query = \"select distinct * from R, (S natural join T)\";\n\tvar query_ref = \"R x (S join T)\";\n\n\tdeepEqual(exec_sql(query).getResult(), exec_ra(query_ref).getResult());\n});\n\ntest('test statement with \"with-clause\"', function () {\n\tvar query = \"with A as (select * from R) select * from A\";\n\tvar query_ref = \"rho A R\";\n\n\tdeepEqual(exec_sql(query).getResult(), exec_ra(query_ref).getResult());\n});\n\ntest('test statement with \"with-clause\"', function () {\n\tvar query = \"with A as (select a, b from R) select * from A cross join S\";\n\tvar query_ref = \"pi a, b rho A R x S\";\n\n\tdeepEqual(exec_sql(query).getResult(), exec_ra(query_ref).getResult());\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/tests/translate_tests_sql.js\n// module id = 164\n// module chunks = 1\n//# sourceURL=webpack:///./src/db/tests/translate_tests_sql.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _relalg = __webpack_require__(43);\n\nvar relalgjs = _interopRequireWildcard(_relalg);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar emptyRoot; /* global translate_ra, replaceVariables, peg_parser_ra, module, QUnit, test, ok, deepEqual, equal, RA */\n\nvar relations = {};\n\nQUnit.module('variable replacer');\n\nfunction exec_ra(query, alternative_relations) {\n\treturn relalgjs.executeRelalg(query, alternative_relations || relations);\n}\n\nvar unsetLineColumn = function unsetLineColumn(root) {\n\tvar rec = function rec(n) {\n\t\tif (typeof n.codeInfo !== 'undefined') delete n.codeInfo;\n\n\t\tif (typeof n.child !== 'undefined') rec(n.child);\n\t\tif (typeof n.child2 !== 'undefined') rec(n.child2);\n\t\tif (typeof n.arg !== 'undefined') rec(n.arg);\n\t};\n\trec(root);\n\n\tdelete root.comment1;\n\n\tfor (var i in root.assignments) {\n\t\trec(root.assignments[i]);\n\t}\n};\n\nQUnit.testStart(function () {\n\temptyRoot = {\n\t\ttype: 'root',\n\t\tchild: null,\n\t\tassignments: []\n\t};\n\n\t/*var schema = new RA.Schema();\n  var firstRelation = new RA.Relation('firstRelation');\n  firstRelation.setSchema(schema);\n \n  schema = new RA.Schema();\n  var secondRelation = new RA.Relation('secondRelation');\n  secondRelation.setSchema(schema);*/\n\n\tvar firstRelation = exec_ra('{\\n\\t\\ta:string\\n\\t}');\n\tvar secondRelation = exec_ra('{\\n\\t\\ta:string\\n\\t}');\n\n\trelations.firstRelation = firstRelation;\n\trelations.secondRelation = secondRelation;\n});\n\ntest('simple relation', function () {\n\tvar query = 'test';\n\tvar ast = relalgjs.parseRelalg(query);\n\tunsetLineColumn(ast);\n\n\temptyRoot.child = {\n\t\ttype: 'relation',\n\t\tname: 'test'\n\t};\n\n\tdeepEqual(ast, emptyRoot);\n});\n\ntest('test selection 0', function () {\n\tvar query = 'sigma true (test)';\n\tvar ast = relalgjs.parseRelalg(query);\n\tunsetLineColumn(ast);\n\n\temptyRoot.child = {\n\t\ttype: 'selection',\n\t\targ: {\n\t\t\ttype: 'valueExpr',\n\t\t\tdatatype: 'boolean',\n\t\t\tfunc: 'constant',\n\t\t\targs: [true]\n\t\t},\n\t\tchild: {\n\t\t\ttype: 'relation',\n\t\t\tname: 'test',\n\t\t\twrappedInBrackets: true\n\t\t}\n\t};\n\n\tdeepEqual(ast, emptyRoot);\n});\n\ntest('test selection 1', function () {\n\tvar query = '(σ (false) (test))';\n\tvar ast = relalgjs.parseRelalg(query);\n\tunsetLineColumn(ast);\n\n\temptyRoot.child = {\n\t\ttype: 'selection',\n\t\targ: {\n\t\t\ttype: 'valueExpr',\n\t\t\tdatatype: 'boolean',\n\t\t\tfunc: 'constant',\n\t\t\targs: [false],\n\t\t\twrappedInBrackets: true\n\t\t},\n\t\tchild: {\n\t\t\ttype: 'relation',\n\t\t\tname: 'test',\n\t\t\twrappedInBrackets: true\n\t\t},\n\t\twrappedInBrackets: true\n\t};\n\n\tdeepEqual(ast, emptyRoot);\n});\n\ntest('test variables (unreplaced)', function () {\n\tvar query = 'A = firstRelation ' + 'B = secondRelation ' + 'σ false (A union B)';\n\tvar ast = relalgjs.parseRelalg(query);\n\tunsetLineColumn(ast);\n\n\temptyRoot.assignments.push({\n\t\ttype: 'assignment',\n\t\tname: 'A',\n\t\tchild: {\n\t\t\ttype: 'relation',\n\t\t\tname: 'firstRelation'\n\t\t}\n\t});\n\temptyRoot.assignments.push({\n\t\ttype: 'assignment',\n\t\tname: 'B',\n\t\tchild: {\n\t\t\ttype: 'relation',\n\t\t\tname: 'secondRelation'\n\t\t}\n\t});\n\temptyRoot.child = {\n\t\ttype: 'selection',\n\t\targ: {\n\t\t\ttype: 'valueExpr',\n\t\t\tdatatype: 'boolean',\n\t\t\tfunc: 'constant',\n\t\t\targs: [false]\n\t\t},\n\t\tchild: {\n\t\t\ttype: 'union',\n\t\t\tchild: {\n\t\t\t\ttype: 'relation',\n\t\t\t\tname: 'A'\n\t\t\t},\n\t\t\tchild2: {\n\t\t\t\ttype: 'relation',\n\t\t\t\tname: 'B'\n\t\t\t},\n\t\t\twrappedInBrackets: true\n\t\t}\n\t};\n\n\tdeepEqual(ast, emptyRoot);\n});\n\ntest('test variables (replaced)', function () {\n\tvar query = 'A = firstRelation ' + 'B = secondRelation ' + 'σ false (A union B)';\n\tvar ast = relalgjs.parseRelalg(query);\n\tunsetLineColumn(ast);\n\n\temptyRoot.assignments.push({\n\t\ttype: 'assignment',\n\t\tname: 'A',\n\t\tchild: {\n\t\t\tmetaData: {\n\t\t\t\tfromVariable: 'A'\n\t\t\t},\n\t\t\ttype: 'relation',\n\t\t\tname: 'firstRelation',\n\t\t\twrappedInBrackets: true\n\t\t}\n\t});\n\temptyRoot.assignments.push({\n\t\ttype: 'assignment',\n\t\tname: 'B',\n\t\tchild: {\n\t\t\tmetaData: {\n\t\t\t\tfromVariable: 'B'\n\t\t\t},\n\t\t\ttype: 'relation',\n\t\t\tname: 'secondRelation',\n\t\t\twrappedInBrackets: true\n\t\t}\n\t});\n\temptyRoot.child = {\n\t\ttype: 'selection',\n\t\targ: {\n\t\t\ttype: 'valueExpr',\n\t\t\tdatatype: 'boolean',\n\t\t\tfunc: 'constant',\n\t\t\targs: [false]\n\t\t},\n\t\tchild: {\n\t\t\ttype: 'union',\n\t\t\tchild: {\n\t\t\t\tmetaData: {\n\t\t\t\t\tfromVariable: 'A'\n\t\t\t\t},\n\t\t\t\ttype: 'relation',\n\t\t\t\tname: 'firstRelation',\n\t\t\t\twrappedInBrackets: true\n\t\t\t},\n\t\t\tchild2: {\n\t\t\t\tmetaData: {\n\t\t\t\t\tfromVariable: 'B'\n\t\t\t\t},\n\t\t\t\ttype: 'relation',\n\t\t\t\tname: 'secondRelation',\n\t\t\t\twrappedInBrackets: true\n\t\t\t},\n\t\t\twrappedInBrackets: true\n\t\t}\n\t};\n\n\trelalgjs.replaceVariables(ast, relations);\n\n\tdeepEqual(ast, emptyRoot);\n});\n\ntest('test variables without cycle', function () {\n\tvar query = 'A = firstRelation ' + 'B = secondRelation ' + 'C = A ' + 'σ false (C union B)';\n\tvar ast = relalgjs.parseRelalg(query);\n\tunsetLineColumn(ast);\n\n\temptyRoot.assignments.push({\n\t\ttype: 'assignment',\n\t\tname: 'A',\n\t\tchild: {\n\t\t\tmetaData: {\n\t\t\t\tfromVariable: 'A'\n\t\t\t},\n\t\t\ttype: 'relation',\n\t\t\tname: 'firstRelation',\n\t\t\twrappedInBrackets: true\n\t\t}\n\t});\n\temptyRoot.assignments.push({\n\t\ttype: 'assignment',\n\t\tname: 'B',\n\t\tchild: {\n\t\t\tmetaData: {\n\t\t\t\tfromVariable: 'B'\n\t\t\t},\n\t\t\ttype: 'relation',\n\t\t\tname: 'secondRelation',\n\t\t\twrappedInBrackets: true\n\t\t}\n\t});\n\temptyRoot.assignments.push({\n\t\ttype: 'assignment',\n\t\tname: 'C',\n\t\tchild: {\n\t\t\tmetaData: {\n\t\t\t\tfromVariable: 'A'\n\t\t\t},\n\t\t\ttype: 'relation',\n\t\t\tname: 'firstRelation',\n\t\t\twrappedInBrackets: true\n\t\t}\n\t});\n\temptyRoot.child = {\n\t\ttype: 'selection',\n\t\targ: {\n\t\t\ttype: 'valueExpr',\n\t\t\tdatatype: 'boolean',\n\t\t\tfunc: 'constant',\n\t\t\targs: [false]\n\t\t},\n\t\tchild: {\n\t\t\ttype: 'union',\n\t\t\tchild: {\n\t\t\t\tmetaData: {\n\t\t\t\t\tfromVariable: 'A'\n\t\t\t\t},\n\t\t\t\ttype: 'relation',\n\t\t\t\tname: 'firstRelation',\n\t\t\t\twrappedInBrackets: true\n\t\t\t},\n\t\t\tchild2: {\n\t\t\t\tmetaData: {\n\t\t\t\t\tfromVariable: 'B'\n\t\t\t\t},\n\t\t\t\ttype: 'relation',\n\t\t\t\tname: 'secondRelation',\n\t\t\t\twrappedInBrackets: true\n\t\t\t},\n\t\t\twrappedInBrackets: true\n\t\t}\n\t};\n\n\trelalgjs.replaceVariables(ast, relations);\n\n\tdeepEqual(ast, emptyRoot);\n});\n\ntest('test variables with cycle', function () {\n\tvar query = 'A = B ' + 'B = C ' + 'C = A ' + '(σ (false) ((C) union (B)))';\n\tvar ast = relalgjs.parseRelalg(query);\n\tunsetLineColumn(ast);\n\n\ttry {\n\t\trelalgjs.replaceVariables(ast, relations);\n\t\tok(false);\n\t} catch (e) {\n\t\tequal(e.message.indexOf('cyclic-usage') > -1, true);\n\t}\n});\n\ntest('test variables with name conflict', function () {\n\tvar query = 'A = B ' + 'secondRelation = A ' + '(A)';\n\tvar ast = relalgjs.parseRelalg(query);\n\tunsetLineColumn(ast);\n\n\ttry {\n\t\trelalgjs.replaceVariables(ast, relations);\n\t\tok(false);\n\t} catch (e) {\n\t\tequal(e.message.indexOf('conflict') > -1, true);\n\t}\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/db/tests/var_replacer_tests.js\n// module id = 165\n// module chunks = 1\n//# sourceURL=webpack:///./src/db/tests/var_replacer_tests.js?")}]);